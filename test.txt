{
file:./res/go/orderofsearch.go
contents:
"package res

//type TypeOfPage struct {
//	PageType string
//	Data     interface{}
//}
//
//func (t *TemplateManager) orderOfSearch() TypeOfPage {
//	const op = "Templates.orderOfSearch"
//
//	data := TypeOfPage{
//		PageType: "page",
//		Data:     nil,
//	}
//
//	slug := t.post.Slug
//	slugArr := strings.Split(slug, "/")
//	last := slugArr[len(slugArr)-1]
//
//	theme := t.store.Site.GetThemeConfig()
//
//	if _, ok := theme.Resources[last]; ok {
//		data.PageType = "archive"
//		data.Data = t.post.Post.Resource
//		return data
//	}
//
//	if t.store.Categories.ExistsBySlug(last) {
//
//		cat, err := t.store.Categories.GetBySlug(last)
//		if err != nil {
//			return data
//		}
//
//		parentCat, err := t.store.Categories.GetById(cat.Id)
//		if err != nil {
//			data.PageType = "category_child_archive"
//			data.Data = cat
//			return data
//		} else {
//			data.PageType = "category_archive"
//			data.Data = parentCat
//			return data
//		}
//	}
//
//	return data
//}"
}
{
file:./res/go/gin-paths.go
contents:
"package res

fmt.Println("------")
fmt.Printf("%+v\n", g.Request)
fmt.Printf("%+v\n", g.Request.Header.Get("origin"))
fmt.Println("------")

.go#L50"
}
{
file:./res/go/users.go
contents:
"package res

import (
	"bufio"
	"github.com/ainsleyclark/verbis/api/domain"
	validation "github.com/ainsleyclark/verbis/api/helpers/vaidation"
	"fmt"
	"github.com/spf13/cobra"
	"os"
	"strconv"
	"strings"
)

var (
	v validation.Validator
	usersCmd = &cobra.Command{
		Use:   "users",
		Short: "Access & modify the CMS users.",
		Long: `Calling users will enable you to add, update and delete users,
you will be able to assign role ids, and modify existing users that have
been stored in the cms database.`,
	}
)

// Add child commands
func init() {
	v = validation.New()
	usersCmd.AddCommand(listUsersCmd)
	usersCmd.AddCommand(createUserCmd)
}

// listCmd represents the list command
var listUsersCmd = &cobra.Command{
	Use:   "list",
	Short: "List's all users in the database.",
	Run: func(cmd *cobra.Command, args []string) {

		//users, err := app.store.User.GetAll()
		//if err != nil {
		//	fmt.Print(err)
		//}
		//
		//t := table.NewWriter()
		//t.SetOutputMirror(os.Stdout)
		//t.AppendHeader(table.Row{"# ID", "First Name", "Last Name", "Email", "Email Verified At", "Created At", "Updated At"})
		//
		//for _, v := range users {
		//	t.AppendRows([]table.Row{
		//		{v.Id, v.FirstName, v.LastName, v.Email, v.EmailVerifiedAt, v.CreatedAt, v.UpdatedAt},
		//	})
		//}
		//
		//t.Render()
	},
}

// createCmd represents the create command
var createUserCmd = &cobra.Command{
	Use:   "create",
	Short: "Creates a user in the database.",
	RunE: func(cmd *cobra.Command, args []string) error {

		reader := bufio.NewReader(os.Stdin)
		var user domain.User

		// First name
		firstName := ""
		for {
			fmt.Print("First name: ")
			firstName, _ = reader.ReadString('\n')
			user.FirstName = strings.TrimSuffix(firstName, "\n")
			err := v.CmdCheck("firstname", user)
			if  err != nil {
				fmt.Println(err)
			} else {
				break
			}
		}

		// Last name
		lastName := ""
		for {
			fmt.Print("Last name: ")
			lastName, _ = reader.ReadString('\n')
			user.LastName = strings.TrimSuffix(lastName, "\n")
			err := v.CmdCheck("lastname", user)
			if  err != nil {
				fmt.Println(err)
			} else {
				break
			}
		}

		// Email
		email := ""
		for {
			fmt.Print("Email address: ")
			email, _ = reader.ReadString('\n')
			user.Email = strings.TrimSuffix(email, "\n")
			err := v.CmdCheck("email", user)
			if  err != nil {
				fmt.Println(err)
			} else {
				break
			}
		}

		// Password
		password := ""
		for {
			fmt.Print("Password: ")
			password, _ = reader.ReadString('\n')
			user.Password = strings.TrimSuffix(password, "\n")
			err := v.CmdCheck("password", user)
			if  err != nil {
				fmt.Println(err)
			} else {
				break
			}
		}

		// Access Level
		accessLevel := ""
		for {
			fmt.Println("User a number to select an access level")
			fmt.Println("0) Banned")
			fmt.Println("1) Operator")
			fmt.Println("2) Administrator")
			fmt.Print("Access Level: ")
			accessLevel, _ = reader.ReadString('\n')

			_, err := strconv.Atoi(strings.TrimSuffix(accessLevel, "\n"))
			if err != nil {
				return err
			}

			//user.Role.Id = l
			err = v.CmdCheck("accesslevel", user)
			if  err != nil {
				fmt.Println(err)
			} else {
				break
			}
		}

		// Create
		_, err := app.store.User.Create(&user)
		if err != nil {
			return err
		}

		fmt.Println(user.FirstName + " created successfully!")

		return nil
	},
}"
}
{
file:./res/go/recovery.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package res

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/foolin/goview"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"html"
	"net/http"
	"reflect"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

const (
	STACKDEPTH = 16
)

type Recovery struct {
	Err        errors.Error
	SubMessage string
	Path       string
	Line       int
	Contents   string
	Language   string
	Stack      []Stack
	Highlight  int
	config     config.Configuration
	theme      domain.ThemeConfig
}

// TemplateStack defines the stack used for the error page
type Stack struct {
	File    string
	Line    int
	Name    string
	Message string
}

// FileLine defines the error for templating it includes the
// line & content of the error file.
type FileLine struct {
	Line    int
	Content string
}

func Recover(g *gin.Context, err interface{}) {
	const op = "Server.Recover"

	// IMPORTANT: Do not set anything else to be err here
	cfg, ok := config.New()
	if ok != nil {
		log.WithFields(log.Fields{
			"error": errors.Error{Code: errors.INTERNAL, Message: "Unable to get the configuration", Operation: op, Err: ok},
		}).Fatal()
	}

	rc := &Recovery{
		config: *cfg,
	}

	// Load up the Verbis error pages
	gvRecovery := goview.New(goview.Config{
		Root:         paths.Web(),
		Extension:    ".html",
		Master:       "layouts/main",
		DisableCache: true,
	})

	// Assign the error
	fmt.Println(err)
	rc.Err = *rc.setType(err)

	// Set the error for the logger & middleware
	g.Set("verbis_error", &rc.Err)

	// Get the stack
	rc.Stack = rc.getStack()

	// Get the file contents
	contents, err := rc.setFileContents()
	if err != nil {
		log.Panic(err)
	}
	rc.Contents = contents

	// Return the error page
	if err := gvRecovery.Render(g.Writer, http.StatusOK, "/templates/error", gin.H{
		"Error":         rc.Err,
		"Stack":         rc.Stack,
		"SubMessage":    rc.SubMessage,
		"RequestMethod": g.Request.Method,
		"File":          rc.getFileLines(rc.Contents, rc.Line, 10),
		"Highlight":     rc.Highlight,
		"LineNumber":    rc.Line,
		"FileLanguage":  rc.Language,
		"Url":           g.Request.URL.Path,
		"Ip":            g.ClientIP(),
		"DataLength":    g.Writer.Size(),
	}); err != nil {
		log.Panic(err)
	}
}

// Get the type of error and return new Verbis error
func (r *Recovery) setType(err interface{}) *errors.Error {
	errType := reflect.TypeOf(err).String()

	var errData errors.Error
	var stack = r.getStack()
	if errType == "*logrus.Entry" {
		entry, ok := err.(*log.Entry)
		if !ok {
			return nil
		}
		errData = entry.Data["error"].(errors.Error)

		r.Line = stack[8].Line
		r.Path = stack[8].File
		r.Highlight = 7
		r.Language = "go"

	} else {
		e, ok := err.(error)
		if !ok {
			return nil
		}
		if strings.Contains(e.Error(), "ViewEngine") {
			if err := r.handleTemplate(e); err != nil {
				panic(err)
			}
			errData = errors.Error{
				Code:      errors.TEMPLATE,
				Message:   fmt.Sprintf("Could not render the template %s: ", r.Path),
				Operation: "RenderTemplate",
				Err:       fmt.Errorf(e.Error()),
			}
			r.SubMessage = e.Error()
		} else {
			errData = errors.Error{
				Code:    errors.INTERNAL,
				Message: "Internal Verbis error, please report.",
				Err:     fmt.Errorf(e.Error()),
			}
		}
		r.Highlight = -1
	}

	return &errData
}

// getStack obtains the stack details from the caller
func (r *Recovery) getStack() []Stack {
	var stack []Stack

	const stackDepth = STACKDEPTH
	for c := 0; c < stackDepth; c++ {
		t, file, line, ok := runtime.Caller(c)
		if ok {
			stack = append(stack, Stack{
				File: file,
				Line: line,
				Name: runtime.FuncForPC(t).Name(),
			})
		}
	}

	return stack
}

// getFileContents gets the file contents of the errored file.
// Returns INTERNAL if the path could not be found
func (r *Recovery) setFileContents() (string, error) {
	const op = "Recovery.getFileContents"

	var fileContents string
	if ok := files.Exists(r.Path); ok {
		var err error
		if fileContents, err = files.GetFileContents(r.Path); err != nil {
			fmt.Println(err)
			return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not convert get file contents with path %s", r.Path), Operation: op, Err: err}
		} else {
			return fileContents, nil
		}
	}

	return fileContents, nil
}

// getTemplate obtains the file path for the template and the line number
// if the errors is directly associated with a template, it the assigns
// the variables to the Recovery struct.
// Returns INTERNAL if the line number could not be converted to an integer.
func (r *Recovery) handleTemplate(err error) error {
	const op = "Recovery.getTemplate"

	var (
		file string
		line int
	)

	tmpl := helpers.StringsBetween(err.Error(), "name:", ",")
	lineStr := regexp.MustCompile("[0-9]+").FindAllString(err.Error(), -1)
	if len(lineStr) > 0 {
		l, err := strconv.Atoi(lineStr[0])
		if err != nil {
			return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not convert %v to int", line), Operation: op, Err: err}
		}
		line = l
		file = paths.Theme() + "/" + tmpl + r.theme.FileExtension
	}

	r.Path = file
	r.Line = line
	r.Language = "handlebars"

	return nil
}

// Lines gets the range of lines of a file in between a limit
// Returns an array of file lines
func (r *Recovery) getFileLines(file string, line int, limit int) []FileLine {
	split := strings.Split(file, "\n")

	var fileLines []FileLine
	counter := line - (limit / 2)
	for i := 0; i < limit; i++ {
		if counter >= 0 && counter < len(split) {
			fileLines = append(fileLines, FileLine{
				Line:    counter + 1,
				Content: html.UnescapeString(strings.Replace(split[counter], " ", "&nbsp;", -1)),
			})
		}
		counter++
	}

	return fileLines
}"
}
{
file:./res/go/rowsclose.go
contents:
"package res

//rows := s.db.QueryRowx("SELECT posts.*, post_options.seo 'options.seo', post_options.meta 'options.meta' FROM posts LEFT JOIN post_options ON posts.id = post_options.page_id WHERE posts.slug = ? LIMIT 1", slug)
////for rows.Next() {
//err := rows.StructScan(&p)
//if err != nil {
//fmt.Println(err)
//}
////}
//err := rows.Close()
//if err != nil {
//fmt.Println(err)
//}
//"
}
{
file:./res/go/webp.go
contents:
"//package res
//
//import (
//	"bytes"
//	"github.com/chai2010/webp"
//	"image"
//	"io/ioutil"
//)

// Converts an image to webp based on compression and decoded image.
// Compression level is also set.
//func convertWebP(image image.Image, path string, compression int) {
//	const op = "MediaRepository.convertWebP"
//
//	var buf bytes.Buffer
//	var opts = webp.Options{
//		Lossless: true,
//		Quality:  float32(compression),
//	}
//
//	if err := webp.Encode(&buf, image, &opts); err != nil {
//		log.Error(err)
//	}
//
//	if err := ioutil.WriteFile(path + ".webp", buf.Bytes(), 0666); err != nil {
//		log.Error(err)
//	}
//
//	log.Info("WebP conversion ok with path: " + path + ".webp")
//}
//
//// Converts an image to webp based on compression and decoded image.
//// Compression level is also set.
//func convertWebP(image image.Image, path string, compression int) {
//	const op = "MediaRepository.convertWebP"
//
//	webpConfig, _ := webp.ConfigPreset(webp.PresetDefault, float32(compression))
//
//	// Create file and buffered writer
//	io, err := os.Create(path + ".webp")
//	if err != nil {
//		return
//	}
//	w := bufio.NewWriter(io)
//	defer func() {
//		w.Flush()
//		io.Close()
//	}()
//
//	if err := webp.EncodeRGBA(w, image, webpConfig); err != nil {
//		return
//	}
//
//	log.Info("WebP conversion ok with path: " + path + ".webp")
//}


// Converts an image to webp based on compression and decoded image.
// Compression level is also set.
//func convertWebP(image image.Image, path string, compression int) {
//	const op = "MediaRepository.convertWebP"
//
//	var buf bytes.Buffer
//
//	if err := webp.Encode(&buf, image, &webp.Options{Lossless: true}); err != nil {
//		log.Println(err)
//	}
//
//	if err := ioutil.WriteFile(path + ".webp", buf.Bytes(), 0666); err != nil {
//		log.Println(err)
//	}
//}"
}
{
file:./res/go/store.go
contents:
"package res

import (
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
)

var Store store

type store struct {
	User UserRepository
}

// Create a new database instance, connect to database.
func NewStore() (*sqlx.DB, error) {
	db, err := sqlx.Open("mysql", DBConnectString())

	if err != nil {
		return nil, fmt.Errorf("error opening database: %w", err)
	}
	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	Store = store{
		User: NewUserStore(db),
	}

	return db, nil
}"
}
{
file:./res/go/session.go
contents:
"


// SessionRepository defines methods for Sessions to interact with the database
type SessionRepository interface {
	GetByKey(sessionKey string) (*domain.UserSession, error)
	Create(id int, email string) (string, error)
	Update(sessionKey string) error
	Delete(userId int) error
	Has(userId int) bool
	Check(userId int) error
}

// SessionRepository defines the data layer for Sessions
type SessionStore struct {
	db *sqlx.DB
}

// newSession - Construct
func newSession(db *sqlx.DB) *SessionStore {
	return &SessionStore{
		db: db,
	}
}

// GetByKey gets the user session by key
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no posts available.
func (s *SessionStore) GetByKey(sessionKey string) (*domain.UserSession, error) {
	const op = "SessionRepository.GetByKey"
	var us domain.UserSession
	if err := s.db.Get(&us, "SELECT * FROM user_sessions WHERE session_key = ? LIMIT 1", sessionKey); err != nil {
		return &domain.UserSession{}, &errors.Error{Code: errors.NOTFOUND, Message:  fmt.Sprintf("Could not get user session with the session key: %v", sessionKey), Operation: op}
	}
	return &us, nil
}

// Create the user session once logged in, will return a
// unique session string and create a session within
// the user_sessions table.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *SessionStore) Create(id int, email string) (string, error) {
	const op = "SessionRepository.Create"

	sessionToken := encryption.GenerateSessionToken(email)
	q := "INSERT INTO user_sessions (user_id, session_key, login_time, last_seen_time) VALUES (?, ?, NOW(), NOW())"
	_, err := s.db.Exec(q, id, sessionToken)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the user session with the ID: %v", id), Operation: op, Err: err}
	}

	return sessionToken, nil
}

// Update session and set last seen time
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *SessionStore) Update(sessionKey string) error {
	const op = "SessionRepository.Update"
	q := "UPDATE user_sessions SET last_seen_time = NOW() WHERE session_key = ?"
	_, err := s.db.Exec(q, sessionKey)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not update last seen time in the user's session", Operation: op, Err: err}
	}
	return nil
}

// Delete the session of not valid
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *SessionStore) Delete(userId int) error {
	const op = "SessionRepository.Delete"
	if _, err := s.db.Exec("DELETE FROM user_sessions WHERE user_id = ?", userId); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete user session with user ID of: %v", userId), Operation: op, Err: err}
	}
	return nil
}

// Check if the user has a session
func (s *SessionStore) Has(userId int) bool {
	var has bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM user_sessions WHERE user_id = ?)", userId).Scan(&has)
	return has
}

// Check if the session is valid
// Returns errors.INTERNAL if the SQL query was invalid
// Returns errors.CONFLICT time has surpassed the configuration inactive session time variable.
func (s *SessionStore) Check(userId int) error {
	const op = "SessionRepository.Check"

	var inactiveFor int
	err := s.db.Get(&inactiveFor,"SELECT TIMESTAMPDIFF(MINUTE, last_seen_time, NOW()) AS valid FROM user_sessions WHERE user_id = ?", userId)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Unable to get user from sessions", Operation: op, Err: err}
	}

	if inactiveFor > config.Admin.InactiveSessionTime {
		return &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("User has been in active for %v minutes", inactiveFor), Operation: op, Err: err}
	}

	return nil
}"
}
{
file:./res/go/posts.go
contents:
"package res

import (
	"github.com/spf13/cobra"
)

var (
	postsCmd = &cobra.Command{
		Use:   "posts",
		Short: "Access the posts",
		Long: ``,
	}
)

// Add child commands
func init() {
	postsCmd.AddCommand(listPostsCmd)
}

// List all the posts within the database
var listPostsCmd = &cobra.Command{
	Use:   "list",
	Short: "List's all users in the database.",
	Run: func(cmd *cobra.Command, args []string) {

		//posts, err := app.store.Posts.GetAll()
		//if err != nil {
		//	log.Error(err)
		//}
		//
		//t := table.NewWriter()
		//t.SetOutputMirror(os.Stdout)
		//t.AppendHeader(table.Row{"#", "Slug", "Title", "Resource", "Page Template", "Layout", "Fields", "Status", "Page Views", "User ID", "Created At", "Updated At"})
		//
		//for _, v := range posts {
		//	t.AppendRows([]table.Row{
		//		{v.Id, v.Slug, v.Title, v.Resource, v.PageTemplate, v.Layout, v.Fields, v.Status, v.UserId, v.CreatedAt, v.UpdatedAt},
		//	})
		//}
		//
		//t.Render()
	},
}"
}
{
file:./res/go/resources.go
contents:
"package res

import (
	gojson "encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/database"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/jmoiron/sqlx"
	"time"
)

type Resources struct {
	db *sqlx.DB
	config *Config
}

type Resource struct {
	ID				int			`db:"id" json:"id"`
	Name			string 		`db:"name" json:"name"`
	FriendlyName	string 		`db:"friendly_name" json:"friendly_name"`
	Slug			string 		`db:"slug" json:"slug"`
	Icon			string 		`db:"icon" json:"icon"`
	CreatedAt		time.Time	`db:"created_at" json:"created_at"`
	UpdatedAt		time.Time	`db:"updated_at" json:"updated_at"`
}

type Config struct {
	Theme theme `json:"theme"`
	resources
}

type theme struct {
	Name	string	`json:"name"`
	Author	string	`json:"author"`
	Version	string	`json:"version"`
}

type resources struct {
	Resource	map[string]resource `json:"resources"`
}

type resource struct {
	Name    string  `json:"name"`
	Options options `json:"options"`
}

type options struct {
	Slug string `icon:"name"`
	Icon string `icon:"name"`
}

func NewResources(db *database.DB) (*Resources, error) {

	// Create new resources instance
	r := &Resources{
		db: db.Sqlx,
	}

	// Load config
	c, err:= r.Load()
	if err != nil {
		return &Resources{}, err
	}
	r.config = c


	//Purge to database


	return r, nil
}

func (s *Resources) Load() (*Config, error) {

	// Retrieve the theme JSON file
	jsonFile, err := helpers.Read(paths.Theme() + "/config.json")
	if err != nil {
		return &Config{}, err
	}

	// Unmarshal the config file into the Config struct
	var c Config
	err = gojson.Unmarshal(jsonFile, &c)
	if err != nil {
		fmt.Print("here")
		return &Config{}, err
	}

	// TEST: Pretty print
	pretty, _ := gojson.MarshalIndent(c, "", "\t")
	fmt.Print(string(pretty))

	return &c, nil
}

// Get all resources
func (s *Resources) GetAll() ([]Resource, error) {
	var r []Resource
	if err := s.db.Select(&r, "SELECT * FROM resources"); err != nil {
		return nil, fmt.Errorf("Could not get resources - %w", err)
	}
	return r, nil
}

// Get resource by ID
func (s *Resources) GetById(id int) (Resource, error) {
	var r Resource
	if err := s.db.Get(&r, "SELECT * FROM resources WHERE id = ?", id); err != nil {
		return Resource{}, fmt.Errorf("Could not get resource with the ID %v - %w", id, err)
	}
	return r, nil
}

// Get resource by name
func (s *Resources) GetByName(name string) (Resource, error) {
	var r Resource
	if err := s.db.Get(&r, "SELECT * FROM resources WHERE name = ?", name); err != nil {
		return Resource{}, fmt.Errorf("Could not get resource with the name %v - %w", name, err)
	}
	return r, nil
}

// Update resource
func (s *Resources) Update(r *Resource) error {
	_, err := s.GetById(r.ID)
	if err != nil {
		return err
	}

	// TODO: Update all posts that share a resource

	q := "UPDATE resources SET name = ?, friendly_name = ?, slug = ?, icon = ?, updated_at = NOW() WHERE id = ?"
	_, err = s.db.Exec(q, r.Name, r.FriendlyName, r.Slug, r.Icon)
	if err != nil {
		return fmt.Errorf("Could not update the resource %v - %w", r.Name, err)
	}

	return nil
}

// Create a resource
func (s *Resources) Create(r *Resource) error {
	q := "INSERT INTO resources (name, friendly_name, slug, icon, updated_at, created_at) VALUES (?, ?, ?, ?, NOW(), NOW())"
	_, err := s.db.Exec(q, r.Name, r.FriendlyName, r.Slug, r.Icon)

	if err != nil {
		return fmt.Errorf("Could not create the resource, %v - %w", r.Name, err)
	}

	return nil
}

// Insert all resources into database
func (s *Resources) insertToDB() error {
	for k, v := range s.config.Resource {

		// Check to see if the resource exists
		_, err := s.GetByName(k)
		if err != nil {
			continue
		}

		r := Resource{
			Name: k,
			FriendlyName: v.Name,
			Slug: v.Options.Slug,
			Icon: v.Options.Icon,
		}

		err = s.Create(&r)
		if err != nil {
			return err
		}
	}

	return nil
}


// Dump json file"
}
{
file:./res/go/templates.go
contents:
"package res

import (
	"encoding/json"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/foolin/goview"
	"github.com/foolin/goview/supports/ginview"
	"os"
)

func discord() {
	master :=
		`
		Hello: {{ .names }}
		World: {{ .otherkey }}
		`

	data := make(map[string]string)
	data["names"] = "banana!"
	data["otherkey"] = "otherbanana!"

	masterTmpl, err := template.New("master").Parse(master)
	if err != nil {
		//log.Fatal(err)
	}
	if err := masterTmpl.Execute(os.Stdout, data); err != nil {
		//log.Fatal(err)
	}
}

package main

import (
"html/template"
"log"
"os"
)

type TemplateData struct {
	Fields map[string]string
}

func main() {

	templateString := `
Hello: {{ .Fields.names }}
World: {{ .Fields.other_key }}
`

	d := TemplateData{Fields: make(map[string]string)}
	d.Fields["names"] = "banana!"
	d.Fields["otherkey"] = "otherbanana!"

	masterTmpl, err := template.New("templateString").Parse(templateString)
	if err != nil {
		log.Fatal(err)
	}
	if err := masterTmpl.Execute(os.Stdout, d); err != nil {
		log.Fatal(err)
	}
}

package templates

import (
"cms/api/domain"
"cms/api/helpers/paths"
"cms/config"
"encoding/json"
"github.com/foolin/goview"
"github.com/foolin/goview/supports/ginview"
"html/template"
)

type ViewData struct {
	Post		domain.Post
}

func GetViewData(post *domain.Post) *ViewData {

	fields := make(map[string]string)
	_ = json.Unmarshal(post.Fields, &fields)

	t := newFields(fields)


	c.server.HTMLRender = ginview.New(goview.Config{
		Root:      paths.Theme(),
		Extension: config.Template["file_extension"],
		Master:    "/layouts/main",
		Partials:  []string{},
		DisableCache: true,
		Funcs: template.FuncMap{
			"getField": func(field string) string {
				if _, found := fields[field]; found {
					return fields[field]
				} else {
					return ""
				}
			},
			"getFields": func() map[string]string {
				return fields
			},
			"hasField": func(field string) bool {
				if _, found := fields[field]; found {
					return true
				}
				return false
			},
			"test":
		},
	})

	return &ViewData{}
}"
}
{
file:./res/console/options.go
contents:
"package console

import (
	"fmt"
	"github.com/common-nighthawk/go-figure"
	"github.com/gookit/color"
)

// Welcome message
func Welcome() {
	figure := figure.NewColorFigure("Reddico CMS", "cybermedium", "reset", true)
	figure.Print()
	fmt.Printf("\n%s version %s\n", color.Green.Render("Reddico CMS"), color.Yellow.Render("0.0.1"))
	fmt.Printf("\n")
}

// Display options/help
func Options() {

	color.Yellow.Println("- Options")

	// Help
	color.Green.Print("    help")
	fmt.Print("\t\tDisplay this help message\n")
	color.Green.Print("    exit")
	fmt.Print("\t\tExit the shell\n\n")

	color.Yellow.Println("- Available Commands")

	// Serve
	color.Yellow.Println("serve")
	color.Green.Print("    serve\t\t")
	fmt.Print("Serve the CMS\n")
	color.Green.Print("    serve:live\t\t")
	fmt.Print("Serve the CMS with Gin\n")

	// Make
	color.Yellow.Println("make")
	color.Green.Print("    make:controller\t")
	fmt.Print("Create a new controller instance\n")
	color.Green.Print("    make:migration\t")
	fmt.Print("Create a new migration file\n")
	color.Green.Print("    make:model\t")
	fmt.Print("\tCreate a new model instance\n")

	// Migrate
	color.Yellow.Println("migrate")
	color.Green.Print("    migrate\t\t")
	fmt.Print("Run all database migrations\n")
	color.Green.Print("    migrate:fresh\t")
	fmt.Print("Drop all tables and re-run all migrations\n")
	color.Green.Print("    migrate:fresh\t")
	fmt.Print("Drop all tables and re-run all migrations\n")

	fmt.Println()
}"
}
{
file:./res/console/process.go
contents:
"package console

import (
	"bufio"
	"cms/core/bootstrap"
	"fmt"
	"github.com/gookit/color"
	"os"
	"strings"
)

func Process() {

	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Print("-> ")
		command, _ := reader.ReadString('\n')
		command = strings.Replace(command, "\n", "", -1)
		argument1 := ""
		argument2 := ""

		if strings.Contains(command, "make") {

			if !strings.Contains(command, ":") {
				color.Red.Println("Command not found")
			} else {
				stringSlice := strings.Split(command, ":")
				argSlice := strings.Split(stringSlice[1], " ")

				if len(argSlice) == 1 {
					color.Red.Println("Pass two arguments to make. E.g make:controller filename")
				} else {
					command = stringSlice[0]
					argument1 = argSlice[0]
					argument2 = argSlice[1]
				}
			}
		}

		switch command {
		case "help":
			Options()
			break
		case "clear":
			print("\033[H\033[2J")
			break
		case "serve":
			bootstrap.Load()
			break
		case "make":
			make(argument1, argument2)
			break
		case "migrate":
			fmt.Println("in")
			//migrate.Migrate.Load()
			//migrate.Migrate.Fresh()
		case "exit":
			os.Exit(0)
			break
		default:
			color.Red.Println("Command not found")
		}
	}
}

// Process arguments passed to console
func processArgs(command string) {

}

// Serve application
func serve(option string) {

}

// Make a module
func make(module string, name string) {

	switch module {
	case "migration":
		//migrate.Migrate.Load()
		//migrate.Migrate.Up()
		break
	case "controller":
		fmt.Print("In make controller")
		break
	case "model":
		fmt.Print("In make model")
		break
	}
}"
}
{
file:./api/minify/minify_test.go
contents:
"package minify

import (
	"bytes"
	"github.com/stretchr/testify/assert"
	"os"
	"testing"
)

func TestMinify_MinifyBytes(t *testing.T) {

	m := New(defaultConfig)

	tt := map[string]struct {
		input string
		mime  string
		want  interface{}
	}{
		"HTML": {
			` <div> <i> test </i> <b> test </b> </div> `,
			HTML,
			`<div><i>test</i> <b>test</b></div>`,
		},
		"CSS": {
			`/*comment*/`,
			CSS,
			``,
		},
		"JS": {
			`/*comment*/a`,
			Javascript,
			`a`,
		},
		"SVG": {
			`<!-- comment -->`,
			SVG,
			``,
		},
		"JSON": {
			`{ "a": [1, 2] }`,
			JSON,
			`{"a":[1,2]}`,
		},
		"XML": {
			`<!-- comment -->`,
			XML,
			``,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			b := bytes.NewBuffer([]byte(test.input))
			got, _ := m.MinifyBytes(b, test.mime)
			assert.Equal(t, test.want, string(got))
		})
	}
}

func TestMinify_MinifyBytesError(t *testing.T) {
	m := New(defaultConfig)

	t.Run("Error", func(t *testing.T) {
		orignal := htmlMime
		defer func() {
			htmlMime = orignal
		}()

		htmlMime = "wrongval"
		b := bytes.NewBuffer([]byte(""))
		_, err := m.MinifyBytes(b, HTML)
		assert.Contains(t, err.Error(), "Minifier.execute: minifier does not exist for mimetype")
	})
}

func TestMinify_MinifyBytesNotParsed(t *testing.T) {

	m := New(Config{
		MinifyHTML: false,
		MinifyCSS:  false,
		MinifyJS:   false,
		MinifySVG:  false,
		MinifyJSON: false,
		MinifyXML:  false,
	})

	tt := map[string]struct {
		input string
		mime  string
		want  interface{}
	}{
		"HTML": {
			` <div> <i> test </i> <b> test </b> </div> `,
			HTML,
			` <div> <i> test </i> <b> test </b> </div> `,
		},
		"CSS": {
			`/*comment*/`,
			CSS,
			`/*comment*/`,
		},
		"JS": {
			`/*comment*/a`,
			Javascript,
			`/*comment*/a`,
		},
		"SVG": {
			`<!-- comment -->`,
			SVG,
			`<!-- comment -->`,
		},
		"JSON": {
			`{ "a": [1, 2] }`,
			JSON,
			`{ "a": [1, 2] }`,
		},
		"XML": {
			`<!-- comment -->`,
			XML,
			`<!-- comment -->`,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			b := bytes.NewBuffer([]byte(test.input))
			got, _ := m.MinifyBytes(b, test.mime)
			assert.Equal(t, test.want, string(got))
		})
	}
}

func TestMinify_Minify(t *testing.T) {
	m := New(defaultConfig)

	file, err := os.Create(os.TempDir() + "verbis-test-minify")
	assert.NoError(t, err)

	defer os.Remove(file.Name())

	_, err = file.Write([]byte(` <div> <i> test </i> <b> test </b> </div> `))
	assert.NoError(t, err)

	got, err := m.Minify(file.Name(), HTML)
	assert.NoError(t, err)

	assert.Equal(t, []byte(`<div><i>test</i> <b>test</b></div>`), got)

	err = file.Close()
	assert.NoError(t, err)
}

func TestMinify_MinifyError(t *testing.T) {
	m := New(defaultConfig)
	_, err := m.Minify("wrong", HTML)
	assert.Contains(t, err.Error(), "Minifier.Minify: open wrong: no such file or directory")
}"
}
{
file:./api/minify/minify.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package minify

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	min "github.com/tdewolff/minify/v2"
	"github.com/tdewolff/minify/v2/css"
	"github.com/tdewolff/minify/v2/html"
	"github.com/tdewolff/minify/v2/js"
	"github.com/tdewolff/minify/v2/json"
	"github.com/tdewolff/minify/v2/svg"
	"github.com/tdewolff/minify/v2/xml"
	"io/ioutil"
	"regexp"
)

// Minifier represents functions for executing the minify package.
type Minifier interface {
	Minify(name string, mime string) ([]byte, error)
	MinifyBytes(b *bytes.Buffer, mime string) ([]byte, error)
}

// Minify represents the minify type along with the minify
// package and options to determine whether or not to
// minify the asset passed.
type minify struct {
	pkg    *min.M
	config Config
}

// New
//
// Creates a new Minify instance, if no config options are
// passed the defaultConfig is used.
func New(cfg ...Config) *minify {
	m := min.New()

	config := defaultConfig
	if len(cfg) == 1 {
		config = cfg[0]
	}

	return &minify{
		pkg:    m,
		config: config,
	}
}

// Minify
//
// Minifies a file & calls the compare function to render
// the file.
func (m *minify) Minify(name string, mime string) ([]byte, error) {
	const op = "Minifier.Minify"

	b, err := ioutil.ReadFile(name)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to read file contents"), Operation: op, Err: err}
	}

	return m.compare(bytes.NewBuffer(b), mime)
}

// MinifyBytes
//
// Minifies existing bytes.Buffer & calls the compare function
// to render the file. Usually used for HTML files.
func (m *minify) MinifyBytes(b *bytes.Buffer, mime string) ([]byte, error) {
	return m.compare(b, mime)
}

// compare
//
// Gets the options struct in order to see if the user has
// selected the type of minification. It then compares
// mime's and executes the file to be minified.
func (m *minify) compare(b *bytes.Buffer, mime string) ([]byte, error) {
	var (
		render []byte
		err    error
	)

	switch mime {
	case HTML:
		m.pkg.AddFunc(htmlMime, html.Minify)
		render, err = m.execute(b, m.config.MinifyHTML, mime)
	case CSS:
		m.pkg.AddFunc(cssMime, css.Minify)
		render, err = m.execute(b, m.config.MinifyCSS, mime)
	case Javascript:
		m.pkg.AddFuncRegexp(regexp.MustCompile(jsMime), js.Minify)
		render, err = m.execute(b, m.config.MinifyJS, mime)
	case SVG:
		m.pkg.AddFunc(svgMime, svg.Minify)
		render, err = m.execute(b, m.config.MinifySVG, mime)
	case JSON:
		m.pkg.AddFuncRegexp(regexp.MustCompile(jsonMime), json.Minify)
		render, err = m.execute(b, m.config.MinifyJSON, mime)
	case XML:
		m.pkg.AddFuncRegexp(regexp.MustCompile(xmlMime), xml.Minify)
		render, err = m.execute(b, m.config.MinifyXML, mime)
	}

	if err != nil {
		return nil, err
	}

	return render, nil
}

// execute
//
// Execute the buffer.Bytes depending onn the user selection
// in the Config table.
//
// Returns the original bytes if the minification failed.
// Returns errors.INTERNAL if something went wrong minifying the file.
func (m *minify) execute(buf *bytes.Buffer, allow bool, mime string) ([]byte, error) {
	const op = "Minifier.execute"

	if allow {
		render, err := m.pkg.Bytes(mime, buf.Bytes())
		if err != nil {
			return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not minify the file"), Operation: op, Err: err}
		}
		return render, nil
	}

	return buf.Bytes(), nil
}"
}
{
file:./api/minify/config.go
contents:
"package minify

const (
	// HTML mime type for comparison
	HTML = "text/html"
	// CSS mime type for comparison
	CSS = "text/css"
	// Javascript mime type for comparison
	Javascript = "application/javascript"
	// SVG mime type for comparison
	SVG = "image/svg+xml"
	// JSON mime type for comparison
	JSON = "application/json"
	// XML mime type for comparison
	XML = "text/xml"
)

var (
	// The default configuration for when none is passed
	defaultConfig = Config{
		MinifyHTML: true,
		MinifyCSS:  true,
		MinifyJS:   true,
		MinifySVG:  true,
		MinifyJSON: true,
		MinifyXML:  true,
	}
	// htmlMime is the default for HTML regexp for the pkg minifier
	htmlMime = `text/html`
	// cssMime is the default for CSS regexp for the pkg minifier
	cssMime = `text/css`
	// jsMime is the default for JS regexp for the pkg minifier
	jsMime = `^(application|text)/(x-)?(java|ecma)script$`
	// svgMime is the default for SVG regexp for the pkg minifier
	svgMime = `image/svg+xml`
	// jsonMime is the default for JSON regexp for the pkg minifier
	jsonMime = `[/+]json$`
	// xmlMime is the default for XML regexp for the pkg minifier
	xmlMime = `[/+]xml$`
)

// Config represents the options for minifying output.
type Config struct {
	MinifyHTML bool
	MinifyCSS  bool
	MinifyJS   bool
	MinifySVG  bool
	MinifyJSON bool
	MinifyXML  bool
}"
}
{
file:./api/mocks/minify/Minifier.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	bytes "bytes"

	mock "github.com/stretchr/testify/mock"
)

// Minifier is an autogenerated mock type for the Minifier type
type Minifier struct {
	mock.Mock
}

// Minify provides a mock function with given fields: name, mime
func (_m *Minifier) Minify(name string, mime string) ([]byte, error) {
	ret := _m.Called(name, mime)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, string) []byte); ok {
		r0 = rf(name, mime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(name, mime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinifyBytes provides a mock function with given fields: b, mime
func (_m *Minifier) MinifyBytes(b *bytes.Buffer, mime string) ([]byte, error) {
	ret := _m.Called(b, mime)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*bytes.Buffer, string) []byte); ok {
		r0 = rf(b, mime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bytes.Buffer, string) error); ok {
		r1 = rf(b, mime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/importer/Importer.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// Importer is an autogenerated mock type for the Importer type
type Importer struct {
	mock.Mock
}

// Import provides a mock function with given fields:
func (_m *Importer) Import() {
	_m.Called()
}"
}
{
file:./api/mocks/importer/uploader.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	multipart "mime/multipart"

	mock "github.com/stretchr/testify/mock"
)

// uploader is an autogenerated mock type for the uploader type
type uploader struct {
	mock.Mock
}

// Execute provides a mock function with given fields: file, url, err
func (_m *uploader) Execute(file *multipart.FileHeader, url string, err error) string {
	ret := _m.Called(file, url, err)

	var r0 string
	if rf, ok := ret.Get(0).(func(*multipart.FileHeader, string, error) string); ok {
		r0 = rf(file, url, err)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}"
}
{
file:./api/mocks/cache/Cacher.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// Cacher is an autogenerated mock type for the Cacher type
type Cacher struct {
	mock.Mock
}

// Flush provides a mock function with given fields:
func (_m *Cacher) Flush() {
	_m.Called()
}

// Get provides a mock function with given fields: k
func (_m *Cacher) Get(k string) (interface{}, bool) {
	ret := _m.Called(k)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(k)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(k)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Set provides a mock function with given fields: k, x, d
func (_m *Cacher) Set(k string, x interface{}, d time.Duration) {
	_m.Called(k, x, d)
}"
}
{
file:./api/mocks/recovery/Recovery.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"

	recovery "github.com/ainsleyclark/verbis/api/recovery"
)

// Recovery is an autogenerated mock type for the Recovery type
type Recovery struct {
	mock.Mock
}

// HttpRecovery provides a mock function with given fields:
func (_m *Recovery) HttpRecovery() gin.HandlerFunc {
	ret := _m.Called()

	var r0 gin.HandlerFunc
	if rf, ok := ret.Get(0).(func() gin.HandlerFunc); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.HandlerFunc)
		}
	}

	return r0
}

// Recover provides a mock function with given fields: cfg
func (_m *Recovery) Recover(cfg recovery.Config) []byte {
	ret := _m.Called(cfg)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(recovery.Config) []byte); ok {
		r0 = rf(cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}"
}
{
file:./api/mocks/recovery/TplData.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	recovery "github.com/ainsleyclark/verbis/api/recovery"
	mock "github.com/stretchr/testify/mock"
)

// TplData is an autogenerated mock type for the TplData type
type TplData struct {
	mock.Mock
}

// Execute provides a mock function with given fields:
func (_m *TplData) Execute() *recovery.Data {
	ret := _m.Called()

	var r0 *recovery.Data
	if rf, ok := ret.Get(0).(func() *recovery.Data); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*recovery.Data)
		}
	}

	return r0
}"
}
{
file:./api/mocks/recovery/trace/Tracer.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	trace "github.com/ainsleyclark/verbis/api/recovery/trace"
	mock "github.com/stretchr/testify/mock"
)

// Tracer is an autogenerated mock type for the Tracer type
type Tracer struct {
	mock.Mock
}

// Trace provides a mock function with given fields: depth, skip
func (_m *Tracer) Trace(depth int, skip int) trace.Stack {
	ret := _m.Called(depth, skip)

	var r0 trace.Stack
	if rf, ok := ret.Get(0).(func(int, int) trace.Stack); ok {
		r0 = rf(depth, skip)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(trace.Stack)
		}
	}

	return r0
}"
}
{
file:./api/mocks/recovery/Resolver.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	tpl "github.com/ainsleyclark/verbis/api/tpl"
)

// Resolver is an autogenerated mock type for the Resolver type
type Resolver struct {
	mock.Mock
}

// Execute provides a mock function with given fields: custom
func (_m *Resolver) Execute(custom bool) (string, tpl.TemplateExecutor, bool) {
	ret := _m.Called(custom)

	var r0 string
	if rf, ok := ret.Get(0).(func(bool) string); ok {
		r0 = rf(custom)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 tpl.TemplateExecutor
	if rf, ok := ret.Get(1).(func(bool) tpl.TemplateExecutor); ok {
		r1 = rf(custom)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(tpl.TemplateExecutor)
		}
	}

	var r2 bool
	if rf, ok := ret.Get(2).(func(bool) bool); ok {
		r2 = rf(custom)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}"
}
{
file:./api/mocks/tpl/TemplateHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"

	template "html/template"

	tpl "github.com/ainsleyclark/verbis/api/tpl"
)

// TemplateHandler is an autogenerated mock type for the TemplateHandler type
type TemplateHandler struct {
	mock.Mock
}

// Data provides a mock function with given fields: ctx, post
func (_m *TemplateHandler) Data(ctx *gin.Context, post *domain.PostData) interface{} {
	ret := _m.Called(ctx, post)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(*gin.Context, *domain.PostData) interface{}); ok {
		r0 = rf(ctx, post)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// FuncMap provides a mock function with given fields: ctx, post, cfg
func (_m *TemplateHandler) FuncMap(ctx *gin.Context, post *domain.PostData, cfg tpl.TemplateConfig) template.FuncMap {
	ret := _m.Called(ctx, post, cfg)

	var r0 template.FuncMap
	if rf, ok := ret.Get(0).(func(*gin.Context, *domain.PostData, tpl.TemplateConfig) template.FuncMap); ok {
		r0 = rf(ctx, post, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(template.FuncMap)
		}
	}

	return r0
}

// GenericFuncMap provides a mock function with given fields:
func (_m *TemplateHandler) GenericFuncMap() template.FuncMap {
	ret := _m.Called()

	var r0 template.FuncMap
	if rf, ok := ret.Get(0).(func() template.FuncMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(template.FuncMap)
		}
	}

	return r0
}

// Prepare provides a mock function with given fields: c
func (_m *TemplateHandler) Prepare(c tpl.TemplateConfig) tpl.TemplateExecutor {
	ret := _m.Called(c)

	var r0 tpl.TemplateExecutor
	if rf, ok := ret.Get(0).(func(tpl.TemplateConfig) tpl.TemplateExecutor); ok {
		r0 = rf(c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tpl.TemplateExecutor)
		}
	}

	return r0
}"
}
{
file:./api/mocks/tpl/TemplateFuncGetter.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"

	template "html/template"

	tpl "github.com/ainsleyclark/verbis/api/tpl"
)

// TemplateFuncGetter is an autogenerated mock type for the TemplateFuncGetter type
type TemplateFuncGetter struct {
	mock.Mock
}

// FuncMap provides a mock function with given fields: ctx, post, cfg
func (_m *TemplateFuncGetter) FuncMap(ctx *gin.Context, post *domain.PostData, cfg tpl.TemplateConfig) template.FuncMap {
	ret := _m.Called(ctx, post, cfg)

	var r0 template.FuncMap
	if rf, ok := ret.Get(0).(func(*gin.Context, *domain.PostData, tpl.TemplateConfig) template.FuncMap); ok {
		r0 = rf(ctx, post, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(template.FuncMap)
		}
	}

	return r0
}

// GenericFuncMap provides a mock function with given fields:
func (_m *TemplateFuncGetter) GenericFuncMap() template.FuncMap {
	ret := _m.Called()

	var r0 template.FuncMap
	if rf, ok := ret.Get(0).(func() template.FuncMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(template.FuncMap)
		}
	}

	return r0
}"
}
{
file:./api/mocks/tpl/tplimpl/fileHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	tpl "github.com/ainsleyclark/verbis/api/tpl"
	mock "github.com/stretchr/testify/mock"
)

// fileHandler is an autogenerated mock type for the fileHandler type
type fileHandler struct {
	mock.Mock
}

// Execute provides a mock function with given fields: config, template
func (_m *fileHandler) Execute(config tpl.TemplateConfig, template string) (string, error) {
	ret := _m.Called(config, template)

	var r0 string
	if rf, ok := ret.Get(0).(func(tpl.TemplateConfig, string) string); ok {
		r0 = rf(config, template)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(tpl.TemplateConfig, string) error); ok {
		r1 = rf(config, template)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/tpl/TemplateExecutor.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	gin "github.com/gin-gonic/gin"

	io "io"

	mock "github.com/stretchr/testify/mock"

	tpl "github.com/ainsleyclark/verbis/api/tpl"
)

// TemplateExecutor is an autogenerated mock type for the TemplateExecutor type
type TemplateExecutor struct {
	mock.Mock
}

// Config provides a mock function with given fields:
func (_m *TemplateExecutor) Config() tpl.TemplateConfig {
	ret := _m.Called()

	var r0 tpl.TemplateConfig
	if rf, ok := ret.Get(0).(func() tpl.TemplateConfig); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tpl.TemplateConfig)
		}
	}

	return r0
}

// Execute provides a mock function with given fields: w, name, data
func (_m *TemplateExecutor) Execute(w io.Writer, name string, data interface{}) (string, error) {
	ret := _m.Called(w, name, data)

	var r0 string
	if rf, ok := ret.Get(0).(func(io.Writer, string, interface{}) string); ok {
		r0 = rf(w, name, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(io.Writer, string, interface{}) error); ok {
		r1 = rf(w, name, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutePost provides a mock function with given fields: w, name, ctx, post
func (_m *TemplateExecutor) ExecutePost(w io.Writer, name string, ctx *gin.Context, post *domain.PostData) (string, error) {
	ret := _m.Called(w, name, ctx, post)

	var r0 string
	if rf, ok := ret.Get(0).(func(io.Writer, string, *gin.Context, *domain.PostData) string); ok {
		r0 = rf(w, name, ctx, post)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(io.Writer, string, *gin.Context, *domain.PostData) error); ok {
		r1 = rf(w, name, ctx, post)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor provides a mock function with given fields:
func (_m *TemplateExecutor) Executor() tpl.TemplateExecutor {
	ret := _m.Called()

	var r0 tpl.TemplateExecutor
	if rf, ok := ret.Get(0).(func() tpl.TemplateExecutor); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tpl.TemplateExecutor)
		}
	}

	return r0
}

// Exists provides a mock function with given fields: template
func (_m *TemplateExecutor) Exists(template string) bool {
	ret := _m.Called(template)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(template)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}"
}
{
file:./api/mocks/tpl/TemplateDataGetter.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"
)

// TemplateDataGetter is an autogenerated mock type for the TemplateDataGetter type
type TemplateDataGetter struct {
	mock.Mock
}

// Data provides a mock function with given fields: ctx, post
func (_m *TemplateDataGetter) Data(ctx *gin.Context, post *domain.PostData) interface{} {
	ret := _m.Called(ctx, post)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(*gin.Context, *domain.PostData) interface{}); ok {
		r0 = rf(ctx, post)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}"
}
{
file:./api/mocks/tpl/TemplateConfig.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// TemplateConfig is an autogenerated mock type for the TemplateConfig type
type TemplateConfig struct {
	mock.Mock
}

// GetExtension provides a mock function with given fields:
func (_m *TemplateConfig) GetExtension() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetMaster provides a mock function with given fields:
func (_m *TemplateConfig) GetMaster() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetRoot provides a mock function with given fields:
func (_m *TemplateConfig) GetRoot() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}"
}
{
file:./api/mocks/tpl/funcs/partial/PartialFunc.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	template "html/template"
)

// PartialFunc is an autogenerated mock type for the PartialFunc type
type PartialFunc struct {
	mock.Mock
}

// Execute provides a mock function with given fields: name, data
func (_m *PartialFunc) Execute(name string, data ...interface{}) (template.HTML, error) {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, data...)
	ret := _m.Called(_ca...)

	var r0 template.HTML
	if rf, ok := ret.Get(0).(func(string, ...interface{}) template.HTML); ok {
		r0 = rf(name, data...)
	} else {
		r0 = ret.Get(0).(template.HTML)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(name, data...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/render/headerWriter.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// headerWriter is an autogenerated mock type for the headerWriter type
type headerWriter struct {
	mock.Mock
}

// Cache provides a mock function with given fields: g
func (_m *headerWriter) Cache(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/render/SiteMapper.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// SiteMapper is an autogenerated mock type for the SiteMapper type
type SiteMapper struct {
	mock.Mock
}

// ClearCache provides a mock function with given fields:
func (_m *SiteMapper) ClearCache() {
	_m.Called()
}

// GetIndex provides a mock function with given fields:
func (_m *SiteMapper) GetIndex() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPages provides a mock function with given fields: resource
func (_m *SiteMapper) GetPages(resource string) ([]byte, error) {
	ret := _m.Called(resource)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(resource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(resource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetXSL provides a mock function with given fields: index
func (_m *SiteMapper) GetXSL(index bool) ([]byte, error) {
	ret := _m.Called(index)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(bool) []byte); ok {
		r0 = rf(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(bool) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/render/Renderer.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// Renderer is an autogenerated mock type for the Renderer type
type Renderer struct {
	mock.Mock
}

// Asset provides a mock function with given fields: g
func (_m *Renderer) Asset(g *gin.Context) (*string, *[]byte, error) {
	ret := _m.Called(g)

	var r0 *string
	if rf, ok := ret.Get(0).(func(*gin.Context) *string); ok {
		r0 = rf(g)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 *[]byte
	if rf, ok := ret.Get(1).(func(*gin.Context) *[]byte); ok {
		r1 = rf(g)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*[]byte)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*gin.Context) error); ok {
		r2 = rf(g)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotFound provides a mock function with given fields: g
func (_m *Renderer) NotFound(g *gin.Context) {
	_m.Called(g)
}

// Page provides a mock function with given fields: g
func (_m *Renderer) Page(g *gin.Context) ([]byte, error) {
	ret := _m.Called(g)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*gin.Context) []byte); ok {
		r0 = rf(g)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context) error); ok {
		r1 = rf(g)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Upload provides a mock function with given fields: g
func (_m *Renderer) Upload(g *gin.Context) (*string, *[]byte, error) {
	ret := _m.Called(g)

	var r0 *string
	if rf, ok := ret.Get(0).(func(*gin.Context) *string); ok {
		r0 = rf(g)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 *[]byte
	if rf, ok := ret.Get(1).(func(*gin.Context) *[]byte); ok {
		r1 = rf(g)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*[]byte)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*gin.Context) error); ok {
		r2 = rf(g)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}"
}
{
file:./api/mocks/render/ErrorHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// ErrorHandler is an autogenerated mock type for the ErrorHandler type
type ErrorHandler struct {
	mock.Mock
}

// NotFound provides a mock function with given fields: g
func (_m *ErrorHandler) NotFound(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/models/MediaRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"

	params "github.com/ainsleyclark/verbis/api/helpers/params"
)

// MediaRepository is an autogenerated mock type for the MediaRepository type
type MediaRepository struct {
	mock.Mock
}

// Delete provides a mock function with given fields: id
func (_m *MediaRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: name
func (_m *MediaRepository) Exists(name string) bool {
	ret := _m.Called(name)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: meta
func (_m *MediaRepository) Get(meta params.Params) ([]domain.Media, int, error) {
	ret := _m.Called(meta)

	var r0 []domain.Media
	if rf, ok := ret.Get(0).(func(params.Params) []domain.Media); ok {
		r0 = rf(meta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Media)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(params.Params) int); ok {
		r1 = rf(meta)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(params.Params) error); ok {
		r2 = rf(meta)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetById provides a mock function with given fields: id
func (_m *MediaRepository) GetById(id int) (domain.Media, error) {
	ret := _m.Called(id)

	var r0 domain.Media
	if rf, ok := ret.Get(0).(func(int) domain.Media); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.Media)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: name
func (_m *MediaRepository) GetByName(name string) (domain.Media, error) {
	ret := _m.Called(name)

	var r0 domain.Media
	if rf, ok := ret.Get(0).(func(string) domain.Media); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(domain.Media)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByUrl provides a mock function with given fields: url
func (_m *MediaRepository) GetByUrl(url string) (string, string, error) {
	ret := _m.Called(url)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(url)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string) string); ok {
		r1 = rf(url)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(url)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Serve provides a mock function with given fields: uploadPath, acceptWeb
func (_m *MediaRepository) Serve(uploadPath string, acceptWeb bool) ([]byte, string, error) {
	ret := _m.Called(uploadPath, acceptWeb)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, bool) []byte); ok {
		r0 = rf(uploadPath, acceptWeb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, bool) string); ok {
		r1 = rf(uploadPath, acceptWeb)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, bool) error); ok {
		r2 = rf(uploadPath, acceptWeb)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Total provides a mock function with given fields:
func (_m *MediaRepository) Total() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: m
func (_m *MediaRepository) Update(m *domain.Media) error {
	ret := _m.Called(m)

	var r0 error
	if rf, ok := ret.Get(0).(func(*domain.Media) error); ok {
		r0 = rf(m)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upload provides a mock function with given fields: file, token
func (_m *MediaRepository) Upload(file *multipart.FileHeader, token string) (domain.Media, error) {
	ret := _m.Called(file, token)

	var r0 domain.Media
	if rf, ok := ret.Get(0).(func(*multipart.FileHeader, string) domain.Media); ok {
		r0 = rf(file, token)
	} else {
		r0 = ret.Get(0).(domain.Media)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*multipart.FileHeader, string) error); ok {
		r1 = rf(file, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validate provides a mock function with given fields: file
func (_m *MediaRepository) Validate(file *multipart.FileHeader) error {
	ret := _m.Called(file)

	var r0 error
	if rf, ok := ret.Get(0).(func(*multipart.FileHeader) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}"
}
{
file:./api/mocks/models/PostsRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	params "github.com/ainsleyclark/verbis/api/helpers/params"
)

// PostsRepository is an autogenerated mock type for the PostsRepository type
type PostsRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: p
func (_m *PostsRepository) Create(p *domain.PostCreate) (domain.PostData, error) {
	ret := _m.Called(p)

	var r0 domain.PostData
	if rf, ok := ret.Get(0).(func(*domain.PostCreate) domain.PostData); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(domain.PostData)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.PostCreate) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: id
func (_m *PostsRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: id
func (_m *PostsRepository) Exists(id int) bool {
	ret := _m.Called(id)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExistsBySlug provides a mock function with given fields: slug
func (_m *PostsRepository) ExistsBySlug(slug string) bool {
	ret := _m.Called(slug)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(slug)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: meta, layout, resource, status
func (_m *PostsRepository) Get(meta params.Params, layout bool, resource string, status string) ([]domain.PostData, int, error) {
	ret := _m.Called(meta, layout, resource, status)

	var r0 []domain.PostData
	if rf, ok := ret.Get(0).(func(params.Params, bool, string, string) []domain.PostData); ok {
		r0 = rf(meta, layout, resource, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PostData)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(params.Params, bool, string, string) int); ok {
		r1 = rf(meta, layout, resource, status)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(params.Params, bool, string, string) error); ok {
		r2 = rf(meta, layout, resource, status)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetById provides a mock function with given fields: id, layout
func (_m *PostsRepository) GetById(id int, layout bool) (domain.PostData, error) {
	ret := _m.Called(id, layout)

	var r0 domain.PostData
	if rf, ok := ret.Get(0).(func(int, bool) domain.PostData); ok {
		r0 = rf(id, layout)
	} else {
		r0 = ret.Get(0).(domain.PostData)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, bool) error); ok {
		r1 = rf(id, layout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBySlug provides a mock function with given fields: slug
func (_m *PostsRepository) GetBySlug(slug string) (domain.PostData, error) {
	ret := _m.Called(slug)

	var r0 domain.PostData
	if rf, ok := ret.Get(0).(func(string) domain.PostData); ok {
		r0 = rf(slug)
	} else {
		r0 = ret.Get(0).(domain.PostData)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Total provides a mock function with given fields:
func (_m *PostsRepository) Total() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: p
func (_m *PostsRepository) Update(p *domain.PostCreate) (domain.PostData, error) {
	ret := _m.Called(p)

	var r0 domain.PostData
	if rf, ok := ret.Get(0).(func(*domain.PostCreate) domain.PostData); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(domain.PostData)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.PostCreate) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/models/OptionsRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// OptionsRepository is an autogenerated mock type for the OptionsRepository type
type OptionsRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: name, value
func (_m *OptionsRepository) Create(name string, value interface{}) error {
	ret := _m.Called(name, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(name, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: name
func (_m *OptionsRepository) Exists(name string) bool {
	ret := _m.Called(name)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields:
func (_m *OptionsRepository) Get() (domain.OptionsDB, error) {
	ret := _m.Called()

	var r0 domain.OptionsDB
	if rf, ok := ret.Get(0).(func() domain.OptionsDB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(domain.OptionsDB)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: name
func (_m *OptionsRepository) GetByName(name string) (interface{}, error) {
	ret := _m.Called(name)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStruct provides a mock function with given fields:
func (_m *OptionsRepository) GetStruct() domain.Options {
	ret := _m.Called()

	var r0 domain.Options
	if rf, ok := ret.Get(0).(func() domain.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.Options)
	}

	return r0
}

// Update provides a mock function with given fields: name, value
func (_m *OptionsRepository) Update(name string, value interface{}) error {
	ret := _m.Called(name, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(name, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCreate provides a mock function with given fields: options
func (_m *OptionsRepository) UpdateCreate(options *domain.OptionsDB) error {
	ret := _m.Called(options)

	var r0 error
	if rf, ok := ret.Get(0).(func(*domain.OptionsDB) error); ok {
		r0 = rf(options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}"
}
{
file:./api/mocks/models/AuthRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// AuthRepository is an autogenerated mock type for the AuthRepository type
type AuthRepository struct {
	mock.Mock
}

// Authenticate provides a mock function with given fields: email, password
func (_m *AuthRepository) Authenticate(email string, password string) (domain.User, error) {
	ret := _m.Called(email, password)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(string, string) domain.User); ok {
		r0 = rf(email, password)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(email, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CleanPasswordResets provides a mock function with given fields:
func (_m *AuthRepository) CleanPasswordResets() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Logout provides a mock function with given fields: token
func (_m *AuthRepository) Logout(token string) (int, error) {
	ret := _m.Called(token)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetPassword provides a mock function with given fields: token, password
func (_m *AuthRepository) ResetPassword(token string, password string) error {
	ret := _m.Called(token, password)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendResetPassword provides a mock function with given fields: email
func (_m *AuthRepository) SendResetPassword(email string) error {
	ret := _m.Called(email)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyEmail provides a mock function with given fields: md5String
func (_m *AuthRepository) VerifyEmail(md5String string) error {
	ret := _m.Called(md5String)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(md5String)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyPasswordToken provides a mock function with given fields: token
func (_m *AuthRepository) VerifyPasswordToken(token string) error {
	ret := _m.Called(token)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}"
}
{
file:./api/mocks/models/FormRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	params "github.com/ainsleyclark/verbis/api/helpers/params"
)

// FormRepository is an autogenerated mock type for the FormRepository type
type FormRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: f
func (_m *FormRepository) Create(f *domain.Form) (domain.Form, error) {
	ret := _m.Called(f)

	var r0 domain.Form
	if rf, ok := ret.Get(0).(func(*domain.Form) domain.Form); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Get(0).(domain.Form)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.Form) error); ok {
		r1 = rf(f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: id
func (_m *FormRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: meta
func (_m *FormRepository) Get(meta params.Params) ([]domain.Form, int, error) {
	ret := _m.Called(meta)

	var r0 []domain.Form
	if rf, ok := ret.Get(0).(func(params.Params) []domain.Form); ok {
		r0 = rf(meta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Form)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(params.Params) int); ok {
		r1 = rf(meta)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(params.Params) error); ok {
		r2 = rf(meta)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetById provides a mock function with given fields: id
func (_m *FormRepository) GetById(id int) (domain.Form, error) {
	ret := _m.Called(id)

	var r0 domain.Form
	if rf, ok := ret.Get(0).(func(int) domain.Form); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.Form)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByUUID provides a mock function with given fields: uuid
func (_m *FormRepository) GetByUUID(uuid string) (domain.Form, error) {
	ret := _m.Called(uuid)

	var r0 domain.Form
	if rf, ok := ret.Get(0).(func(string) domain.Form); ok {
		r0 = rf(uuid)
	} else {
		r0 = ret.Get(0).(domain.Form)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Send provides a mock function with given fields: form, ip, agent
func (_m *FormRepository) Send(form *domain.Form, ip string, agent string) error {
	ret := _m.Called(form, ip, agent)

	var r0 error
	if rf, ok := ret.Get(0).(func(*domain.Form, string, string) error); ok {
		r0 = rf(form, ip, agent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: f
func (_m *FormRepository) Update(f *domain.Form) (domain.Form, error) {
	ret := _m.Called(f)

	var r0 domain.Form
	if rf, ok := ret.Get(0).(func(*domain.Form) domain.Form); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Get(0).(domain.Form)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.Form) error); ok {
		r1 = rf(f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/models/FieldsRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// FieldsRepository is an autogenerated mock type for the FieldsRepository type
type FieldsRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: f
func (_m *FieldsRepository) Create(f domain.PostField) (domain.PostField, error) {
	ret := _m.Called(f)

	var r0 domain.PostField
	if rf, ok := ret.Get(0).(func(domain.PostField) domain.PostField); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Get(0).(domain.PostField)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(domain.PostField) error); ok {
		r1 = rf(f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exists provides a mock function with given fields: postId, _a1, key
func (_m *FieldsRepository) Exists(postId int, _a1 uuid.UUID, key string) bool {
	ret := _m.Called(postId, _a1, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int, uuid.UUID, string) bool); ok {
		r0 = rf(postId, _a1, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetByPost provides a mock function with given fields: postId
func (_m *FieldsRepository) GetByPost(postId int) ([]domain.PostField, error) {
	ret := _m.Called(postId)

	var r0 []domain.PostField
	if rf, ok := ret.Get(0).(func(int) []domain.PostField); ok {
		r0 = rf(postId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PostField)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(postId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLayout provides a mock function with given fields: post
func (_m *FieldsRepository) GetLayout(post domain.PostData) []domain.FieldGroup {
	ret := _m.Called(post)

	var r0 []domain.FieldGroup
	if rf, ok := ret.Get(0).(func(domain.PostData) []domain.FieldGroup); ok {
		r0 = rf(post)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.FieldGroup)
		}
	}

	return r0
}

// Update provides a mock function with given fields: f
func (_m *FieldsRepository) Update(f domain.PostField) (domain.PostField, error) {
	ret := _m.Called(f)

	var r0 domain.PostField
	if rf, ok := ret.Get(0).(func(domain.PostField) domain.PostField); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Get(0).(domain.PostField)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(domain.PostField) error); ok {
		r1 = rf(f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCreate provides a mock function with given fields: postId, f
func (_m *FieldsRepository) UpdateCreate(postId int, f []domain.PostField) error {
	ret := _m.Called(postId, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, []domain.PostField) error); ok {
		r0 = rf(postId, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}"
}
{
file:./api/mocks/models/SeoMetaRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// SeoMetaRepository is an autogenerated mock type for the SeoMetaRepository type
type SeoMetaRepository struct {
	mock.Mock
}

// UpdateCreate provides a mock function with given fields: id, p
func (_m *SeoMetaRepository) UpdateCreate(id int, p domain.PostOptions) error {
	ret := _m.Called(id, p)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, domain.PostOptions) error); ok {
		r0 = rf(id, p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}"
}
{
file:./api/mocks/models/RoleRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// RoleRepository is an autogenerated mock type for the RoleRepository type
type RoleRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: r
func (_m *RoleRepository) Create(r *domain.UserRole) (domain.UserRole, error) {
	ret := _m.Called(r)

	var r0 domain.UserRole
	if rf, ok := ret.Get(0).(func(*domain.UserRole) domain.UserRole); ok {
		r0 = rf(r)
	} else {
		r0 = ret.Get(0).(domain.UserRole)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.UserRole) error); ok {
		r1 = rf(r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: id
func (_m *RoleRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: name
func (_m *RoleRepository) Exists(name string) bool {
	ret := _m.Called(name)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields:
func (_m *RoleRepository) Get() ([]domain.UserRole, error) {
	ret := _m.Called()

	var r0 []domain.UserRole
	if rf, ok := ret.Get(0).(func() []domain.UserRole); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.UserRole)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetById provides a mock function with given fields: id
func (_m *RoleRepository) GetById(id int) (domain.UserRole, error) {
	ret := _m.Called(id)

	var r0 domain.UserRole
	if rf, ok := ret.Get(0).(func(int) domain.UserRole); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.UserRole)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: r
func (_m *RoleRepository) Update(r *domain.UserRole) (domain.UserRole, error) {
	ret := _m.Called(r)

	var r0 domain.UserRole
	if rf, ok := ret.Get(0).(func(*domain.UserRole) domain.UserRole); ok {
		r0 = rf(r)
	} else {
		r0 = ret.Get(0).(domain.UserRole)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.UserRole) error); ok {
		r1 = rf(r)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/models/UserRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	params "github.com/ainsleyclark/verbis/api/helpers/params"
)

// UserRepository is an autogenerated mock type for the UserRepository type
type UserRepository struct {
	mock.Mock
}

// CheckSession provides a mock function with given fields: token
func (_m *UserRepository) CheckSession(token string) error {
	ret := _m.Called(token)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckToken provides a mock function with given fields: token
func (_m *UserRepository) CheckToken(token string) (domain.User, error) {
	ret := _m.Called(token)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(string) domain.User); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: u
func (_m *UserRepository) Create(u *domain.UserCreate) (domain.User, error) {
	ret := _m.Called(u)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(*domain.UserCreate) domain.User); ok {
		r0 = rf(u)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.UserCreate) error); ok {
		r1 = rf(u)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: id
func (_m *UserRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: id
func (_m *UserRepository) Exists(id int) bool {
	ret := _m.Called(id)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExistsByEmail provides a mock function with given fields: email
func (_m *UserRepository) ExistsByEmail(email string) bool {
	ret := _m.Called(email)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(email)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: meta
func (_m *UserRepository) Get(meta params.Params) (domain.Users, int, error) {
	ret := _m.Called(meta)

	var r0 domain.Users
	if rf, ok := ret.Get(0).(func(params.Params) domain.Users); ok {
		r0 = rf(meta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(domain.Users)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(params.Params) int); ok {
		r1 = rf(meta)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(params.Params) error); ok {
		r2 = rf(meta)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetByEmail provides a mock function with given fields: email
func (_m *UserRepository) GetByEmail(email string) (domain.User, error) {
	ret := _m.Called(email)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(string) domain.User); ok {
		r0 = rf(email)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetById provides a mock function with given fields: id
func (_m *UserRepository) GetById(id int) (domain.User, error) {
	ret := _m.Called(id)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(int) domain.User); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByToken provides a mock function with given fields: token
func (_m *UserRepository) GetByToken(token string) (domain.User, error) {
	ret := _m.Called(token)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(string) domain.User); ok {
		r0 = rf(token)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOwner provides a mock function with given fields:
func (_m *UserRepository) GetOwner() (domain.User, error) {
	ret := _m.Called()

	var r0 domain.User
	if rf, ok := ret.Get(0).(func() domain.User); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoles provides a mock function with given fields:
func (_m *UserRepository) GetRoles() ([]domain.UserRole, error) {
	ret := _m.Called()

	var r0 []domain.UserRole
	if rf, ok := ret.Get(0).(func() []domain.UserRole); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.UserRole)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetPassword provides a mock function with given fields: id, reset
func (_m *UserRepository) ResetPassword(id int, reset domain.UserPasswordReset) error {
	ret := _m.Called(id, reset)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, domain.UserPasswordReset) error); ok {
		r0 = rf(id, reset)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Total provides a mock function with given fields:
func (_m *UserRepository) Total() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: u
func (_m *UserRepository) Update(u *domain.User) (domain.User, error) {
	ret := _m.Called(u)

	var r0 domain.User
	if rf, ok := ret.Get(0).(func(*domain.User) domain.User); ok {
		r0 = rf(u)
	} else {
		r0 = ret.Get(0).(domain.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.User) error); ok {
		r1 = rf(u)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/models/SiteRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// SiteRepository is an autogenerated mock type for the SiteRepository type
type SiteRepository struct {
	mock.Mock
}

// GetGlobalConfig provides a mock function with given fields:
func (_m *SiteRepository) GetGlobalConfig() domain.Site {
	ret := _m.Called()

	var r0 domain.Site
	if rf, ok := ret.Get(0).(func() domain.Site); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.Site)
	}

	return r0
}

// GetLayouts provides a mock function with given fields:
func (_m *SiteRepository) GetLayouts() (domain.Layouts, error) {
	ret := _m.Called()

	var r0 domain.Layouts
	if rf, ok := ret.Get(0).(func() domain.Layouts); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.Layouts)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTemplates provides a mock function with given fields:
func (_m *SiteRepository) GetTemplates() (domain.Templates, error) {
	ret := _m.Called()

	var r0 domain.Templates
	if rf, ok := ret.Get(0).(func() domain.Templates); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.Templates)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThemeConfig provides a mock function with given fields:
func (_m *SiteRepository) GetThemeConfig() domain.ThemeConfig {
	ret := _m.Called()

	var r0 domain.ThemeConfig
	if rf, ok := ret.Get(0).(func() domain.ThemeConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(domain.ThemeConfig)
	}

	return r0
}"
}
{
file:./api/mocks/models/CategoryRepository.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"

	params "github.com/ainsleyclark/verbis/api/helpers/params"
)

// CategoryRepository is an autogenerated mock type for the CategoryRepository type
type CategoryRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: c
func (_m *CategoryRepository) Create(c *domain.Category) (domain.Category, error) {
	ret := _m.Called(c)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(*domain.Category) domain.Category); ok {
		r0 = rf(c)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.Category) error); ok {
		r1 = rf(c)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: id
func (_m *CategoryRepository) Delete(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePostCategories provides a mock function with given fields: id
func (_m *CategoryRepository) DeletePostCategories(id int) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: id
func (_m *CategoryRepository) Exists(id int) bool {
	ret := _m.Called(id)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExistsByName provides a mock function with given fields: name
func (_m *CategoryRepository) ExistsByName(name string) bool {
	ret := _m.Called(name)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExistsBySlug provides a mock function with given fields: slug
func (_m *CategoryRepository) ExistsBySlug(slug string) bool {
	ret := _m.Called(slug)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(slug)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: meta
func (_m *CategoryRepository) Get(meta params.Params) ([]domain.Category, int, error) {
	ret := _m.Called(meta)

	var r0 []domain.Category
	if rf, ok := ret.Get(0).(func(params.Params) []domain.Category); ok {
		r0 = rf(meta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Category)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(params.Params) int); ok {
		r1 = rf(meta)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(params.Params) error); ok {
		r2 = rf(meta)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetById provides a mock function with given fields: id
func (_m *CategoryRepository) GetById(id int) (domain.Category, error) {
	ret := _m.Called(id)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(int) domain.Category); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: name
func (_m *CategoryRepository) GetByName(name string) (domain.Category, error) {
	ret := _m.Called(name)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(string) domain.Category); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByPost provides a mock function with given fields: pageId
func (_m *CategoryRepository) GetByPost(pageId int) (*domain.Category, error) {
	ret := _m.Called(pageId)

	var r0 *domain.Category
	if rf, ok := ret.Get(0).(func(int) *domain.Category); ok {
		r0 = rf(pageId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Category)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(pageId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBySlug provides a mock function with given fields: slug
func (_m *CategoryRepository) GetBySlug(slug string) (domain.Category, error) {
	ret := _m.Called(slug)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(string) domain.Category); ok {
		r0 = rf(slug)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParent provides a mock function with given fields: id
func (_m *CategoryRepository) GetParent(id int) (domain.Category, error) {
	ret := _m.Called(id)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(int) domain.Category); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertPostCategory provides a mock function with given fields: postId, categoryId
func (_m *CategoryRepository) InsertPostCategory(postId int, categoryId *int) error {
	ret := _m.Called(postId, categoryId)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, *int) error); ok {
		r0 = rf(postId, categoryId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Total provides a mock function with given fields:
func (_m *CategoryRepository) Total() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: c
func (_m *CategoryRepository) Update(c *domain.Category) (domain.Category, error) {
	ret := _m.Called(c)

	var r0 domain.Category
	if rf, ok := ret.Get(0).(func(*domain.Category) domain.Category); ok {
		r0 = rf(c)
	} else {
		r0 = ret.Get(0).(domain.Category)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*domain.Category) error); ok {
		r1 = rf(c)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/http/handler/frontend/SEOHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// SEOHandler is an autogenerated mock type for the SEOHandler type
type SEOHandler struct {
	mock.Mock
}

// Robots provides a mock function with given fields: g
func (_m *SEOHandler) Robots(g *gin.Context) {
	_m.Called(g)
}

// SiteMapIndex provides a mock function with given fields: g
func (_m *SEOHandler) SiteMapIndex(g *gin.Context) {
	_m.Called(g)
}

// SiteMapResource provides a mock function with given fields: g
func (_m *SEOHandler) SiteMapResource(g *gin.Context) {
	_m.Called(g)
}

// SiteMapXSL provides a mock function with given fields: g, index
func (_m *SEOHandler) SiteMapXSL(g *gin.Context, index bool) {
	_m.Called(g, index)
}"
}
{
file:./api/mocks/http/handler/frontend/PublicHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// PublicHandler is an autogenerated mock type for the PublicHandler type
type PublicHandler struct {
	mock.Mock
}

// GetAssets provides a mock function with given fields: g
func (_m *PublicHandler) GetAssets(g *gin.Context) {
	_m.Called(g)
}

// GetUploads provides a mock function with given fields: g
func (_m *PublicHandler) GetUploads(g *gin.Context) {
	_m.Called(g)
}

// Serve provides a mock function with given fields: g
func (_m *PublicHandler) Serve(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/spa/SPAHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// SPAHandler is an autogenerated mock type for the SPAHandler type
type SPAHandler struct {
	mock.Mock
}

// Serve provides a mock function with given fields: g
func (_m *SPAHandler) Serve(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/CategoryHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// CategoryHandler is an autogenerated mock type for the CategoryHandler type
type CategoryHandler struct {
	mock.Mock
}

// Create provides a mock function with given fields: g
func (_m *CategoryHandler) Create(g *gin.Context) {
	_m.Called(g)
}

// Delete provides a mock function with given fields: g
func (_m *CategoryHandler) Delete(g *gin.Context) {
	_m.Called(g)
}

// Get provides a mock function with given fields: g
func (_m *CategoryHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetById provides a mock function with given fields: g
func (_m *CategoryHandler) GetById(g *gin.Context) {
	_m.Called(g)
}

// Update provides a mock function with given fields: g
func (_m *CategoryHandler) Update(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/MediaHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// MediaHandler is an autogenerated mock type for the MediaHandler type
type MediaHandler struct {
	mock.Mock
}

// Delete provides a mock function with given fields: g
func (_m *MediaHandler) Delete(g *gin.Context) {
	_m.Called(g)
}

// Get provides a mock function with given fields: g
func (_m *MediaHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetById provides a mock function with given fields: g
func (_m *MediaHandler) GetById(g *gin.Context) {
	_m.Called(g)
}

// Update provides a mock function with given fields: g
func (_m *MediaHandler) Update(g *gin.Context) {
	_m.Called(g)
}

// Upload provides a mock function with given fields: g
func (_m *MediaHandler) Upload(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/UserHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// UserHandler is an autogenerated mock type for the UserHandler type
type UserHandler struct {
	mock.Mock
}

// Create provides a mock function with given fields: g
func (_m *UserHandler) Create(g *gin.Context) {
	_m.Called(g)
}

// Delete provides a mock function with given fields: g
func (_m *UserHandler) Delete(g *gin.Context) {
	_m.Called(g)
}

// Get provides a mock function with given fields: g
func (_m *UserHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetById provides a mock function with given fields: g
func (_m *UserHandler) GetById(g *gin.Context) {
	_m.Called(g)
}

// GetRoles provides a mock function with given fields: g
func (_m *UserHandler) GetRoles(g *gin.Context) {
	_m.Called(g)
}

// ResetPassword provides a mock function with given fields: g
func (_m *UserHandler) ResetPassword(g *gin.Context) {
	_m.Called(g)
}

// Update provides a mock function with given fields: g
func (_m *UserHandler) Update(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/CacheHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// CacheHandler is an autogenerated mock type for the CacheHandler type
type CacheHandler struct {
	mock.Mock
}

// Clear provides a mock function with given fields: g
func (_m *CacheHandler) Clear(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/FieldHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// FieldHandler is an autogenerated mock type for the FieldHandler type
type FieldHandler struct {
	mock.Mock
}

// Get provides a mock function with given fields: g
func (_m *FieldHandler) Get(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/OptionsHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// OptionsHandler is an autogenerated mock type for the OptionsHandler type
type OptionsHandler struct {
	mock.Mock
}

// Get provides a mock function with given fields: g
func (_m *OptionsHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetByName provides a mock function with given fields: g
func (_m *OptionsHandler) GetByName(g *gin.Context) {
	_m.Called(g)
}

// UpdateCreate provides a mock function with given fields: g
func (_m *OptionsHandler) UpdateCreate(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/FormHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// FormHandler is an autogenerated mock type for the FormHandler type
type FormHandler struct {
	mock.Mock
}

// Create provides a mock function with given fields: g
func (_m *FormHandler) Create(g *gin.Context) {
	_m.Called(g)
}

// Get provides a mock function with given fields: g
func (_m *FormHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetById provides a mock function with given fields: g
func (_m *FormHandler) GetById(g *gin.Context) {
	_m.Called(g)
}

// Send provides a mock function with given fields: g
func (_m *FormHandler) Send(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/AuthHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// AuthHandler is an autogenerated mock type for the AuthHandler type
type AuthHandler struct {
	mock.Mock
}

// Login provides a mock function with given fields: g
func (_m *AuthHandler) Login(g *gin.Context) {
	_m.Called(g)
}

// Logout provides a mock function with given fields: g
func (_m *AuthHandler) Logout(g *gin.Context) {
	_m.Called(g)
}

// ResetPassword provides a mock function with given fields: g
func (_m *AuthHandler) ResetPassword(g *gin.Context) {
	_m.Called(g)
}

// SendResetPassword provides a mock function with given fields: g
func (_m *AuthHandler) SendResetPassword(g *gin.Context) {
	_m.Called(g)
}

// VerifyEmail provides a mock function with given fields: g
func (_m *AuthHandler) VerifyEmail(g *gin.Context) {
	_m.Called(g)
}

// VerifyPasswordToken provides a mock function with given fields: g
func (_m *AuthHandler) VerifyPasswordToken(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/SiteHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// SiteHandler is an autogenerated mock type for the SiteHandler type
type SiteHandler struct {
	mock.Mock
}

// GetLayouts provides a mock function with given fields: g
func (_m *SiteHandler) GetLayouts(g *gin.Context) {
	_m.Called(g)
}

// GetSite provides a mock function with given fields: g
func (_m *SiteHandler) GetSite(g *gin.Context) {
	_m.Called(g)
}

// GetTemplates provides a mock function with given fields: g
func (_m *SiteHandler) GetTemplates(g *gin.Context) {
	_m.Called(g)
}

// GetTheme provides a mock function with given fields: g
func (_m *SiteHandler) GetTheme(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/handler/api/PostHandler.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// PostHandler is an autogenerated mock type for the PostHandler type
type PostHandler struct {
	mock.Mock
}

// Create provides a mock function with given fields: g
func (_m *PostHandler) Create(g *gin.Context) {
	_m.Called(g)
}

// Delete provides a mock function with given fields: g
func (_m *PostHandler) Delete(g *gin.Context) {
	_m.Called(g)
}

// Get provides a mock function with given fields: g
func (_m *PostHandler) Get(g *gin.Context) {
	_m.Called(g)
}

// GetById provides a mock function with given fields: g
func (_m *PostHandler) GetById(g *gin.Context) {
	_m.Called(g)
}

// Update provides a mock function with given fields: g
func (_m *PostHandler) Update(g *gin.Context) {
	_m.Called(g)
}"
}
{
file:./api/mocks/http/Paginate.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	params "github.com/ainsleyclark/verbis/api/helpers/params"
	mock "github.com/stretchr/testify/mock"
)

// Paginate is an autogenerated mock type for the Paginate type
type Paginate struct {
	mock.Mock
}

// Get provides a mock function with given fields:
func (_m *Paginate) Get() params.Params {
	ret := _m.Called()

	var r0 params.Params
	if rf, ok := ret.Get(0).(func() params.Params); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(params.Params)
	}

	return r0
}"
}
{
file:./api/mocks/fields/resolve/valuer.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	mock "github.com/stretchr/testify/mock"
)

// valuer is an autogenerated mock type for the valuer type
type valuer struct {
	mock.Mock
}

// Execute provides a mock function with given fields: field
func (_m *valuer) Execute(field domain.FieldValue) (interface{}, error) {
	ret := _m.Called(field)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(domain.FieldValue) interface{}); ok {
		r0 = rf(field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(domain.FieldValue) error); ok {
		r1 = rf(field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}"
}
{
file:./api/mocks/fields/converter/Finder.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"

	mock "github.com/stretchr/testify/mock"
)

// Finder is an autogenerated mock type for the Finder type
type Finder struct {
	mock.Mock
}

// GetLayout provides a mock function with given fields: post, cacheable
func (_m *Finder) GetLayout(post domain.PostData, cacheable bool) []domain.FieldGroup {
	ret := _m.Called(post, cacheable)

	var r0 []domain.FieldGroup
	if rf, ok := ret.Get(0).(func(domain.PostData, bool) []domain.FieldGroup); ok {
		r0 = rf(post, cacheable)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.FieldGroup)
		}
	}

	return r0
}"
}
{
file:./api/mocks/fields/WalkerFunc.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"

	mock "github.com/stretchr/testify/mock"
)

// WalkerFunc is an autogenerated mock type for the WalkerFunc type
type WalkerFunc struct {
	mock.Mock
}

// Execute provides a mock function with given fields: field
func (_m *WalkerFunc) Execute(field domain.PostField) {
	_m.Called(field)
}"
}
{
file:./api/mocks/fields/FieldService.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	domain "github.com/ainsleyclark/verbis/api/domain"
	fields "github.com/ainsleyclark/verbis/api/fields"

	mock "github.com/stretchr/testify/mock"
)

// FieldService is an autogenerated mock type for the FieldService type
type FieldService struct {
	mock.Mock
}

// GetField provides a mock function with given fields: name, args
func (_m *FieldService) GetField(name string, args ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(name, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetFieldObject provides a mock function with given fields: name, args
func (_m *FieldService) GetFieldObject(name string, args ...interface{}) domain.PostField {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 domain.PostField
	if rf, ok := ret.Get(0).(func(string, ...interface{}) domain.PostField); ok {
		r0 = rf(name, args...)
	} else {
		r0 = ret.Get(0).(domain.PostField)
	}

	return r0
}

// GetFields provides a mock function with given fields: args
func (_m *FieldService) GetFields(args ...interface{}) fields.Fields {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 fields.Fields
	if rf, ok := ret.Get(0).(func(...interface{}) fields.Fields); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fields.Fields)
		}
	}

	return r0
}

// GetFlexible provides a mock function with given fields: input, args
func (_m *FieldService) GetFlexible(input interface{}, args ...interface{}) fields.Flexible {
	var _ca []interface{}
	_ca = append(_ca, input)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 fields.Flexible
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) fields.Flexible); ok {
		r0 = rf(input, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fields.Flexible)
		}
	}

	return r0
}

// GetLayout provides a mock function with given fields: name, args
func (_m *FieldService) GetLayout(name string, args ...interface{}) domain.Field {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 domain.Field
	if rf, ok := ret.Get(0).(func(string, ...interface{}) domain.Field); ok {
		r0 = rf(name, args...)
	} else {
		r0 = ret.Get(0).(domain.Field)
	}

	return r0
}

// GetLayouts provides a mock function with given fields: args
func (_m *FieldService) GetLayouts(args ...interface{}) []domain.FieldGroup {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 []domain.FieldGroup
	if rf, ok := ret.Get(0).(func(...interface{}) []domain.FieldGroup); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.FieldGroup)
		}
	}

	return r0
}

// GetRepeater provides a mock function with given fields: input, args
func (_m *FieldService) GetRepeater(input interface{}, args ...interface{}) fields.Repeater {
	var _ca []interface{}
	_ca = append(_ca, input)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 fields.Repeater
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) fields.Repeater); ok {
		r0 = rf(input, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fields.Repeater)
		}
	}

	return r0
}"
}
{
file:./api/mocks/helpers/vaidation/Validator.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	validation "github.com/ainsleyclark/verbis/api/helpers/vaidation"
	validator "github.com/go-playground/validator/v10"
	mock "github.com/stretchr/testify/mock"
)

// Validator is an autogenerated mock type for the Validator type
type Validator struct {
	mock.Mock
}

// CmdCheck provides a mock function with given fields: key, data
func (_m *Validator) CmdCheck(key string, data interface{}) error {
	ret := _m.Called(key, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(key, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Process provides a mock function with given fields: errors
func (_m *Validator) Process(errors validator.ValidationErrors) []validation.ValidationError {
	ret := _m.Called(errors)

	var r0 []validation.ValidationError
	if rf, ok := ret.Get(0).(func(validator.ValidationErrors) []validation.ValidationError); ok {
		r0 = rf(errors)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]validation.ValidationError)
		}
	}

	return r0
}

// message provides a mock function with given fields: kind, field, param
func (_m *Validator) message(kind string, field string, param string) string {
	ret := _m.Called(kind, field, param)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string) string); ok {
		r0 = rf(kind, field, param)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}"
}
{
file:./api/mocks/helpers/params/Parameterize.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	params "github.com/ainsleyclark/verbis/api/helpers/params"
	mock "github.com/stretchr/testify/mock"
)

// Parameterize is an autogenerated mock type for the Parameterize type
type Parameterize struct {
	mock.Mock
}

// Get provides a mock function with given fields:
func (_m *Parameterize) Get() params.Params {
	ret := _m.Called()

	var r0 params.Params
	if rf, ok := ret.Get(0).(func() params.Params); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(params.Params)
	}

	return r0
}"
}
{
file:./api/mocks/helpers/params/Stringer.go
contents:
"// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// Stringer is an autogenerated mock type for the Stringer type
type Stringer struct {
	mock.Mock
}

// Param provides a mock function with given fields: _a0
func (_m *Stringer) Param(_a0 string) string {
	ret := _m.Called(_a0)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}"
}
{
file:./api/cmd/config.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"github.com/spf13/cobra"
)

var (
	configCmd = &cobra.Command{
		Use:   "config",
		Short: "Used to cache and clear Verbis's configuration.",
	}
)

func init() {
	//configCmd.AddCommand(configStoreCmd)
	//configCmd.AddCommand(configClearCmd)
}

// cacheClearCmd represents the down command
//var configStoreCmd = &cobra.Command{
//	Use:   "cache",
//	Short: "Cache all of the configuration files.",
//	Long: `Cache will cache all of the configuration files based
//on configuration path ./config. It will cache the yaml files
//defined for faster reading. Recommended in production`,
//	Run: func(cmd *cobra.Command, args []string) {
//		config.Cache()
//		color.Green.Println("Successfully cached the configuration files.")
//	},
//}
//
//// cacheClearCmd represents the down command
//var configClearCmd = &cobra.Command{
//	Use:   "clear",
//	Short: "Clear will delete the configuration cache.",
//	Long: `Cache will delete the cache all of the configuration
//files based on configuration path ./config.`,
//	Run: func(cmd *cobra.Command, args []string) {
//		config.CacheClear()
//		color.Green.Println("Successfully cleared the configuration files cache.")
//	},
//}"
}
{
file:./api/cmd/import.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/importer/wordpress"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/kyokomi/emoji"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

var (
	importCmd = &cobra.Command{
		Use:   "import",
		Short: "Import XML files from Wordpress and migrate content to your Verbis installation",
		Long: `This command will accept an XML file from a Wordpress installation
and convert the data into Verbis content. `,
		Run: func(cmd *cobra.Command, args []string) {

			// Run doctor
			db, err := doctor()
			if err != nil {
				printError(err.Error())
			}

			fmt.Println()

			// Init Config
			cfg, err := config.New()
			if err != nil {
				printError(errors.Message(err))
			}

			// Set up stores & pass the database.
			store := models.New(db, *cfg)
			if err != nil {
				printError(err.Error())
			}

			file := getXMLFile()

			wp, err := wordpress.New(file, store, true)
			if err != nil {
				printError(err.Error())
			}

			//"/Users/ainsley/Desktop/Reddico/websites/reddico-website/theme/res/import-xml/test.xml"

			wp.Import()
		},
	}
)

func getXMLFile() string {

	emoji.Println(":backhand_index_pointing_right: Enter the absolute path of the XML file to be imported")
	fmt.Println()

	promptXML := promptui.Prompt{
		Label: "XML File",
		Validate: func(input string) error {
			if input == "" {
				return fmt.Errorf("Enter a the XML file path")
			}
			return nil
		},
	}

	xmlFile, err := promptXML.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	return xmlFile
}"
}
{
file:./api/cmd/start.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/cron"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/http/handler"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/server"
	"github.com/ainsleyclark/verbis/api/server/routes"
	"github.com/ainsleyclark/verbis/api/tpl/tplimpl"
	"github.com/kyokomi/emoji"
	"github.com/spf13/cobra"
)

var (
	startCmd = &cobra.Command{
		Use:   "start",
		Short: "Running start will start Verbis project from the current directory and run the CMS project.",
		Long: `This command will start Verbis from the current directory. First it will
run Verbis doctor to see if the environment is configured correctly. It will then start
up the server on the port specified in the .env file.`,
		Run: func(cmd *cobra.Command, args []string) {

			// Run doctor
			db, err := doctor()
			if err != nil {
				printError(err.Error())
			}

			// Init Config
			cfg, err := config.New()
			if err != nil {
				printError(errors.Message(err))
			}

			// Set up stores & pass the database.
			store := models.New(db, *cfg)
			if err != nil {
				printError(err.Error())
			}

			// Load cron jobs
			scheduler := cron.New(store)
			go scheduler.Run()

			// Set up the router & pass logger
			serve := server.New(store.Options)

			d := deps.New(deps.DepsConfig{
				Store:   store,
				Config:  cfg,
				Running: true,
			})

			d.SetTmpl(tplimpl.New(d))

			// Pass the stores to the controllers
			handler := handler.New(d)

			// Load the routes
			routes.Load(d, serve, handler)

			// Print listening success
			printSuccess(fmt.Sprintf("Verbis listening on port: %d \n", environment.GetPort()))
			emoji.Printf(":backhand_index_pointing_right: Visit your site at:          %s \n", d.Options.SiteUrl)
			emoji.Printf(":key: Or visit the admin area at:  %s \n", d.Options.SiteUrl+"/admin")
			fmt.Println()

			// Listen & serve.
			err = serve.ListenAndServe(environment.GetPort())
			if err != nil {
				printError(err.Error())
			}
		},
	}
)"
}
{
file:./api/cmd/test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"github.com/spf13/cobra"
)

var (
	testCmd = &cobra.Command{
		Use:   "test",
		Short: "Test Command",
		Run: func(cmd *cobra.Command, args []string) {

		},
	}
)"
}
{
file:./api/cmd/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"fmt"
	"github.com/briandowns/spinner"
	"github.com/gookit/color"
	"os"
	"regexp"
	"time"
)

// Print error to terminal
func printError(msg string) {
	fmt.Println()
	errMsg := color.New(color.LightWhite, color.BgRed, color.OpBold)
	errMsg.Print(" ERROR ")
	fmt.Print(" ")
	color.Red.Print(msg)
	fmt.Println()
	os.Exit(1)
}

// Print error to terminal with no exit
func printErrorNoExit(msg string) {
	fmt.Println()
	errMsg := color.New(color.LightWhite, color.BgRed, color.OpBold)
	errMsg.Print(" ERROR ")
	fmt.Print(" ")
	color.Red.Print(msg)
	fmt.Println()
}

// Print success to terminal
func printSuccess(msg string) {
	fmt.Println()
	successMsg := color.New(color.LightWhite, color.BgGreen)
	successMsg.Print(" SUCCESS ")
	fmt.Print(" ")
	color.Green.Print(msg)
	fmt.Println()
}

// Print spinner
func printSpinner(msg string) {
	fmt.Println()
	s := spinner.New(spinner.CharSets[14], 50*time.Millisecond)
	s.Suffix = " " + msg
	s.Start()
	fmt.Printf("\n")
	s.Stop()
}

// isEmailValid checks if the email provided passes the required structure and length.
func isEmailValid(e string) bool {
	var emailRegex = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
	if len(e) < 3 && len(e) > 254 {
		return false
	}
	return emailRegex.MatchString(e)
}"
}
{
file:./api/cmd/uninstall.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"bufio"
	"fmt"
	"github.com/spf13/cobra"
	"os"
	"strings"
)

var (
	uninstallCmd = &cobra.Command{
		Use:   "uninstall",
		Short: "Use with caution! This will drop the Verbis database entirely, it should only be used in development.",
		Long: `This command will drop the database that is provided in the environment file.
It will first run Verbis doctor to ensure the database connection is passable and then 
continue to drop the database. Use with caution!`,
		Run: func(cmd *cobra.Command, args []string) {

			// Message
			fmt.Println()
			fmt.Println("This will drop the entire Verbis database, are you sure you want to continue?")
			fmt.Println("Are you sure you want to continue? (yes/no)")
			fmt.Println()

			// Check for user input
			reader := bufio.NewReader(os.Stdin)
			for {

				fmt.Print("-> ")
				text, _ := reader.ReadString('\n')
				text = strings.Replace(text, "\n", "", -1)

				if strings.Contains(text, "yes") {
					break
				} else if strings.Contains(text, "no") {
					fmt.Println()
					fmt.Println("Bye!")
					os.Exit(0)
				} else {
					printErrorNoExit("Please enter yes or no")
					fmt.Println()
				}
			}

			// Start the spinner
			printSpinner("Uninstalling Verbis...")

			// Run doctor
			db, err := doctor()
			if err != nil {
				printError(err.Error())
			}

			// Drop the database
			if err := db.Drop(); err != nil {
				printError(err.Error())
			}

			// Print success
			printSuccess("Successfully uninstalled verbis")

			return
		},
	}
)

func init() {

}"
}
{
file:./api/cmd/dump.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/spf13/cobra"
	"time"
)

var (
	dumpCmd = &cobra.Command{
		Use:   "dump",
		Short: "Dumps the Verbis database to the storage dumps directory using the database name provided in the .env file.",
		Long: `This command will dump the database to the dumps directory,
located in ./storage/dumps. First the export command runs Verbis doctor to
check if the database exists connection is passable. Then dump the
database to file`,
		Run: func(cmd *cobra.Command, args []string) {
			printSpinner("Dumping database...")

			db, err := doctor()
			if err != nil {
				printError("Could not dump the database, is your database connection valid?")
			}

			time := time.Now().Format(time.RFC3339)
			fileName := fmt.Sprintf("%s-dump-%v", environment.GetDatabaseName(), time)
			if err := db.Dump(paths.Storage()+"/dumps", fileName); err != nil {
				printError("Could not dump the database, is your database connection valid?")
			}

			printSuccess(fmt.Sprintf("Successfully exported database to filename: %s", fileName))

			return
		},
	}
)"
}
{
file:./api/cmd/doctor.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/database"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/logger"
	"github.com/spf13/cobra"
	"strings"
)

var (
	doctorCmd = &cobra.Command{
		Use:   "doctor",
		Short: "Running doctor will check the system for any potential hiccups when installing, updating or running Verbis.",
		Long: `This command is a diagnostic tool to find any potential issues for your
Verbis install. It will check if the database has been set up correctly as well as the
environment.`,
		Run: func(cmd *cobra.Command, args []string) {
			if _, err := doctor(); err != nil {
				return
			}

			return
		},
	}
)

// doctor checks if the environment is validated and checks
// to see if there is a valid database connection and the
// database exists before proceeding.
func doctor() (*database.MySql, error) {

	printSpinner("Running doctor...")

	// Check paths are correct
	if err := paths.BaseCheck(); err != nil {
		printError(err.Error())
		return nil, err
	}

	// Load the environment (.env file)
	err := environment.Load()
	if err != nil {
		printError(err.Error())
		return nil, err
	}

	// Check if the environment values are valid
	vErrors := environment.Validate()
	if vErrors != nil {
		for _, v := range vErrors {
			printError(fmt.Sprintf("Obtaining environment variable: %s", strings.ToUpper(v.Key)))
		}
		return nil, fmt.Errorf("Validation failed for the enviroment")
	}

	// Get the database and ping
	db, err := database.New()
	if err != nil {
		printError(fmt.Sprintf("Establishing database connection, are the credentials in the .env file correct? %s", err.Error()))
		return nil, fmt.Errorf("Error establishing database connection")
	}

	// Check if the database exists
	if err := db.CheckExists(); err != nil {
		printError(fmt.Sprintf("Establishing database connection, are the credentials in the .env file correct? %s", err.Error()))
		return nil, fmt.Errorf("error establishing database connection")
	}

	// Init Cache
	cache.Init()

	// Init Config
	con, err := config.New()
	if err != nil {
		printError(errors.Message(err))
	}

	// Init logging
	if err := logger.Init(*con); err != nil {
		printError(err.Error())
	}

	printSuccess("All checks passed.")

	return db, nil
}"
}
{
file:./api/cmd/root.go
contents:
"/*
Copyright  2020 Verbis ainsley@reddico.co.uk

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/spf13/cobra"
	"strconv"
)

// Root represents the base command when called without any subcommands
var (
	rootCmd = &cobra.Command{
		Use:               "Verbis",
		Short:             "Verbis CLI",
		Long:              `Verbis - CHANGE.`,
		DisableAutoGenTag: true,
	}
)

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the Root.
func Execute() {

	// Pass the super admin to bool (ldflags)
	admin, _ := strconv.ParseBool(api.SuperAdminString)
	api.SuperAdmin = admin

	// Execute the main command
	if err := rootCmd.Execute(); err != nil {
		printError(fmt.Sprintf("Could not start Verbis: %s", err.Error()))
	}
}

// Add child commands and bootstrap
func init() {
	rootCmd.AddCommand(startCmd)
	rootCmd.AddCommand(configCmd)
	rootCmd.AddCommand(doctorCmd)
	rootCmd.AddCommand(installCmd)
	rootCmd.AddCommand(uninstallCmd)
	rootCmd.AddCommand(dumpCmd)
	rootCmd.AddCommand(testCmd)
	rootCmd.AddCommand(importCmd)
}"
}
{
file:./api/cmd/install.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/database/seeds"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	validation "github.com/ainsleyclark/verbis/api/helpers/vaidation"
	"github.com/ainsleyclark/verbis/api/helpers/webp"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/kyokomi/emoji"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
	"net/url"
)

// Add child commands
func init() {
	v = validation.New()
}

var (
	v          validation.Validator
	installCmd = &cobra.Command{
		Use:   "install",
		Short: "Install will run the doctor command and then run database schema and insert any data dependant on Verbis.",
		Long: `This command will install first run Verbis doctor to see if the database,
exists and is passable. Install will then run the migration to insert into the schema.
Seeds are also run, inserting options and any necessary configuration into the 
database.`,
		Run: Install,
	}
)

// Add child commands/init
func init() {
	v = validation.New()
}

func Install(cmd *cobra.Command, args []string) {

	//figure := figure.NewColorFigure("Verbis", "cybermedium", "reset", true)
	//	figure.Print()

	// Run doctor
	db, err := doctor()
	if err != nil {
		printError(err.Error())
	}

	// Check if the database exists.
	// TODO NOT WORKING
	err = db.CheckExists()
	if err != nil {
		printError(fmt.Sprintf("A database with the name %s has already been installed. \nPlease run verbis uninstall if you want to delete it.", environment.GetDatabaseName()))
	}

	// Get the user & site variables
	user := createOwner()
	fmt.Println()
	url := setUrl()

	// Start the spinner
	printSpinner("Installing Verbis...")

	// Install the database
	if err := db.Install(); err != nil {
		printError(fmt.Sprintf("Error installing the Verbis database: %v", err))
	}

	// Init Config
	con, err := config.New()
	if err != nil {
		printError(errors.Message(err))
	}

	// Set up stores & pass the database.
	store := models.New(db, *con)
	if err != nil {
		printError(err.Error())
	}

	// Run the seeds
	seeder := seeds.New(db.Sqlx, store)
	if err := seeder.Seed(); err != nil {
		printError(err.Error())
	}

	// Create the owner user
	if _, err := store.User.Create(user); err != nil {
		printError(fmt.Sprintf("Error creating the owner: %s", err.Error()))
	}

	// Insert the site url
	fmt.Println()
	mUrl, _ := json.Marshal(url)
	if err := store.Options.Update("site_url", mUrl); err != nil {
		printError(fmt.Sprintf("Error not inserting the site url: %s", err.Error()))
	}

	// Get webp executables
	bin := webp.CreateBinWrapper()
	bin.ExecPath("cwebp")
	if err := bin.Run(); err != nil {
		// TODO: Log here, dont print error. doesnt work on GCP
	}

	// Print success
	printSuccess("Successfully installed verbis")

	return
}

// setUrl
func setUrl() string {

	emoji.Println(":backhand_index_pointing_right: Enter the url will sit on:")
	fmt.Println("If in development, be sure to append a port (for example: http://127.0.0.1:8080):")

	prompt := promptui.Prompt{
		Label: "Url",
		Validate: func(input string) error {
			if input == "" {
				return fmt.Errorf("Enter URL")
			}
			_, err := url.ParseRequestURI("http://google.com/")
			if err != nil {
				return fmt.Errorf("Enter a valid URL")
			}
			return nil
		},
	}
	homeUrl, err := prompt.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	return homeUrl
}

// createOwner Create's the owner of the site for the install.
func createOwner() *domain.UserCreate {

	emoji.Print(":backhand_index_pointing_right: Enter the owner's details:")

	promptFirstName := promptui.Prompt{
		Label: "First name",
		Validate: func(input string) error {
			if input == "" {
				return fmt.Errorf("Enter a first name")
			}
			return nil
		},
	}
	firstName, err := promptFirstName.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	promptLastName := promptui.Prompt{
		Label: "Last name",
		Validate: func(input string) error {
			if input == "" {
				return fmt.Errorf("Enter a last name")
			}
			return nil
		},
	}
	lastName, err := promptLastName.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	promptEmail := promptui.Prompt{
		Label: "Email",
		Validate: func(input string) error {
			if input == "" {
				return fmt.Errorf("Enter a email address")
			}
			if !isEmailValid(input) {
				return fmt.Errorf("Enter a valid email address")
			}
			return nil
		},
	}
	email, err := promptEmail.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	promptPassword := promptui.Prompt{
		Label: "Password",
		Validate: func(input string) error {
			if len(input) < 8 {
				return fmt.Errorf("Password must have more than 8 characters")
			}
			return nil
		},
		Mask: '*',
	}
	password, err := promptPassword.Run()
	if err != nil {
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	prompConfirmPassword := promptui.Prompt{
		Label: "Password",
		Validate: func(input string) error {
			if input != password {
				return fmt.Errorf("Password and confirm password must match.")
			}
			return nil
		},
		Mask: '*',
	}
	confirmPassword, err := prompConfirmPassword.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		printError(fmt.Sprintf("Install failed: %v\n", err))
	}

	user := domain.UserCreate{
		User: domain.User{
			UserPart: domain.UserPart{
				FirstName: firstName,
				LastName:  lastName,
				Email:     email,
				Role: domain.UserRole{
					Id: 6,
				},
			},
		},
		Password:        password,
		ConfirmPassword: confirmPassword,
	}

	return &user
}"
}
{
file:./api/database/seeds/roles.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package seeds

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

// runRoles will insert all default values for the user roles
// including the Id.
func (s *Seeder) runRoles() error {
	r := []domain.UserRole{
		{
			Id:          1,
			Name:        "Banned",
			Description: "The user has been banned from the system.",
		},
		{
			Id:          2,
			Name:        "Contributor",
			Description: "The user can create and edit their own draft posts, but they are unable to edit drafts of users or published posts.",
		},
		{
			Id:          3,
			Name:        "Author",
			Description: "The user can write, edit and publish their own posts.",
		},
		{
			Id:          4,
			Name:        "Editor",
			Description: "The user can do everything defined in the Author role but they can also edit and publish posts of others, as well as their own.",
		},
		{
			Id:          5,
			Name:        "Administrator",
			Description: "The user can do everything defined in the Editor role but they can also edit site settings and data. Additionally they can manage users",
		},
		{
			Id:          6,
			Name:        "Owner",
			Description: "The user is a special user with all of the permissions as an Administrator however they cannot be deleted",
		},
	}

	for _, v := range r {
		if exists := s.models.Roles.Exists(v.Name); !exists {
			if _, err := s.models.Roles.Create(&v); err != nil {
				return err
			}
		}
	}

	return nil
}"
}
{
file:./api/database/seeds/options.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package seeds

import (
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/domain"
)

// runOptions will insert all default values for the options
// into the database when installing Verbis.
func (s *Seeder) runOptions() error {
	const op = "Seeder.runOptions"

	optionsSeed := domain.OptionsDB{
		// Site
		"site_title":       api.App.Title,
		"site_description": api.App.Description,
		"site_logo":        api.App.Logo,
		"site_url":         api.App.Url,
		// General
		"general_locale": "en_GB",
		// Contact
		"contact_email":     "",
		"contact_telephone": "",
		"contact_address":   "",
		// Social
		"social_facebook":   "",
		"social_twitter":    "",
		"social_instagram":  "",
		"social_linkedin":   "",
		"social_youtube":    "",
		"social_pinterest":  "",
		"footer_text":       "",
		"footer_disclosure": "",
		// Code Injection
		"codeinjection_head": "",
		"codeinjection_foot": "",
		// Meta
		"meta_title":                "",
		"meta_description":          "",
		"meta_facebook_title":       "",
		"meta_facebook_description": "",
		"meta_facebook_image_id":    0,
		"meta_twitter_title":        "",
		"meta_twitter_description":  "",
		"meta_twitter_image_id":     0,
		// SEO
		"seo_public":            false,
		"seo_sitemap_serve":     true,
		"seo_sitemap_redirects": true,
		"seo_sitemap_excluded":  []string{},
		"seo_enforce_slash":     false,
		"seo_robots_serve":      true,
		"seo_robots":            "User-agent: *\nAllow: /",
		"seo_redirects":         nil,
		// Media
		"media_compression":         80,
		"media_convert_webp":        true,
		"media_serve_webp":          true,
		"media_upload_max_size":     100000,
		"media_upload_max_width":    0,
		"media_upload_max_height":   0,
		"media_organise_year_month": true,
		"media_images_sizes": map[string]domain.MediaSizeOptions{
			"thumbnail": {
				Name:   "Thumbnail Size",
				Width:  550,
				Height: 300,
				Crop:   true,
			},
			"medium": {
				Name:   "Medium Size",
				Width:  992,
				Height: 0,
				Crop:   false,
			},
			"large": {
				Name:   "Large Size",
				Width:  1280,
				Height: 0,
				Crop:   false,
			},
			"hd": {
				Name:   "HD Size",
				Width:  1920,
				Height: 0,
				Crop:   false,
			},
		},
		// Cache
		"cache_global":    true,
		"cache_layout":    true,
		"cache_fields":    true,
		"cache_site":      true,
		"cache_templates": true,
		"cache_resources": true,
		// Frontend Caching
		"cache_frontend":            true,
		"cache_frontend_request":    "max-age",
		"cache_frontend_seconds":    31536000,
		"cache_frontend_extensions": []string{"jpg", "jpeg", "gif", "png", "ico", "cur", "webp", "jxr", "svg", "css", "js", "htc", "ttf", "tt", "otf", "eot", "woff", "woff2", "webm"},
		// Gzip
		"gzip":                     true,
		"gzip_compression":         "default-compression",
		"gzip_use_paths":           false,
		"gzip_excluded_extensions": []string{},
		"gzip_excluded_paths":      []string{},
		// Minify
		"minify_html": false,
		"minify_js":   false,
		"minify_css":  false,
		"minify_svg":  false,
		"minify_json": false,
		"minify_xml":  false,
	}

	err := s.models.Options.UpdateCreate(&optionsSeed)
	if err != nil {
		return err
	}

	return nil
}"
}
{
file:./api/database/seeds/posts.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package seeds

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

// runPosts will insert all demo psots for the user.
func (s *Seeder) runPosts() error {

	p := domain.PostCreate{
		Post: domain.Post{
			Slug:         "/",
			Title:        "Welcome to Verbis",
			Status:       "published",
			PageTemplate: "",
			PageLayout:   "",
			UserId:       0,
		},
		Author:   0,
		Category: nil,
	}

	_, err := s.models.Posts.Create(&p)
	if err != nil {
		return err
	}

	return nil
}"
}
{
file:./api/database/seeds/seeder.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package seeds

import (
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/jmoiron/sqlx"
)

type Seeder struct {
	db     *sqlx.DB
	models *models.Store
}

// Construct
func New(db *sqlx.DB, s *models.Store) *Seeder {
	return &Seeder{
		db:     db,
		models: s,
	}
}

// Seed
func (s *Seeder) Seed() error {
	// IMPORTANT: Run roles before inserting the user.
	if err := s.runRoles(); err != nil {
		return err
	}
	if err := s.runOptions(); err != nil {
		return err
	}
	//if err := s.runPosts(); err != nil {
	//	return err
	//}
	return nil
}"
}
{
file:./api/database/sql.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package database

import (
	"fmt"
	"github.com/JamesStewy/go-mysqldump"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
)

// MySql defines the driver for the database
type MySql struct {
	Sqlx *sqlx.DB
}

// New - Creates a new MySql instance.
func New() (*MySql, error) {
	db := MySql{}

	sql, err := db.GetDatabase()
	if err != nil {
		return nil, err
	}
	db.Sqlx = sql

	if err := db.Ping(); err != nil {
		return nil, err
	}

	return &db, nil
}

// Get Database open's sql database connection
// Returns errors.INVALID if the the connection string or database is invalid.
func (db *MySql) GetDatabase() (*sqlx.DB, error) {
	const op = "Database.GetDatabase"
	var driver *sqlx.DB
	driver, err := sqlx.Connect("mysql", environment.ConnectString())
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Could not establish a database connection", Operation: op, Err: err}
	}
	driver.SetMaxIdleConns(5)
	driver.SetMaxOpenConns(100)
	return driver, nil
}

// CheckExists check's if database exists with a given name
// Returns errors.INVALID if the database was not found.
func (db *MySql) CheckExists() error {
	const op = "Database.CheckExists"
	_, err := db.Sqlx.Exec("SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = ?", environment.GetDatabaseName())
	if err != nil {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("No database found with the name: %s", environment.GetDatabaseName()), Operation: op, Err: err}
	}
	return nil
}

// Ping database to check connection
// Returns errors.INVALID if the ping was unsuccessful.
func (db *MySql) Ping() error {
	const op = "Database.Ping"
	if err := db.Sqlx.Ping(); err != nil {
		return &errors.Error{Code: errors.INVALID, Message: "Pinging the database was unsuccessful", Operation: op, Err: err}
	}
	return nil
}

// Install Verbis by executing the migration file
// Returns errors.INVALID if the sql file could not be located.
// Returns errors.INTERNAL if the exec command could not be ran.
func (db *MySql) Install() error {
	const op = "Database.Install"
	path := paths.Migration() + "/schema.sql"
	sql, err := files.GetFileContents(path)
	if err != nil {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("Unable to load the sql migration file from the path: %s", path), Operation: op, Err: err}
	}
	if _, err := db.Sqlx.Exec(sql); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could execute the migration file", Operation: op, Err: err}
	}
	return nil
}

// Drop deletes the database with the environments database name.
// Returns errors.INTERNAL if the exec command could not be ran.
func (db *MySql) Drop() error {
	const op = "Database.Drop"
	_, err := db.Sqlx.Exec("DROP DATABASE " + environment.GetDatabaseName() + ";")
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not drop the database with the name: %s", environment.GetDatabaseName()), Operation: op, Err: err}
	}
	return nil
}

// Create the database with the environments database name.
// Returns errors.INTERNAL if the exec command could not be ran.
func (db *MySql) Create() error {
	const op = "Database.Create"
	_, err := db.Sqlx.Exec("CREATE DATABASE " + environment.GetDatabaseName() + ";")
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the database with the name: %s", environment.GetDatabaseName()), Operation: op, Err: err}
	}
	return nil
}

// Dump the database to file with the given path and file name.
// Returns errors.INTERNAL if the connection, dump failed as well as closing
// the database.
func (db *MySql) Dump(path string, filename string) error {
	const op = "Database.Dump"
	dumper, err := mysqldump.Register(db.Sqlx.DB, path, filename)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Unable to register with mysqldump", Operation: op, Err: err}
	}

	_, err = dumper.Dump()
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not dump the database with the path and filename: %s", path+filename), Operation: op, Err: err}
	}

	if err := dumper.Close(); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not close the database connection", Operation: op, Err: err}
	}

	return nil
}"
}
{
file:./api/importer/importer.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package importer

import (
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/google/uuid"
	"net/url"
)

// Importer defines the method to migrate various CMS's content to Verbis.
type Importer interface {
	Import()
}

// ParseLink converts a link to of type *URL
// Returns errors.INVALID if the post link was unable to be parsed.
func ParseLink(link string) (string, error) {
	const op = "Importer.ParseLink"
	u, err := url.Parse(link)
	if err != nil {
		return "", &errors.Error{Code: errors.INVALID, Message: "Unable to parse post link", Operation: op, Err: err}
	}
	return u.Path, nil
}

// ParseUUID converts a string to of type uuid.UUID
// Returns errors.INVALID if the string was unable to be parsed.
func ParseUUID(u string) (uuid.UUID, error) {
	const op = "Importer.ParseUUID"
	id, err := uuid.Parse(u)
	if err != nil {
		return uuid.UUID{}, &errors.Error{Code: errors.INVALID, Message: "Could not pass UUID", Operation: op, Err: err}
	}
	return id, nil
}"
}
{
file:./api/importer/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package importer

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"io"
	"mime/multipart"
	"net/http"
	"path"
)

// DownloadFile
//
// Retrieves a file from a specific URL and copies it to a
// multipart.FileHeader ready to be uploaded by the
// media repository.
//
// Returns errors.NOTFOUND if the status code is anything but 200.
// Returns errors.INTERNAL if the file could not be created, copied, closed or read.
func DownloadFile(url string) (*multipart.FileHeader, error) {
	const op = "Importer.DownloadFile"

	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("File with the path %s not found", path.Base(url)), Operation: op, Err: fmt.Errorf("status code of %v with the url of: %s", resp.StatusCode, url)}
	}

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, err := writer.CreateFormFile("file", path.Base(url))
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not create new file", Operation: op, Err: err}
	}

	_, err = io.Copy(part, resp.Body)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not copy new file", Operation: op, Err: err}
	}

	err = writer.Close()
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not close file", Operation: op, Err: err}
	}

	mr := multipart.NewReader(body, writer.Boundary())
	mt, err := mr.ReadForm(99999)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not read new file", Operation: op, Err: err}
	}

	return mt.File["file"][0], nil
}"
}
{
file:./api/importer/wordpress/verbis.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package wordpress

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/ainsleyclark/verbis/api/importer"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gookit/color"
	"github.com/kyokomi/emoji"
	"mime/multipart"
	"runtime"
	"strings"
	"sync"
)

// TODO: This needs to be dynamic.
var (
	resource   = "news"
	layout     = "main"
	template   = "news-single"
	fieldUuid  = "2dedc760-5016-11eb-ae93-0242ac130002"
	userRoleId = 2
	trackChan  = make(chan int, runtime.NumCPU()*4)
	wg         = sync.WaitGroup{}
)

type Convert struct {
	XML       WpXml
	failed    Failures
	store     *models.Store
	authors   []domain.User
	owner     domain.User
	sendEmail bool
}

type Result struct {
	Failed     Failures
	Posts      []domain.PostData
	Authors    []domain.UserPart
	Categories []domain.Category
}

// New - Construct
func New(xmlPath string, s *models.Store, sendEmail bool) (*Convert, error) {
	wp := NewWordpressXml()
	err := wp.ReadFile(xmlPath)
	if err != nil {
		return nil, err
	}

	owner, err := s.User.GetOwner()
	if err != nil {
		return nil, err
	}

	return &Convert{
		XML:       wp,
		failed:    Failures{},
		store:     s,
		owner:     owner,
		sendEmail: sendEmail,
	}, nil
}

// Import
//
// The XML file into Wordpress by populating Authors
// and Posts.
func (c *Convert) Import() {

	authors := c.populateAuthors()
	posts, categories := c.populatePosts()

	r := Result{
		Failed:     c.failed,
		Posts:      posts,
		Authors:    authors,
		Categories: categories,
	}

	// TODO: To be returned here as a WebHook or placed in a Debug Table
	emoji.Println(":check_mark: Successful entries:")
	fmt.Println(fmt.Sprintf("Posts: %d", len(r.Posts)))
	fmt.Println(fmt.Sprintf("Authors: %d", len(r.Authors)))
	fmt.Println(fmt.Sprintf("Categories: %d", len(r.Authors)))
	fmt.Println()
	emoji.Println(":cross_mark: Failed entries")
	fmt.Println(fmt.Sprintf("Posts: %d", len(r.Failed.Posts)))
	fmt.Println(fmt.Sprintf("Authors: %d", len(r.Failed.Authors)))
}

// Failed import defines the errors that occured when importing
// multiple entities into Verbis.
type Failures struct {
	Posts   []FailedPost
	Authors []FailedAuthor
}

// FailedMedia defines a failure of a post that occurred during migration.
type FailedPost struct {
	Post  Item
	Media []FailedMedia
	Error error
}

// FailedMedia defines a failure of an upload to the media library
type FailedMedia struct {
	Url   string
	Error error
}

// FailedAuthor defines a failure of an author that occurred during migration
type FailedAuthor struct {
	FirstName string
	LastName  string
	Email     string
	Error     error
}

var (
	posts      []domain.PostData // Successful posts that have been inserted
	categories []domain.Category // Successful categories that have been inserted
)

// populatePosts
//
// Loops over all of the Wordpress item and creates a Verbis post.
// Spawns a new process to insert into the database.
func (c *Convert) populatePosts() ([]domain.PostData, []domain.Category) {
	posts = []domain.PostData{}
	categories = []domain.Category{}

	for _, item := range c.XML.Channel.Items {
		trackChan <- 1
		go c.addItem(item)
	}

	wg.Wait()

	return posts, categories
}

// addItem
//
// This function will append to the FailedPosts array if there
// was a problem parsing any of the content.
func (c *Convert) addItem(item Item) {

	wg.Add(1)
	defer func() {
		wg.Done()
		<-trackChan
	}()

	link, err := importer.ParseLink(item.Link)
	if err != nil {
		c.failPost(item, nil, err)
		return
	}

	uuid, err := importer.ParseUUID(fieldUuid)
	if err != nil {
		c.failPost(item, nil, err)
	}

	content, failed, err := c.parseContent(item.Content)
	if err != nil {
		c.failPost(item, failed, err)
	}

	p := domain.PostCreate{
		Post: domain.Post{
			Slug:         fmt.Sprintf("/%v/%v", resource, strings.ReplaceAll(link, "/", "")),
			Title:        item.Title,
			Status:       getStatus(item.Status),
			Resource:     &resource,
			PageTemplate: template,
			PageLayout:   layout,
			PublishedAt:  &item.PubDatetime,
			CreatedAt:    &item.PostDatetime,
			UpdatedAt:    &item.PostDatetime,
			SeoMeta:      c.getSeoMeta(item.Title, item.Meta),
		},
		Author: c.findAuthor(item),
		Fields: []domain.PostField{
			{
				UUID:          uuid,
				Type:          "richtext",
				Name:          "content",
				OriginalValue: domain.FieldValue(content),
			},
		},
	}

	category, err := c.getCategory(item.Categories)
	if err != nil && errors.Code(err) != errors.NOTFOUND {
		c.failPost(item, nil, err)
		categories = append(categories, category)
	}

	if err == nil {
		p.Category = &category.Id
	}

	post, err := c.store.Posts.Create(&p)
	if err != nil {
		c.failPost(item, nil, err)
		return
	}

	posts = append(posts, post)
}

// parseContent
//
// Accepts a HTML document as a string and uses the ParseHTML function to
// loop over the images, upload them and modify the contents of the HTML
// file If a media item failed to be uploaded to the media library
// or a the file could not be downloaded (such as a 404) the
// media item will be appended to the FailedMedia array.
//
// Returns the modified HTML file, the FailedMedia array and an error
// if there was a problem parsing the HTML.
func (c *Convert) parseContent(content string) (string, []FailedMedia, error) {
	var failed []FailedMedia
	parsed, err := importer.ParseHTML(content, func(file *multipart.FileHeader, url string, err error) string {

		if err != nil {
			failed = append(failed, FailedMedia{Url: url, Error: err})
			return ""
		}

		media, err := c.store.Media.Upload(file, c.owner.Token)
		if err != nil {
			failed = append(failed, FailedMedia{Url: url, Error: err})
			return ""
		}

		return media.Url
	})

	if err != nil {
		return "", failed, err
	}

	return parsed, failed, nil
}

// getCategory
//
// Converts a 'Wordpress' category into a domain.Category
//
// Returns found category if it already exists.
// Returns newly created category if it doesnt exist.
// Returns errors.NOTFOUND if not category is attached to the post.
func (c *Convert) getCategory(categories []Category) (domain.Category, error) {
	const op = "WordpressConvertor.getCategory"

	if len(categories) == 0 {
		return domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: "No category is attached to the post type.", Operation: op, Err: fmt.Errorf("no category found")}
	}

	wp := categories[0]

	if c.store.Categories.ExistsBySlug(wp.URLSlug) {
		return c.store.Categories.GetBySlug(wp.URLSlug)
	}

	return c.store.Categories.Create(&domain.Category{
		Slug:     wp.URLSlug,
		Name:     wp.DisplayName,
		Resource: resource,
	})
}

// getSeoMeta
//
// Constructs domain.PostOptions and attaches meta titles and
// meta descriptions if the 'Yoast' plugin exists in
// 'Wordpress'.
func (c *Convert) getSeoMeta(title string, meta []Meta) domain.PostOptions {
	m := domain.PostOptions{
		Meta: &domain.PostMeta{
			Title: title,
			Twitter: domain.PostTwitter{
				Title: title,
			},
			Facebook: domain.PostFacebook{
				Title: title,
			},
		},
	}

	for _, v := range meta {
		if v.MetaKey == "_yoast_wpseo_metadesc" {
			m.Meta.Description = v.MetaValue
			m.Meta.Twitter.Description = v.MetaValue
			m.Meta.Facebook.Description = v.MetaValue
		}
	}

	return m
}

// findAuthor
//
// Looks through the array of authors attached to the Convert
// struct and returns the Author ID.
//
// Returns owner ID if there was an error obtaining the Wordpress
// authors or no author exists in the Convert authors array.
func (c *Convert) findAuthor(item Item) int {
	author, err := c.XML.AuthorForLogin(item.Creator)
	if err != nil {
		return c.owner.Id
	}

	for _, v := range c.authors {
		if v.Email == author.AuthorEmail {
			return v.Id
		}
	}

	return c.owner.Id
}

// populateAuthors
//
// Loops over the Wordpress authors and checks to see if they exist.
// If they dont, a new user will be created and an email will be
// sent with there their password. If they do exist, the author
// will be appended to the Convert author array.
// The user will be added to the FailedAuthors array in any case of error.
func (c *Convert) populateAuthors() []domain.UserPart {

	var users []domain.UserPart

	for _, v := range c.XML.Channel.Authors {
		exists := c.store.User.ExistsByEmail(v.AuthorEmail)

		if !exists {

			user, password, err := c.createUser(v)
			if err != nil {
				continue
			}

			color.Green.Println(fmt.Sprintf("User: %s Password: %s", user.Email, password))

			if c.sendEmail {
				// User can't login!
				err = importer.SendNewPassword(user.HideCredentials(), password, c.store.Site.GetGlobalConfig())
				if err != nil {
					color.Red.Println(err)
					continue
				}
			}

			users = append(users, user.HideCredentials())
			continue
		}

		user, err := c.store.User.GetByEmail(v.AuthorEmail)
		if err != nil {
			c.failAuthor(v.AuthorFirstName, v.AuthorLastName, v.AuthorEmail, err)
			continue
		}

		c.authors = append(c.authors, user)
	}

	return users
}

// createUser
//
// Generates a new password and continues to create a new User
// from the repository. If the user failed to be created it
// will be added to the FailedAuthors array.
//
// Returns the newly created password if successful.
// Returns an error if the user could not be created.
func (c *Convert) createUser(a Author) (domain.User, string, error) {
	password := encryption.CreatePassword()

	user := &domain.UserCreate{
		User: domain.User{
			UserPart: domain.UserPart{
				FirstName: a.AuthorFirstName,
				LastName:  a.AuthorLastName,
				Email:     a.AuthorEmail,
				Role: domain.UserRole{
					Id: userRoleId,
				},
			},
		},
		Password:        password,
		ConfirmPassword: password,
	}

	u, err := c.store.User.Create(user)
	if err != nil {
		c.failAuthor(a.AuthorFirstName, a.AuthorLastName, a.AuthorEmail, err)
		return domain.User{}, "", err
	}

	c.authors = append(c.authors, u)

	return user.User, password, nil
}

// getStatus
//
// Converts the Wordpress status to Verbis specific status's.
func getStatus(status string) string {
	if status == "publish" {
		return "published"
	}
	return status
}

// failPost
//
// Append to the failed posts array.
func (c *Convert) failPost(item Item, media []FailedMedia, err error) {
	c.failed.Posts = append(c.failed.Posts, FailedPost{
		Post:  item,
		Media: media,
		Error: err,
	})
}

// Append
//
// Append to the failed authors array.
func (c *Convert) failAuthor(fName string, lName string, email string, err error) {
	c.failed.Authors = append(c.failed.Authors, FailedAuthor{
		FirstName: fName,
		LastName:  lName,
		Email:     email,
		Error:     err,
	})
}"
}
{
file:./api/importer/wordpress/convert.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package wordpress

import (
	"encoding/xml"
	"errors"
	"io/ioutil"
	"time"
)

type WpXml struct {
	Channel        Channel `xml:"channel"`
	CreatorCounts  map[string]int
	CreatorToIndex map[string]int
}

type Rss struct {
	Channel Channel `xml:"channel"`
}

type Channel struct {
	Title   string   `xml:"title"`
	Link    string   `xml:"link"`
	Authors []Author `xml:"author"`
	Items   []Item   `xml:"item"`
}

// Author is the WordPress XML author object.
type Author struct {
	AuthorID          int        `xml:"author_id"`
	AuthorLogin       string     `xml:"author_login"`
	AuthorEmail       string     `xml:"author_email"`
	AuthorDisplayName string     `xml:"author_display_name"`
	AuthorFirstName   string     `xml:"author_first_name"`
	AuthorLastName    string     `xml:"author_last_name"`
	AuthorArticles    []ItemThin `xml:"-"`
}

// Item is a WordPress XML item which can be a post, page or other object.
type Item struct {
	ID           int        `xml:"post_id"`
	Title        string     `xml:"title"`
	Creator      string     `xml:"creator"`
	Encoded      []string   `xml:"encoded"`
	IsSticky     int        `xml:"is_sticky"`
	Link         string     `xml:"link"`
	PubDate      string     `xml:"pubDate"`
	Description  string     `xml:"description"`
	PostDate     string     `xml:"post_date"`
	PostDateGmt  string     `xml:"post_date_gmt"`
	PostName     string     `xml:"post_name"`
	PostType     string     `xml:"post_type"`
	Status       string     `xml:"status"`
	Categories   []Category `xml:"category"`
	Comments     []Comment  `xml:"comment"`
	Meta         []Meta     `xml:"postmeta"`
	Content      string
	PostDatetime time.Time
	PubDatetime  time.Time
}

// ItemThin is a WordPress XML item that is used as additional
// metadata in the Author object.
type ItemThin struct {
	Title string
	Index int
}

type Category struct {
	Domain      string `xml:"domain,attr"`
	DisplayName string `xml:",chardata"`
	URLSlug     string `xml:"nicename,attr"`
}

type Comment struct {
	ID          int    `xml:"comment_id"`
	Parent      int    `xml:"comment_parent"`
	Author      string `xml:"comment_author"`
	AuthorEmail string `xml:"comment_author_email"`
	AuthorURL   string `xml:"comment_author_url"`
	DateGmt     string `xml:"comment_date_gmt"`
	Content     string `xml:"comment_content"`
	IndentLevel int    `xml:"-"`
}

type Meta struct {
	Text      string `xml:",chardata"`
	MetaKey   string `xml:"meta_key"`
	MetaValue string `xml:"meta_value"`
}

func NewWordpressXml() WpXml {
	return WpXml{
		CreatorCounts:  map[string]int{},
		CreatorToIndex: map[string]int{}}
}

// ReadXml reads a WordPress XML file from the provided path.
func (wpxml *WpXml) ReadFile(filepath string) error {
	bytes, err := ioutil.ReadFile(filepath)
	if err != nil {
		return err
	}
	err = xml.Unmarshal(bytes, &wpxml)
	if err != nil {
		return err
	}
	wpxml.inflate()
	return nil
}

func (wpxml *WpXml) inflate() error {
	creatorMap := map[string]int{}
	for i, item := range wpxml.Channel.Items {
		if len(item.Creator) > 0 {
			if _, ok := creatorMap[item.Creator]; ok {
				creatorMap[item.Creator]++
			} else {
				creatorMap[item.Creator] = 1
			}
		}

		item = wpxml.inflateItem(item)
		wpxml.Channel.Items[i] = item
	}
	wpxml.CreatorCounts = creatorMap
	wpxml.inflateAuthors()
	return nil
}

func (wpxml *WpXml) inflateItem(item Item) Item {
	if len(item.Encoded) > 0 && len(item.Encoded[0]) > 0 {
		item.Content = item.Encoded[0]
		item.Encoded[0] = ""
	}
	if len(item.PostDate) > 0 {
		dt, err := time.Parse("Mon Jan 02 2006 15:04:05 GMT-0700", item.PostDate)
		if err == nil {
			item.PostDatetime = dt
		}
	}
	if len(item.PubDate) > 0 {
		dt, err := time.Parse(time.RFC1123Z, item.PubDate)
		if err == nil {
			item.PubDatetime = dt
		}
	}
	return item
}

func (wpxml *WpXml) inflateAuthors() error {
	a2i := wpxml.AuthorsToIndex()
	for i, item := range wpxml.Channel.Items {
		if len(item.Creator) > 0 {
			authorLogin := item.Creator
			if _, ok := a2i[authorLogin]; ok {
				authorIndex := a2i[authorLogin]
				itemThin := ItemThin{Title: item.Title, Index: i}
				if wpxml.Channel.Authors[authorIndex].AuthorArticles == nil {
					wpxml.Channel.Authors[authorIndex].AuthorArticles = []ItemThin{}
				}
				wpxml.Channel.Authors[authorIndex].AuthorArticles = append(wpxml.Channel.Authors[authorIndex].AuthorArticles, itemThin)
			}
		}
	}
	wpxml.CreatorToIndex = a2i
	return nil
}

func (wpxml *WpXml) AuthorsToIndex() map[string]int {
	a2i := map[string]int{}
	for i, author := range wpxml.Channel.Authors {
		a2i[author.AuthorLogin] = i
	}
	return a2i
}

// AuthorForLogin returns the Author object for a given AuthorLogin
// or username.
func (wpxml *WpXml) AuthorForLogin(authorLogin string) (Author, error) {
	a2i := wpxml.CreatorToIndex
	if index, ok := a2i[authorLogin]; ok {
		author := wpxml.Channel.Authors[index]
		return author, nil
	}
	return Author{}, errors.New("Author Not Found")
}"
}
{
file:./api/importer/mail.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package importer

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/mail/events"
)

func SendNewPassword(user domain.UserPart, password string, site domain.Site) error {
	mailer, err := events.NewChangedPassword()
	if err != nil {
		return err
	}
	return mailer.Send(user, password, site)
}"
}
{
file:./api/importer/html.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package importer

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"golang.org/x/net/html"
	"mime/multipart"
	"strings"
)

// uploader defines the return return function thats called when a image
// is found crawling the content.
type uploader func(file *multipart.FileHeader, url string, err error) string

// ParseHTML
//
func ParseHTML(content string, upload uploader) (string, error) {
	const op = "Importer.ParseHTML"

	doc, err := html.Parse(strings.NewReader(content))
	if err != nil {
		return "", err
	}

	var f func(*html.Node) bool
	f = func(n *html.Node) bool {
		if n.Type == html.ElementNode && n.Data == "img" {
			for index, img := range n.Attr {
				if img.Key == "src" {
					file, err := DownloadFile(img.Val)
					url := upload(file, img.Val, err)

					if url == "" {
						break
					}

					n.Attr[index].Val = url
					break
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
		return false
	}

	f(doc)

	var b bytes.Buffer
	err = html.Render(&b, doc)
	if err != nil {
		return "", &errors.Error{Code: errors.INVALID, Message: "Could not parse HTML", Operation: op, Err: fmt.Errorf("unable to parse HTML")}
	}

	replacer := strings.NewReplacer("<html><head></head><body>", "", "</body></html>", "")

	return replacer.Replace(b.String()), nil
}"
}
{
file:./api/forms/forms.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package forms

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	dynamicstruct "github.com/ompluscator/dynamic-struct"
	"golang.org/x/net/html"
	"mime/multipart"
)

type Reader struct {
	Form   *domain.Form
	Reader dynamicstruct.Reader
}

type FormValues map[string]interface{}

func (f FormValues) JSON() ([]byte, error) {
	const op = "FormValues.JSON"
	v, err := json.Marshal(f)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not process the form fields for storing"), Operation: op, Err: err}
	}
	return v, nil
}

type Sender struct {
	Attachments []Attachment
	Fields      FormValues
}

func NewReader(form *domain.Form) *Reader {
	return &Reader{
		Form:   form,
		Reader: dynamicstruct.NewReader(form.Body),
	}
}

func (r *Reader) Values() (FormValues, Attachments, error) {
	const op = "FormReader.Values"

	m := make(FormValues)
	var attachments Attachments

	var totalSize int64 = 0
	for _, v := range r.Form.Fields {
		field := r.Reader.GetField(v.Label.Name())

		switch v.Type {
		case "file":

			a, err := getAttachment(field.Interface())
			if err != nil {
				return nil, nil, err
			}

			if a == nil {
				continue
			}

			// Add to the total size to ensure its below
			// the UploadLimit
			totalSize += a.Size

			// Append to the attachments
			attachments = append(attachments, a)

			// Set the key of the FormValues to the MD5
			// name of the file.
			m[v.Key] = a.MD5name
		case "checkbox":
			m[v.Key] = field.Bool()
		default:
			str := field.String()
			m[v.Key] = html.EscapeString(str)
		}
	}

	if float64(totalSize/1024)/1024 > UploadLimit {
		return nil, nil, &errors.Error{Code: errors.INVALID, Message: "File attachments have exceeded the upload limit", Operation: op, Err: fmt.Errorf("attachements exceed the upload limit defined")}
	}

	return m, attachments, nil
}

// Struct returns the dynamic struct used for validation.
func ToStruct(form domain.Form) interface{} {
	instance := dynamicstruct.NewStruct()

	for _, v := range form.Fields {
		tag := fmt.Sprintf("json:\"%s\" form:\"%s\"", v.Key, v.Key)
		if v.Required {
			tag = fmt.Sprintf("%s binding:\"required\"", tag)
		}
		instance.AddField(v.Label.Name(), getType(v.Type), tag)
	}

	return instance.Build().New()
}

// getType
//
//
func getType(typ string) interface{} {
	var i interface{} = nil

	switch typ {
	case "text":
		i = ""
	case "int":
		i = 0
	case "float":
		i = 0.0
	case "checkbox":
		i = false
	case "file":
		m := &multipart.FileHeader{}
		i = m
	}

	return i
}"
}
{
file:./api/forms/attachments.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package forms

import (
	//"bytes"
	"encoding/base64"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/ainsleyclark/verbis/api/helpers/mime"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/gabriel-vasile/mimetype"
	"io"
	"io/ioutil"

	//"io/ioutil"
	"mime/multipart"
	"os"
	"path/filepath"
	"time"
)

const (
	// The total upload limit allowed to upload file
	// attachments.
	UploadLimit = 5
)

var (
	// AllowedMimes represents the mime types permitted
	// to be attached to forms.
	AllowedMimes = []string{
		"text/plain",
		"image/jpeg",
		"image/png",
		"image/svg+xml",
		"application/pdf",
		"application/msword",
		"application/vnd.ms-word.document.macroenabled.12",
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document",
		"application/msword",
	}
)

// Attachments defines the slice of mail attachments
type Attachments []*Attachment

// Attachment defines the mail file that has been
// uploaded via the forms endpoint. It contains
// useful information for sending files over
// the mail driver.
type Attachment struct {
	MIMEType string
	Filename string
	MD5name  string
	B64Data  *string
	Size     int64
}

// SizeMB
//
// Returns the attachment file size in megabytes.
func (a *Attachment) SizeMB() int {
	return int(a.Size / 1024)
}

// getAttachment
//
//
func getAttachment(i interface{}) (*Attachment, error) {
	const op = "Forms.getAttachement"

	m, ok := i.(*multipart.FileHeader)
	if !ok {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "", Operation: op, Err: fmt.Errorf("")}
	}

	path, file, teardown, err := createTempFile(m)
	if err != nil {
		return nil, err
	}
	defer teardown()

	mt, err := validateFile(file, m.Size)
	if err != nil {
		return nil, err
	}

	bytes, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "", Operation: op, Err: err}
	}

	md5Name, err := dumpFile(bytes, m.Filename)
	if err != nil {
		return nil, err
	}

	data := b64(bytes)

	return &Attachment{
		MIMEType: mt,
		Filename: m.Filename,
		MD5name:  md5Name,
		B64Data:  &data,
		Size:     m.Size,
	}, nil
}

func createTempFile(m *multipart.FileHeader) (string, *multipart.File, func(), error) {
	const op = "Forms.createTempFile"

	path := os.TempDir() + "/verbis-" + encryption.MD5Hash(time.Now().String()) + filepath.Ext(m.Filename)

	file, err := m.Open()
	if err != nil {
		return "", nil, nil, &errors.Error{Code: errors.INTERNAL, Message: "", Operation: op, Err: err}
	}

	out, err := os.Create(path)
	if err != nil {
		fmt.Println(err)
	}

	t := func() {
		_ = file.Close()
		_ = out.Close()
		_ = os.Remove(path)
	}

	_, err = io.Copy(out, file)
	if err != nil {
		return "", nil, t, &errors.Error{Code: errors.INTERNAL, Message: "", Operation: op, Err: err}
	}

	return path, &file, t, nil
}

// validateFile
//
// Validates the file attachment for mime types and file sizes.
//
// Returns errors.INVALID if the mime type could not to be detected,
// the mime type is not in the list of permitted types or the
// file is above the UploadLimit.
func validateFile(file *multipart.File, size int64) (string, error) {
	const op = "Forms.validateFile"

	typ, err := mimetype.DetectReader(*file)
	if err != nil {
		return "", &errors.Error{Code: errors.INVALID, Message: "Unable to detect filetype", Operation: op, Err: err}
	}

	if !mime.IsValidMime(AllowedMimes, typ.String()) {
		return "", &errors.Error{Code: errors.INVALID, Message: "Mime type not permitted", Operation: op, Err: fmt.Errorf("mime for the uploaded file is not permitted")}
	}

	fileSize := int(1024 / size)
	if fileSize > UploadLimit {
		return "", &errors.Error{Code: errors.INVALID, Message: "File is too large to upload", Operation: op, Err: fmt.Errorf("the file exceeds the upload limit for uploading")}
	}

	return typ.String(), nil
}

// b64
//
// Base64 encodes the attachment to be sent via the
// mailer.
func b64(data []byte) string {
	return base64.StdEncoding.EncodeToString(data)
}

// dumpFile
//
// Saves the mail attachment to the system by taking
// in the data and name of the file, a new MD5
// hash of the filename will be created and
// saved to the forms storage folder.
//
// Returns errors.INTERNAL if the file could not be created or saved.
func dumpFile(b []byte, name string) (string, error) {
	const op = "Forms.dumpFile"

	ext := filepath.Ext(name)
	file := encryption.MD5Hash(name+time.Now().String()) + ext
	dst := paths.Forms() + "/" + file

	err := ioutil.WriteFile(dst, b, 777)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: "Unable to create file to save mail attachment to the system.", Operation: op, Err: err}
	}

	return file, nil
}"
}
{
file:./api/logger/hooks.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package logger

import (
	"encoding/json"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	log "github.com/sirupsen/logrus"
	"io"
)

// WriterHook is a hook that writes logs of specified LogLevels to specified Writer
type WriterHook struct {
	Writer    io.Writer
	LogLevels []log.Level
}

// Fire will be called when some logging function is called with current hook
// It will format log entry to string and write it to appropriate writer
func (hook *WriterHook) Fire(entry *log.Entry) error {

	if !environment.IsDebug() {
		if err := entry.Data["error"]; err != nil {
			e, ok := entry.Data["error"].(*errors.Error)
			if !ok {
				return nil
			}

			m, err := json.Marshal(log.Fields{
				"level":     entry.Level,
				"code":      e.Code,
				"message":   e.Message,
				"operation": e.Operation,
				"err":       e.Err.Error(),
				//"stack":     errors.Stack(e),
				"time": entry.Time.Format("2006-01-02 15:04:05"),
			})

			if err != nil {
				return err
			}

			str := string(m) + "\n"
			_, err = hook.Writer.Write([]byte(str))
			return err
		}
	}

	line, err := entry.String()
	if err != nil {
		return err
	}
	_, err = hook.Writer.Write([]byte(line))
	return err
}

// Levels define on which log levels this hook would trigger
func (hook *WriterHook) Levels() []log.Level {
	return hook.LogLevels
}"
}
{
file:./api/logger/formatter.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package logger

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gookit/color"
	"github.com/sirupsen/logrus"
	"reflect"
	"strings"
	"time"
)

// Formatter implements logrus.Formatter interface.
type Formatter struct {
	Colours         bool
	TimestampFormat string
}

// Format building log message.
func (f *Formatter) Format(entry *logrus.Entry) ([]byte, error) {
	b := &bytes.Buffer{}

	b.WriteString("[VERBIS] ")

	// Print the time
	timestampFormat := f.TimestampFormat
	if timestampFormat == "" {
		timestampFormat = time.StampMilli
	}
	b.WriteString(entry.Time.Format(timestampFormat))

	// Get the response code colour
	cc := color.Style{}
	status := entry.Data["status_code"]
	if codeInt, ok := status.(int); ok {
		if codeInt < 400 {
			cc = color.Style{color.FgLightWhite, color.BgGreen, color.OpBold}
		} else {
			cc = color.Style{color.FgLightWhite, color.BgRed, color.OpBold}
		}
	}

	// Print the response code
	if status != "" && status != nil {
		b.WriteString(" |")
		if f.Colours {
			b.WriteString(cc.Sprintf("%d", status))
		} else {
			b.WriteString(fmt.Sprintf("%d", status))
		}
		b.WriteString("| ")
	} else {
		b.WriteString(" | ")
	}

	// Get level the colour
	lc := color.Style{}
	switch entry.Level {
	case logrus.DebugLevel:
		lc = color.Style{color.FgGray, color.OpBold}
	case logrus.WarnLevel:
		lc = color.Style{color.FgYellow, color.OpBold}
	case logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel:
		lc = color.Style{color.FgRed, color.OpBold}
	default:
		lc = color.Style{color.FgBlue, color.OpBold}
	}

	// Print the level
	level := strings.ToUpper(entry.Level.String())
	if f.Colours {
		b.WriteString(lc.Sprintf("["))
		b.WriteString(lc.Sprintf(level))

		if entry.Level == logrus.InfoLevel {
			b.WriteString(lc.Sprintf("] "))
		} else {
			b.WriteString(lc.Sprintf("]"))
		}
	} else {
		b.WriteString(fmt.Sprintf("["))
		b.WriteString(fmt.Sprintf(level))

		if entry.Level == logrus.InfoLevel {
			b.WriteString(fmt.Sprintf("] "))
		} else {
			b.WriteString(fmt.Sprintf("]"))
		}
	}

	// Print the IP
	if ip, ok := entry.Data["client_ip"].(string); ok {
		b.WriteString(fmt.Sprintf(" | %s | ", ip))
	}

	// Print the method
	if method, ok := entry.Data["request_method"].(string); ok {
		rc := color.Style{color.FgLightWhite, color.BgBlue, color.OpBold}
		if len(method) == 3 {
			if f.Colours {
				b.WriteString(rc.Sprintf("  %s   ", method))
			} else {
				b.WriteString(fmt.Sprintf("  %s   ", method))
			}
		} else {
			if f.Colours {
				b.WriteString(rc.Sprintf("  %s  ", method))
			} else {
				b.WriteString(fmt.Sprintf("  %s  ", method))
			}
		}
	}

	// Print the url
	if url, ok := entry.Data["request_url"].(string); ok {
		b.WriteString(fmt.Sprintf(" \"%s\"", url))
	}

	// Print the message
	if msg, ok := entry.Data["message"].(string); ok {
		if msg != "" {
			b.WriteString(fmt.Sprintf("| [msg] %s |", msg))
		}
	}

	// Print any errors if one is set
	// TODO Fix here
	// THIS is coming a nil pointer deference!
	if reflect.TypeOf(entry.Data["error"]).String() == "*errors.Error" {
		err := entry.Data["error"].(*errors.Error)
		s := f.printError(*err)
		b.Write(s.Bytes())
	} else if errorData, ok := entry.Data["error"].(errors.Error); ok {
		s := f.printError(errorData)
		b.Write(s.Bytes())
	}

	b = bytes.NewBuffer([]byte(strings.TrimSuffix(b.String(), "|")))

	b.WriteString("\n")

	return b.Bytes(), nil
}

func (f *Formatter) printError(errorData errors.Error) *bytes.Buffer {
	b := &bytes.Buffer{}

	if errorData.Error() != "" {
		//if errorData.Code != errors.NOTFOUND {
		if errorData.Code != "" {
			if f.Colours {
				b.WriteString(color.Red.Sprintf(" [code] %s", errorData.Code))
			} else {
				b.WriteString(fmt.Sprintf("| [code] %s", errorData.Code))
			}
		}
		if errorData.Operation != "" {
			if api.SuperAdmin {
				if f.Colours {
					b.WriteString(color.Red.Sprintf(" [operation] %s", errorData.Operation))
				} else {
					b.WriteString(fmt.Sprintf(" [operation] %s", errorData.Operation))
				}
			}
		}
		if errorData.Err != nil {
			if f.Colours {
				b.WriteString(color.Red.Sprintf(" [error] %s", errorData.Err.Error()))
			} else {
				b.WriteString(fmt.Sprintf(" [error] %s", errorData.Err.Error()))
			}
		}
		//	}
	}

	return b
}"
}
{
file:./api/logger/logger.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package logger

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	log "github.com/sirupsen/logrus"
	"io"
	"io/ioutil"
	"os"
)

// logFiles defines the files to be written to when app debug is set to false
type logFiles struct {
	accessLog io.Writer
	errorLog  io.Writer
}

// Init will determine if SuperAdmin and set logging levels
// dependant on environment variables.
func Init(config config.Configuration) error {

	// Set log level depending on SuperAdmin var
	if api.SuperAdmin {
		log.SetLevel(log.DebugLevel)
	} else {
		log.SetLevel(log.InfoLevel)
	}

	// Log json to file if environment is in production if not,
	// log to console.
	if environment.IsDebug() {
		log.SetFormatter(&Formatter{
			TimestampFormat: "2006-01-02 15:04:05",
			Colours:         true,
		})
	} else {
		logs, err := getLogFiles(config)
		if err != nil {
			return err
		}

		log.SetFormatter(&log.JSONFormatter{
			TimestampFormat: "2006-01-02 15:04:05",
		})

		setupLogs(logs)
	}

	return nil
}

// getLogFiles checks to see if the log files set out in the logs.yml file
// in the configuration is valid. If it is set to default (storage/logs)
// and the file does not exist, it will create them. If set to a
// custom path, will return an error if not found.
func getLogFiles(config config.Configuration) (*logFiles, error) {

	logFiles := logFiles{}

	// Access Log
	configAccess := config.Logs.AccessLog
	if configAccess == "default" {
		path := paths.Storage() + "/logs/access.log"
		f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

		if err != nil {
			return nil, fmt.Errorf("Could not create the acccess.log file with the path %s", path)
		}

		logFiles.accessLog = f
	} else {
		if exists := files.Exists(configAccess); !exists {
			return nil, fmt.Errorf("The access log with the path %s, could not be found.", configAccess)
		} else {
			f, err := os.OpenFile(configAccess, os.O_APPEND|os.O_WRONLY, 0644)

			if err != nil {
				return nil, err
			}

			logFiles.accessLog = f
		}
	}

	// Error log
	configError := config.Logs.ErrorLog
	if configError == "default" {
		path := paths.Storage() + "/logs/error.log"
		f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

		if err != nil {
			return nil, fmt.Errorf("Could not create the error.log file with the path %s", path)
		}

		logFiles.errorLog = f
	} else {
		if exists := files.Exists(configError); !exists {
			return nil, fmt.Errorf("The error log with the path %s, could not be found.", configError)
		} else {
			f, err := os.OpenFile(configAccess, os.O_APPEND|os.O_WRONLY, 0644)

			if err != nil {
				return nil, err
			}

			logFiles.errorLog = f
		}
	}

	return &logFiles, nil
}

// setupLogs adds hooks to send logs to different destinations depending on level
func setupLogs(logs *logFiles) {

	// Send all logs to nowhere by default
	log.SetOutput(ioutil.Discard)

	// Send logs with level higher than warning to stderr
	log.AddHook(&WriterHook{
		Writer: logs.errorLog,
		LogLevels: []log.Level{
			log.PanicLevel,
			log.FatalLevel,
			log.ErrorLevel,
			log.WarnLevel,
		},
	})

	// Send info and debug logs to stdout
	log.AddHook(&WriterHook{
		Writer: logs.accessLog,
		LogLevels: []log.Level{
			log.InfoLevel,
			log.DebugLevel,
		},
	})
}"
}
{
file:./api/cache/cache.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cache

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/patrickmn/go-cache"
	"time"
)

var (
	Store *cache.Cache
)

type Cacher interface {
	Get(k string) (interface{}, bool)
	Set(k string, x interface{}, d time.Duration)
	Flush()
}

const (
	// For use with functions that take an expiration time.
	RememberForever time.Duration = -1
	postIdKey                     = "post-id-"
)

// Init set-ups go-cache with defaults
func Init() {
	Store = cache.New(5*time.Minute, 10*time.Minute)
}

func ClearPostCache(id int) {
	Store.Delete(GetPostKey(id))
}

func ClearUserCache(userId int, posts []domain.PostData) {
	for _, v := range posts {
		if v.UserId == userId {
			ClearPostCache(v.Id)
		}
	}
}

func ClearCategoryCache(categoryId int, posts []domain.PostData) {
	for _, v := range posts {
		if v.Category.Id == categoryId {
			ClearPostCache(v.Id)
		}
	}
}

func GetPostKey(id int) string {
	return fmt.Sprintf("%s%d", postIdKey, id)
}"
}
{
file:./api/test/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package test"
}
{
file:./api/config/config.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package config

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"gopkg.in/yaml.v3"
)

// Global Configuration, sets defaults to ensure that there are no
// empty values within the configuration to prevent any errors.
type Configuration struct {
	Admin admin
	Media media
	Logs  logs
}

// Admin
type admin struct {
	Path                string `yaml:"admin_path,omitempty"`
	InactiveSessionTime int    `yaml:"inactive_session_time,omitempty"`
}

// Media
type media struct {
	UploadPath       string   `yaml:"upload_path"`
	AllowedFileTypes []string `yaml:"allowed_file_types"`
}

// Logs
type logs struct {
	AccessLog string `yaml:"access_log"`
	ErrorLog  string `yaml:"error_log"`
}

//
//var (
//	Admin = admin{
//		Path:                "admin",
//		InactiveSessionTime: 60,
//	}
//	Media = media{
//		UploadPath:       "",
//		AllowedFileTypes: nil,
//	}
//	Template = template{
//		FileExtension: ".cms",
//		TemplateDir:   "templates",
//		LayoutDir:     "layouts",
//	}
//	Logs = logs{
//		AccessLog: "default",
//		ErrorLog:  "default",
//	}
//)

func New() (*Configuration, error) {
	c := &Configuration{
		Admin: admin{
			Path:                "admin",
			InactiveSessionTime: 60,
		},
		Media: media{
			UploadPath:       "",
			AllowedFileTypes: nil,
		},
		Logs: logs{
			AccessLog: "default",
			ErrorLog:  "default",
		},
	}

	if err := c.Init(); err != nil {
		return nil, err
	}

	return c, nil
}

// Init the configuration, obtain all of the yaml files
// within the config directory and set variables.
// Returns errors.INTERNAL if the unmarshal was unsuccessful.
func (c *Configuration) Init() error {
	const op = "config.Init"

	// Admin
	a, err := files.LoadFile(paths.Base() + "/config/admin.yml")
	if err != nil {
		return err
	}
	if err := yaml.Unmarshal(a, &c.Admin); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not unmarshal the admin.yml file", Operation: op, Err: err}
	}

	// Media
	m, err := files.LoadFile(paths.Base() + "/config/media.yml")
	if err != nil {
		return err
	}
	if err := yaml.Unmarshal(m, &c.Media); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not unmarshal the media.yml file", Operation: op, Err: err}
	}

	// Logs
	l, err := files.LoadFile(paths.Base() + "/config/logs.yml")
	if err != nil {
		return err
	}
	if err := yaml.Unmarshal(l, &c.Logs); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not unmarshal the logs.yml file", Operation: op, Err: err}
	}

	return nil
}

// Cache the configuration
func (c *Configuration) Cache() {
	cache.Store.Set("config_admin", c.Admin, cache.RememberForever)
	cache.Store.Set("config_media", c.Media, cache.RememberForever)
}

// CacheClear - Clear the configuration
func (c *Configuration) CacheClear() {
	cache.Store.Delete("config_admin")
	cache.Store.Delete("config_media")
	cache.Store.Delete("config_template")
}

// getConfigPath obtains the configuration path of the yaml files
//func (c *Configuration) getConfigPath() string {
//	const op = "config.getConfigPath"
//	path := ""
//	if environment.IsProduction() {
//		path, _ = filepath.Abs(filepath.Dir(os.Args[0]))
//	} else {
//		_, b, _, _ := runtime.Caller(0)
//		path = filepath.Join(filepath.Dir(b), "../..")
//	}
//	return path + "/config"
//}"
}
{
file:./api/mail/mailer.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mail

import (
	"fmt"
	sp "github.com/SparkPost/gosparkpost"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/forms"
	"github.com/ainsleyclark/verbis/api/helpers/html"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	log "github.com/sirupsen/logrus"
)

type Mailer struct {
	client       sp.Client
	Config       config.Configuration
	Transmission Sender
	FromAddress  string
	FromName     string
}

type Sender struct {
	To          []string
	Subject     string
	HTML        string
	Attachments forms.Attachments
}

type Data map[string]interface{}

// New, Create a new mailable instance using environment variables.
func New() (*Mailer, error) {
	const op = "mail.New"
	m := &Mailer{}
	if err := m.load(); err != nil {
		return &Mailer{}, err
	}
	return m, nil
}

// Load the mailer and connect to sparkpost
// Returns errors.INTERNAL if the new mailer instance could not be created
func (m *Mailer) load() error {
	const op = "mail.Load"

	mailConf := environment.GetMailConfiguration()

	config := &sp.Config{
		BaseUrl:    mailConf.SparkpostUrl,
		ApiKey:     mailConf.SparkpostApiKey,
		ApiVersion: 1,
	}

	var client sp.Client
	err := client.Init(config)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not create a new mailer instance", Operation: op, Err: err}
	}
	m.client = client

	m.FromAddress = mailConf.FromAddress
	m.FromName = mailConf.FromName

	return nil
}

// Create a Transmission using an inline Recipient List
// and inline email Content.
// Returns errors.INVALID if the mail failed to send via sparkpost.
func (m *Mailer) Send(t *Sender) {
	const op = "mail.Send"

	content := sp.Content{
		HTML:    t.HTML,
		From:    m.FromAddress,
		Subject: t.Subject,
	}

	if len(t.Attachments) != 0 {
		var att []sp.Attachment
		for _, v := range t.Attachments {
			att = append(att, sp.Attachment{
				MIMEType: v.MIMEType,
				Filename: v.Filename,
				B64Data:  *v.B64Data,
			})
		}
		content.Attachments = att
	}

	tx := &sp.Transmission{
		Recipients: t.To,
		Content:    content,
	}

	id, _, err := m.client.Send(tx)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("Mail sending failed: %s", id), Operation: op, Err: err},
		})
		return
	}

	// TODO: Nil pointer dereference here for logging?
	fmt.Println("Email successfully sent")
}

// Execute the mail HTML files
// Returns errors.INTERNAL if the render failed
func (m *Mailer) ExecuteHTML(file string, data interface{}) (string, error) {
	const op = "mail.ExecuteHTML"
	path := paths.Web() + "/mail/" + file
	tmpl, err := html.RenderTemplate("main", data, paths.Web()+"/mail/main-layout.html", path)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to render the template: %s", path), Operation: op, Err: err}
	}
	return tmpl, nil
}"
}
{
file:./api/mail/events/newpassword.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package events

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/mail"
)

// ChangedPassword defines the event instance for new passwords reset by the system
type ChangedPassword struct {
	mailer *mail.Mailer
}

// NewPassword creates a new reset password event
func NewChangedPassword() (*ChangedPassword, error) {
	const op = "events.NewResetPassword"

	m, err := mail.New()
	if err != nil {
		return &ChangedPassword{}, err
	}

	return &ChangedPassword{
		mailer: m,
	}, nil
}

// Send the reset password event.
func (e *ChangedPassword) Send(u domain.UserPart, password string, site domain.Site) error {
	const op = "events.ResetPassword.Send"

	data := mail.Data{
		"AppUrl":    site.Url,
		"AppTitle":  site.Title,
		"AdminPath": e.mailer.Config.Admin.Path,
		"UserName":  u.FirstName,
		"Password":  password,
		"Email":     u.Email,
	}

	html, err := e.mailer.ExecuteHTML("new-password.html", data)
	if err != nil {
		return err
	}

	tm := mail.Sender{
		To:      []string{u.Email},
		Subject: fmt.Sprintf("New Login Details for %s", site.Title),
		HTML:    html,
	}

	e.mailer.Send(&tm)

	return nil
}"
}
{
file:./api/mail/events/formsend.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package events

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/forms"
	"github.com/ainsleyclark/verbis/api/mail"
)

// FormSend defines the event instance for emailing forms
type FormSend struct {
	mailer *mail.Mailer
	config config.Configuration
}

type FormSendData struct {
	Site   domain.Site
	Form   *domain.Form
	Values forms.FormValues
}

// NewVerifyEmail creates a new verify email event
func NewFormSend(config config.Configuration) (*FormSend, error) {
	const op = "events.NewFormSend"

	m, err := mail.New()
	if err != nil {
		return &FormSend{}, err
	}

	return &FormSend{
		mailer: m,
		config: config,
	}, nil
}

// Send the verify email event.
func (e *FormSend) Send(f *FormSendData, attachments forms.Attachments) error {
	const op = "events.VerifyEmail.Send"

	fv := make(forms.FormValues)
	for _, v := range f.Form.Fields {
		val, ok := f.Values[v.Key]
		if !ok {
			continue
		}
		if v.Type != "file" {
			fv[v.Label.String()] = val
		}
	}
	f.Values = fv

	html, err := e.mailer.ExecuteHTML("form-send.html", &f)
	if err != nil {
		return err
	}

	fmt.Println(f.Form.GetRecipients())

	tm := mail.Sender{
		To:          f.Form.GetRecipients(),
		Subject:     f.Form.EmailSubject,
		HTML:        html,
		Attachments: attachments,
	}

	e.mailer.Send(&tm)

	return nil
}"
}
{
file:./api/mail/events/verifyemail.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package events

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/ainsleyclark/verbis/api/mail"
	"strconv"
)

// VerifyEmail defines the event instance for verifying emails
type VerifyEmail struct {
	mailer *mail.Mailer
	config config.Configuration
}

// NewVerifyEmail creates a new verify email event.
func NewVerifyEmail(config config.Configuration) (*VerifyEmail, error) {
	const op = "events.NewResetPassword"

	m, err := mail.New()
	if err != nil {
		return &VerifyEmail{}, err
	}

	return &VerifyEmail{
		mailer: m,
		config: config,
	}, nil
}

// Send the verify email event.
func (e *VerifyEmail) Send(u *domain.User, title string) error {
	const op = "events.VerifyEmail.Send"

	md5String := encryption.MD5Hash(strconv.Itoa(u.Id) + u.Email)

	data := mail.Data{
		"AppUrl":    environment.GetAppName(),
		"AppTitle":  title,
		"AdminPath": e.mailer.Config.Admin.Path,
		"Token":     md5String,
		"UserName":  u.FirstName,
	}

	html, err := e.mailer.ExecuteHTML("verify-email.html", data)
	if err != nil {
		return err
	}

	tm := mail.Sender{
		To:      []string{u.Email},
		Subject: "Thanks for signing up " + u.FirstName,
		HTML:    html,
	}

	e.mailer.Send(&tm)

	return nil
}"
}
{
file:./api/mail/events/resetpassword.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package events

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/mail"
)

// ResetPassword defines the event instance for resetting passwords
type ResetPassword struct {
	mailer *mail.Mailer
}

// NewResetPassword creates a new reset password event.
func NewResetPassword() (*ResetPassword, error) {
	const op = "events.NewResetPassword"

	m, err := mail.New()
	if err != nil {
		return &ResetPassword{}, err
	}

	return &ResetPassword{
		mailer: m,
	}, nil
}

// Send the reset password event.
func (e *ResetPassword) Send(u *domain.User, url string, token string, title string) error {
	const op = "events.ResetPassword.Send"

	data := mail.Data{
		"AppUrl":    url,
		"AppTitle":  title,
		"AdminPath": e.mailer.Config.Admin.Path,
		"Token":     token,
		"UserName":  u.FirstName,
	}

	html, err := e.mailer.ExecuteHTML("reset-password.html", data)
	if err != nil {
		fmt.Println(err)
		return err
	}

	tm := mail.Sender{
		To:      []string{u.Email},
		Subject: "Reset password",
		HTML:    html,
	}

	e.mailer.Send(&tm)

	return nil
}"
}
{
file:./api/recovery/resolve.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"github.com/ainsleyclark/verbis/api/tpl"
	"strconv"
)

const (
	// TplPrefix defines the prefix for template searching
	// such as "errors-500.html".
	TplPrefix = "error"
	// The extension of the web error file.
	VerbisErrorExtension = ".html"
	// The main layout of the web error file.
	VerbisErrorLayout = "layouts/main"
)

// resolver
//
// Looks up custom error pages from the theme. It starts
// by looking at error-`code`.extension, if the tmpl
// does not exist it will continue to look for
// error.extension. Finally it uses the main
// verbis error pages.
//
// Returns the template path, the template execute and
// if the file is a custom template.
func (r *Recover) resolveErrorPage(custom bool) (string, tpl.TemplateExecutor, bool) {
	code := strconv.Itoa(r.config.Code)
	if r.config.Code == 0 || code == "0" {
		code = "500"
	}

	path := ""
	e := r.deps.Tmpl().Prepare(tpl.Config{
		Root:      r.deps.Paths.Theme + "/" + r.deps.Theme.TemplateDir,
		Extension: r.deps.Theme.FileExtension,
	})

	// Look for `errors-404.cms` for example
	path = TplPrefix + "-" + code
	if e.Exists(path) && custom {
		return path, e, true
	}

	// Look for `error.cms` for example
	path = TplPrefix
	if e.Exists(TplPrefix) && custom {
		return path, e, true
	}

	// Return the native error page
	path, exec := r.verbisErrorResolver()
	return path, exec, false
}

// verbisErrorResolver
//
// Returns a new tpl.TemplateExecutor when no other custom
// error templates have been found.
func (r *Recover) verbisErrorResolver() (string, tpl.TemplateExecutor) {
	return "templates/error", r.deps.Tmpl().Prepare(tpl.Config{
		Root:      r.deps.Paths.Web,
		Extension: VerbisErrorExtension,
		Master:    VerbisErrorLayout,
	})
}"
}
{
file:./api/recovery/trace/stack.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package trace

import (
	"io/ioutil"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	// How many lines before and after the calling function
	// to retrieve.
	LineLimit = 60
)

// Tracer represents the functionality for obtaining a new
// stack.
type Tracer interface {
	Trace(depth int, skip int) Stack
}

// Trace implements the trace method to obtain the stack
type trace struct{}

// Return a new tracer
func New() *trace {
	return &trace{}
}

// Stack defines the slice of file lines for recovery
type Stack []*File

// Append a file to the stack trace
func (s *Stack) Append(file *File) {
	*s = append(*s, file)
}

// Prepend a file to the stack trace (useful for templates)
func (s *Stack) Prepend(file *File) {
	if len(*s) == 0 {
		*s = append(*s, file)
		return
	}
	*s = append([]*File{file}, *s...)
}

// Find a file in the stack by name.
func (s *Stack) Find(name string) *File {
	for _, v := range *s {
		if v.Name == name {
			return v
		}
	}
	return nil
}

// Stack
//
// Returns a slice of FileStack's by traversing the caller.
// using the depth and traverse arguments to loop over.
// If there was an error reading the file, or the
// runtime.Caller function failed, it will not
// be appended to the stack.
func (t *trace) Trace(depth int, skip int) Stack {
	var stack Stack

	for c := skip; c < depth; c++ {
		t, file, line, ok := runtime.Caller(c)

		if !ok {
			continue
		}

		contents, err := ioutil.ReadFile(file)
		if err != nil {
			continue
		}

		stack.Append(&File{
			File:     file,
			Line:     line,
			Name:     runtime.FuncForPC(t).Name(),
			Contents: string(contents),
			Language: Language(file),
		})
	}

	return stack
}

// language
//
// Returns the language used in the file for syntax
// highlighting.
func Language(path string) string {
	ext := filepath.Ext(path)
	switch ext {
	case ".go":
		return "go"
	case ".s":
		return "assembly"
	default:
		return "handlebars"
	}
}

// FileStack defines the stack used for the error page
type File struct {
	File     string
	Line     int
	Name     string
	Contents string
	Language string
}

// FileLine defines the error for templating it includes the
// line & content of the error file.
type FileLine struct {
	Line    int
	Content string
}

// Vendor
//
// Determines if a file is Verbis specific or vendor.
func (f *File) Vendor() bool {
	if f.Language == "handlebars" {
		return false
	}
	return !strings.Contains(f.Name, "verbis")
}

// Lines
//
// Splits the file into a array of lines by separating
// them by a new line.
func (f *File) Lines() []*FileLine {
	lines := strings.Split(f.Contents, "\n")

	diff := LineLimit / 2

	var fileLines []*FileLine
	counter := 0
	for i := f.Line - diff; i < f.Line+diff; i++ {
		if i >= 0 && i < len(lines) {
			fileLines = append(fileLines, &FileLine{
				Line:    i + 1,
				Content: lines[i],
			})
		}
		counter++
	}

	return fileLines
}"
}
{
file:./api/recovery/trace/stack_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package trace

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestStack_Append(t *testing.T) {

	tt := map[string]struct {
		stack Stack
		input *File
		want  Stack
	}{
		"Nil Length": {
			nil,
			&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			Stack{
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			},
		},
		"Multiple": {
			Stack{
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			},
			&File{File: "test", Line: 2, Name: "name", Contents: "contents"},
			Stack{
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
				&File{File: "test", Line: 2, Name: "name", Contents: "contents"},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			test.stack.Append(test.input)
			assert.Equal(t, test.want, test.stack)
		})
	}
}

func TestStack_Prepend(t *testing.T) {

	tt := map[string]struct {
		stack Stack
		input *File
		want  Stack
	}{
		"Nil Length": {
			nil,
			&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			Stack{
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			},
		},
		"Multiple": {
			Stack{
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			},
			&File{File: "test", Line: 2, Name: "name", Contents: "contents"},
			Stack{
				&File{File: "test", Line: 2, Name: "name", Contents: "contents"},
				&File{File: "test", Line: 1, Name: "name", Contents: "contents"},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			test.stack.Prepend(test.input)
			assert.Equal(t, test.want, test.stack)
		})
	}
}

func TestStack_Find(t *testing.T) {

	f := &File{File: "test", Line: 1, Name: "name", Contents: "contents"}

	tt := map[string]struct {
		stack Stack
		input string
		want  *File
	}{
		"Found": {
			Stack{f},
			"name",
			f,
		},
		"Not Found": {
			nil,
			"name",
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := test.stack.Find(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func Test_Language(t *testing.T) {

	tt := map[string]struct {
		input string
		want string
	}{
		"Default": {"test", "handlebars"},
		"Go":   {".go", "go"},
		"HTML":   {".html", "handlebars"},
		"CMS":   {".cms", "handlebars"},
		"Assembly":   {".s", "assembly"},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Language(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func Test_GetStack(t *testing.T) {

	tt := map[string]struct {
		depth    int
		traverse int
		want     int
	}{
		"Single":   {1, 0, 1},
		"Multiple": {3, 0, 3},
		"Traverse": {3, 1, 2},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := New().Trace(test.depth, test.traverse)
			assert.Equal(t, test.want, len(got))
		})
	}
}

func TestFile_Vendor(t *testing.T) {

	tt := map[string]struct {
		input File
		want  bool
	}{
		"Handlebars": {
			File{Language: "handlebars"},
			false,
		},
		"Non Vendor": {
			File{Name: "verbis/recovery"},
			false,
		},
		"Vendor": {
			File{Name: "wrongval"},
			true,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := test.input.Vendor()
			assert.Equal(t, test.want, got)
		})
	}
}

func TestFile_Lines(t *testing.T) {

	tt := map[string]struct {
		input Stack
		want  []*FileLine
	}{
		"Single": {
			Stack{
				{Contents: "test"},
			},
			[]*FileLine{
				{Line: 1, Content: "test"},
			},
		},
		"Multiple": {
			Stack{
				{Contents: "test\ntest"},
			},
			[]*FileLine{
				{Line: 1, Content: "test"},
				{Line: 2, Content: "test"},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			if len(test.input) == 0 {
				t.Error("Wrong args for input")
			}
			got := test.input[0].Lines()
			for i := 0; i < len(got); i++ {
				assert.Equal(t, test.want[i], got[i])
			}
		})
	}
}"
}
{
file:./api/recovery/util_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
)

func (t *RecoverTestSuite) Test_GetError() {

	tt := map[string]struct {
		input interface{}
		want  *errors.Error
	}{
		"Non Pointer": {
			errors.Error{Code: errors.INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("error")},
			&errors.Error{Code: errors.INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("error")},
		},
		"Pointer": {
			&errors.Error{Code: errors.INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("error")},
			&errors.Error{Code: errors.INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("error")},
		},
		"Standard Error": {
			fmt.Errorf("error"),
			&errors.Error{Code: errors.TEMPLATE, Message: "error", Operation: "", Err: fmt.Errorf("error")},
		},
		"Nil Input": {
			nil,
			&errors.Error{Code: errors.TEMPLATE, Message: "Internal Verbis error, please report", Operation: "Internal", Err: nil},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			got := getError(test.input)
			t.Equal(test.want.Operation, got.Operation)
			t.Equal(test.want.Message, got.Message)
			t.Equal(test.want.Code, got.Code)
			if test.want.Err != nil {
				t.Equal(test.want.Err.Error(), got.Err.Error())
			}
		})
	}
}

func (t *RecoverTestSuite) Test_TplLineNumber() {

	tt := map[string]struct {
		input *errors.Error
		want  int
	}{
		"Found": {
			&errors.Error{Err: fmt.Errorf(`template: templates/home:4: function "wrong" not defined`)},
			4,
		},
		"Found Second": {
			&errors.Error{Err: fmt.Errorf(`template: templates/home:10: function "wrong" not defined`)},
			10,
		},
		"Not Found": {
			&errors.Error{Err: fmt.Errorf(`template: templates/home10: function "wrong" not defined`)},
			-1,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			got := tplLineNumber(test.input)
			t.Equal(test.want, got)
		})
	}
}

func (t *RecoverTestSuite) Test_TplFileContents() {

	tt := map[string]struct {
		input string
		want  string
	}{
		"Found": {
			t.apiPath + "/test/testdata/html/partial.cms",
			"<h1>This is a partial file.</h1>",
		},
		"Not Found": {
			"wrong path",
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			got := tplFileContents(test.input)
			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/recovery/data_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	mocks "github.com/ainsleyclark/verbis/api/mocks/tpl"
	"github.com/ainsleyclark/verbis/api/recovery/trace"
	"github.com/gin-gonic/gin"
	"net/http"
	"os"
)

var (
	cookie = http.Cookie{Name: "test"}
)

func (t *RecoverTestSuite) TestRecover_GetData() {

	err := os.Setenv("APP_DEBUG", "false")
	t.NoError(err)

	want := &Data{
		Error: Error{
			Code:      errors.TEMPLATE,
			Message:   "message",
			Operation: "operation",
			Err:       "operation: error",
		},
		Request: Request{
			Url:        "http://localhost:8080/test",
			Method:     "GET",
			Headers:    map[string][]string{"Header": {"test"}},
			Query:      map[string][]string{"page": {"test"}},
			Body:       "test",
			Cookies:    []*http.Cookie{},
			IP:         "",
			DataLength: 0,
			Referer:    "",
		},
		Post:  nil,
		Debug: true,
	}

	r := Recover{
		deps:   nil,
		err:    &errors.Error{Code: errors.TEMPLATE, Message: "message", Operation: "operation", Err: fmt.Errorf("error")},
		config: Config{},
		tracer: trace.New(),
	}

	t.RequestSetup(bytes.NewBuffer([]byte("test")), nil, func(ctx *gin.Context) {
		r.config.Context = ctx
	})

	got := r.getData()
	t.Equal(want.Error, got.Error)
	t.Equal(want.Request, got.Request)
	t.Equal(want.Post, got.Post)
	t.Equal(want.Debug, got.Debug)
}

func (t *RecoverTestSuite) TestRecover_GetStackData() {

	m := &mocks.TemplateExecutor{}
	mc := &mocks.TemplateConfig{}
	mc.On("GetRoot").Return("test")
	mc.On("GetExtension").Return("cms")
	m.On("Config").Return(mc)

	tt := map[string]struct {
		input Config
		want  func(s trace.Stack) trace.Stack
	}{
		"Nil Exec": {
			Config{TplExec: nil},
			func(s trace.Stack) trace.Stack {
				return s
			},
		},
		"Nil TplFile": {
			Config{TplFile: ""},
			func(s trace.Stack) trace.Stack {
				return s
			},
		},
		"With Template": {
			Config{
				TplFile: "test",
				TplExec: m,
			},
			func(s trace.Stack) trace.Stack {
				s.Append(&trace.File{File: "tt", Line: 0, Name: "tt", Contents: "tt"})
				return s
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			r := Recover{config: test.input, tracer: trace.New()}
			stack := trace.New().Trace(StackDepth, 1)
			t.Equal(len(test.want(stack)), len(r.getStackData()))
		})
	}
}

func (t *RecoverTestSuite) TestRecover_GetErrorData() {

	tt := map[string]struct {
		input *errors.Error
		want  Error
	}{
		"Simple": {
			&errors.Error{Code: errors.TEMPLATE, Message: "message", Operation: "operation", Err: fmt.Errorf("error")},
			Error{Code: errors.TEMPLATE, Message: "message", Operation: "operation", Err: "operation: error"},
		},
		"Nil Error": {
			&errors.Error{Code: errors.TEMPLATE, Message: "message", Operation: "operation", Err: nil},
			Error{Code: errors.TEMPLATE, Message: "message", Operation: "operation", Err: "operation: <template> message"},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			r := Recover{err: test.input}
			t.Equal(test.want, r.getErrorData())
		})
	}
}

func (t *RecoverTestSuite) TestRecover_GetRequestData() {
	want := Request{
		Url:        "http://localhost:8080/test",
		Method:     "GET",
		Headers:    map[string][]string{"Header": {"test"}, "Cookie": {"test="}},
		Query:      map[string][]string{"page": {"test"}},
		Body:       "test",
		Cookies:    []*http.Cookie{&cookie},
		IP:         "",
		DataLength: -1,
		Referer:    "",
	}

	t.RequestSetup(bytes.NewBuffer([]byte("test")), &cookie, func(ctx *gin.Context) {
		r := Recover{config: Config{Context: ctx}}
		got := r.getRequestData()
		t.Equal(want, got)
	})
}

type errReader int

func (errReader) Read(p []byte) (n int, err error) {
	return 0, fmt.Errorf("test error")
}

func (t *RecoverTestSuite) TestRecover_GetRequestData_NilBody() {
	want := Request{
		Url:        "http://localhost:8080/test",
		Method:     "GET",
		Headers:    map[string][]string{"Header": {"test"}, "Cookie": {"test="}},
		Query:      map[string][]string{"page": {"test"}},
		Body:       "",
		Cookies:    []*http.Cookie{&cookie},
		IP:         "",
		DataLength: -1,
		Referer:    "",
	}

	t.RequestSetup(errReader(0), &cookie, func(ctx *gin.Context) {
		r := Recover{config: Config{Context: ctx}}
		got := r.getRequestData()
		t.Equal(want, got)
	})
}"
}
{
file:./api/recovery/recover_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/errors"
	mocks "github.com/ainsleyclark/verbis/api/mocks/tpl"
	"github.com/ainsleyclark/verbis/api/recovery/trace"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/gin-contrib/location"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/mock"
	"io"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"syscall"
)

func (t *RecoverTestSuite) TestHandler_New() {
	d := &deps.Deps{}
	h := &Handler{d}
	t.Equal(h, New(d))
}

func (t *RecoverTestSuite) TestHandler_HttpRecovery() {
	gin.SetMode(gin.TestMode)

	rr := httptest.NewRecorder()
	_, engine := gin.CreateTestContext(rr)
	engine.Use(location.Default())

	handlerMock := &mocks.TemplateHandler{}
	templateMock := &mocks.TemplateExecutor{}
	handlerMock.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(templateMock)
	templateMock.On("Exists", "error-500").Return(true)
	templateMock.On("Execute", &bytes.Buffer{}, "error-500", mock.Anything).Run(func(args mock.Arguments) {
		arg := args.Get(0).(io.Writer)
		_, err := arg.Write([]byte("test"))
		t.NoError(err)
	}).Return(nil)

	t.deps.SetTmpl(handlerMock)
	engine.Use(New(t.deps).HttpRecovery())

	engine.GET("/test", func(ctx *gin.Context) {
		panic(&errors.Error{Message: "test"})
	})

	request, err := http.NewRequest("GET", "/test", &bytes.Buffer{})
	t.NoError(err)

	engine.ServeHTTP(rr, request)

	t.Equal("test", rr.Body.String())
	t.Equal(500, rr.Code)
}

func (t *RecoverTestSuite) TestHandler_HttpRecovery_Panics() {

	expectMsgs := map[syscall.Errno]string{
		syscall.EPIPE:      "broken pipe",
		syscall.ECONNRESET: "connection reset by peer",
	}

	for errno, expectMsg := range expectMsgs {
		t.Run(expectMsg, func() {
			t.NotPanics(func() {
				gin.SetMode(gin.TestMode)

				rr := httptest.NewRecorder()
				_, engine := gin.CreateTestContext(rr)
				engine.Use(New(t.deps).HttpRecovery())

				engine.GET("/test", func(ctx *gin.Context) {
					ctx.Header("X-Test", "Value")
					ctx.Status(204)
					e := &net.OpError{Err: &os.SyscallError{Err: errno}}
					panic(e)
				})

				request, err := http.NewRequest("GET", "/test", nil)
				t.NoError(err)

				engine.ServeHTTP(rr, request)

				t.Equal("", rr.Body.String())
			})
		})
	}
}

func (t *RecoverTestSuite) TestRecover_RecoverWrapper() {

	var data = func() *Data {
		return &Data{}
	}

	var nilBytes []byte

	tt := map[string]struct {
		input    bool
		resolver Resolver
		want     []byte
	}{
		"Theme Error Page": {
			true,
			func(custom bool) (string, tpl.TemplateExecutor, bool) {
				m := mocks.TemplateExecutor{}
				m.On("Execute", &bytes.Buffer{}, "root", mock.Anything).Run(func(args mock.Arguments) {
					arg := args.Get(0).(io.Writer)
					_, err := arg.Write([]byte("test"))
					t.NoError(err)
				}).Return(nil)
				return "root", &m, true
			},
			[]byte("test"),
		},
		//"Error Executing Theme Error Page": {
		//	true,
		//	func(custom bool) (string, tpl.TemplateExecutor, bool) {
		//		m := mocks.TemplateExecutor{}
		//		m.On("Execute", &bytes.Buffer{}, "root", data()).Return(fmt.Errorf("error")).Once()
		//		m.On("Execute", &bytes.Buffer{}, "root", data()).Run(func(args mock.Arguments) {
		//			arg := args.Get(0).(io.Writer)
		//			_, err := arg.Write([]byte("test"))
		//			t.NoError(err)
		//		}).Return(fmt.Errorf("error")).Once()
		//		return "root", &m, true
		//	},
		//	[]byte("test"),
		//},
		"Verbis Error": {
			false,
			func(custom bool) (string, tpl.TemplateExecutor, bool) {
				m := mocks.TemplateExecutor{}
				m.On("Execute", &bytes.Buffer{}, "root", data()).Return(fmt.Errorf("error"))
				m.On("Execute", &bytes.Buffer{}, "root", data())
				return "root", &m, false
			},
			nilBytes,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			r := &Recover{
				deps:   t.deps,
				config: Config{},
				tracer: trace.New(),
			}
			r.resolve = test.resolver
			r.data = func() *Data {
				return &Data{}
			}

			var tpl []byte
			r.recoverWrapper(test.input, func(b []byte, err *errors.Error) {
				tpl = b
			})
			t.Equal(test.want, tpl)
		})
	}
}"
}
{
file:./api/recovery/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"
)

// getError
//
// Converts an interface{} to a Verbis internal error
// ready for processing and to return to the recovery
// page.
func getError(e interface{}) *errors.Error {
	switch v := e.(type) {
	case errors.Error:
		return &v
	case *errors.Error:
		return v
	case error:
		return &errors.Error{Code: errors.TEMPLATE, Message: v.Error(), Operation: "", Err: v}
	default:
		return &errors.Error{Code: errors.TEMPLATE, Message: "Internal Verbis error, please report", Operation: "Internal", Err: fmt.Errorf("%v", e)}
	}
}

// tplLineNumber
//
// Returns the line number of the template that broke. If
// the line number could not be retrieved using a regex
// find, -1 will be returned.
func tplLineNumber(err *errors.Error) int {
	reg := regexp.MustCompile(`:\d+:`)
	lc := string(reg.Find([]byte(err.Error())))
	line := strings.ReplaceAll(lc, ":", "")

	i, ok := strconv.Atoi(line)
	if ok != nil {
		return -1
	}
	return i
}

// tplFileContents
//
// Gets the file contents of the errored template.
// Logs errors.NOTFOUND if the path could not be found.
func tplFileContents(path string) string {
	const op = "Recovery.tplFileContents"

	contents, err := ioutil.ReadFile(path)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.NOTFOUND, Message: "Could not get the file contents with the path: " + path, Operation: op, Err: err},
		})
		return ""
	}

	return string(contents)
}"
}
{
file:./api/recovery/resolve_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	mocks "github.com/ainsleyclark/verbis/api/mocks/tpl"
	"github.com/ainsleyclark/verbis/api/tpl"
)

func (t *RecoverTestSuite) TestRecover_Resolver() {

	tt := map[string]struct {
		input  bool
		code   int
		path   string
		mock   func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string)
		custom bool
	}{
		"Default Code": {
			true,
			0,
			"error-500",
			func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string) {
				mh.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(m)
				m.On("Exists", path).Return(true)
			},
			true,
		},
		"Custom error-404.cms": {
			true,
			404,
			"error-404",
			func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string) {
				mh.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(m)
				m.On("Exists", path).Return(true)
			},
			true,
		},
		"Custom error-500.cms": {
			true,
			500,
			"error-500",
			func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string) {
				mh.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(m)
				m.On("Exists", path).Return(true)
			},
			true,
		},
		"Custom error.cms": {
			true,
			500,
			"error",
			func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string) {
				mh.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(m)
				m.On("Exists", "error-500").Return(false).Once()
				m.On("Exists", path).Return(true).Once()
			},
			true,
		},
		"Verbis Error Exec": {
			true,
			500,
			"templates/error",
			func(mh *mocks.TemplateHandler, m *mocks.TemplateExecutor, path string) {
				fe := &mocks.TemplateExecutor{}
				fe.On("Exists", "error-500").Return(false).Once()
				fe.On("Exists", "error").Return(false).Once()
				mh.On("Prepare", tpl.Config{Root: "theme/template", Extension: "cms"}).Return(fe).Once()
				mh.On("Prepare", tpl.Config{Root: t.deps.Paths.Web, Extension: VerbisErrorExtension, Master: VerbisErrorLayout}).Return(m).Once()
			},
			false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			handlerMock := &mocks.TemplateHandler{}
			templateMock := &mocks.TemplateExecutor{}
			test.mock(handlerMock, templateMock, test.path)

			t.deps.SetTmpl(handlerMock)

			r := Recover{deps: t.deps, config: Config{Code: test.code}}
			path, exec, custom := r.resolveErrorPage(test.custom)

			t.Equal(test.custom, custom)
			t.Equal(templateMock, exec)
			t.Equal(test.path, path)
		})
	}
}"
}
{
file:./api/recovery/data.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/environment"
	"github.com/ainsleyclark/verbis/api/recovery/trace"
	"github.com/gin-contrib/location"
	"io/ioutil"
	"net/http"
)

type (
	// Data represents the main struct for sending back data to the
	// template for recovery.
	Data struct {
		Error      Error
		StatusCode int
		Request    Request
		Post       *domain.PostData
		Stack      trace.Stack
		Context    Context
		Debug      bool
	}
	// Error represents a errors.Error in friendly form (strings) to
	// for the recovery template.
	Error struct {
		Code      string
		Message   string
		Operation string
		Err       string
	}
	// Request represents the data obtained from the context with
	// detailed information about the http request made.
	Request struct {
		Url        string
		Method     string
		IP         string
		Referer    string
		DataLength int
		Body       string
		Headers    map[string][]string
		Query      map[string][]string
		Cookies    []*http.Cookie
	}
	// Context represents general information about Verbis to
	// help with debugging.
	Context struct {
		Version string
		Site    domain.Site
		Options map[string]interface{}
	}
)

const (
	// The amount of files in the stack to be retrieved.
	StackDepth = 200
	// How many files to move up in the runtime.Caller
	// before obtaining the stack.
	StackSkip = 2
)

// getData
//
// Retrieves all the necessary template data to show
// the recovery page. If a template executor has
// been set, the template file stack will be
// retrieved,
func (r *Recover) getData() *Data {
	return &Data{
		Error:      r.getErrorData(),
		StatusCode: r.config.Code,
		Request:    r.getRequestData(),
		Post:       r.config.Post,
		Stack:      r.getStackData(),
		Context: r.getContextData(),
		Debug:      environment.IsDebug(),
	}
}

// getStackData
//
// Check if the template exec has been set, if it has
// retrieve the file stack for the template. and
// prepend it to the stack.
func (r *Recover) getStackData() trace.Stack {
	stack := r.tracer.Trace(StackDepth, StackSkip)
	if r.config.TplExec != nil && r.config.TplFile != "" {
		root := r.config.TplExec.Config().GetRoot()
		ext := r.config.TplExec.Config().GetExtension()
		path := root + "/" + r.config.TplFile + ext

		stack.Prepend(&trace.File{
			File:     path,
			Line:     tplLineNumber(r.err),
			Name:     r.config.TplFile,
			Contents: tplFileContents(path),
			Language: "handlebars",
		})
	}
	return stack
}

// getErrorData
//
// Returns error friendly Error data for the template.
func (r *Recover) getErrorData() Error {
	return Error{
		Code:      r.err.Code,
		Message:   r.err.Message,
		Operation: r.err.Operation,
		Err:       r.err.Error(),
	}
}

// getRequestData
//
// Returns error friendly Request data for the template.
func (r *Recover) getRequestData() Request {
	ctx := r.config.Context

	// Retrieve the request body contents.
	body, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		body = nil
	}

	return Request{
		Url:        location.Get(ctx).String() + ctx.Request.URL.Path,
		Method:     ctx.Request.Method,
		IP:         ctx.ClientIP(),
		Referer:    ctx.Request.Referer(),
		DataLength: ctx.Writer.Size(),
		Body:       string(body),
		Headers:    ctx.Request.Header,
		Query:      ctx.Request.URL.Query(),
		Cookies:    ctx.Request.Cookies(),
	}
}

// getContextData
//
// Returns error friendly request Context for the template.
func (r *Recover) getContextData() Context {
	opts, err := r.deps.Store.Options.Get()
	if err != nil {
		opts = nil
	}
	return Context{
		Version: api.App.Version,
		Site:   r.deps.Site,
		Options: opts,
	}
}"
}
{
file:./api/recovery/recover.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/recovery/trace"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/gin-gonic/gin"
	"net"
	"os"
	"strings"
)

type Handler struct {
	deps *deps.Deps
}

func New(d *deps.Deps) *Handler {
	return &Handler{deps: d}
}

type Recovery interface {
	Recover(cfg Config) []byte
	HttpRecovery() gin.HandlerFunc
}

// Recover defines
type Recover struct {
	deps    *deps.Deps
	err     *errors.Error
	config  Config
	resolve Resolver
	data    TplData
	tracer  trace.Tracer
}

type Resolver func(custom bool) (string, tpl.TemplateExecutor, bool)

type TplData func() *Data

// Config defines
type Config struct {
	Code    int
	Context *gin.Context
	Error   interface{}
	TplFile string
	TplExec tpl.TemplateExecutor
	Post    *domain.PostData
}

func (h *Handler) newRecover(cfg Config) *Recover {
	r := &Recover{
		deps:   h.deps,
		err:    getError(cfg.Error),
		config: cfg,
		tracer: trace.New(),
	}
	r.resolve = r.resolveErrorPage
	r.data = r.getData
	return r
}

// Recover
//
//
func (h *Handler) Recover(cfg Config) []byte {
	r := h.newRecover(cfg)
	var tpl []byte
	custom := true

	r.recoverWrapper(custom, func(b []byte, err *errors.Error) {
		if err != nil {
			custom = false
		}
		tpl = b
	})

	//
	if !custom {
		r.recoverWrapper(custom, func(b []byte, err *errors.Error) {
			if err != nil {
				fmt.Println(err)
			}
			tpl = b
		})
	}

	return tpl
}

// HttpRecovery
//
//
func (h *Handler) HttpRecovery() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				// Check for a broken connection, as it is not really a
				// condition that warrants a panic stack trace.
				var brokenPipe bool
				if ne, ok := err.(*net.OpError); ok {
					if se, ok := ne.Err.(*os.SyscallError); ok {
						if strings.Contains(strings.ToLower(se.Error()), "broken pipe") || strings.Contains(strings.ToLower(se.Error()), "connection reset by peer") {
							brokenPipe = true
						}
					}
				}
				// If the connection is dead, we can't write a status to it.
				// Otherwise we will send the recover data back.
				if !brokenPipe {
					b := h.Recover(Config{
						Context: ctx,
						Error:   err,
					})
					ctx.Data(500, "text/html", b)
					return
				}
			}
		}()
		ctx.Next()
	}
}

// recoverWrapper
//
// Obtains the template executor from the resolver, this could
// be a user defined error page, or an internal Verbis page
// dependant on the pages defined in the theme. The
// error page is executed and returned as bytes.
//
// Logs errors.INTERNAL if the internal Verbis error page
// failed to execute.
// Sets the config error errors.TEMPLATE if the user defined
// error page failed to execute.
func (r *Recover) recoverWrapper(useTheme bool, fn func(b []byte, err *errors.Error)) {
	const op = "Recovery.Recover"

	path, exec, custom := r.resolve(useTheme)

	var b bytes.Buffer
	_, err := exec.Execute(&b, path, r.data())

	// Theme error template failed, use the internal error pages
	if err != nil && custom {
		r.config.TplFile = path
		r.config.TplExec = exec
		fn(nil, &errors.Error{Code: errors.TEMPLATE, Message: "Unable to execute template with the name: " + path, Operation: op, Err: err})
	}

	// Verbis error template failed, exit
	if err != nil && !custom {
		fn(nil, &errors.Error{Code: errors.INTERNAL, Message: "Unable to execute Verbis error template", Operation: op, Err: err})
	}

	fn(b.Bytes(), nil)
}"
}
{
file:./api/recovery/suite_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package recovery

import (
	"bytes"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-contrib/location"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/suite"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
)

type RecoverTestSuite struct {
	suite.Suite
	deps      *deps.Deps
	logWriter bytes.Buffer
	apiPath   string
}

type noStringer struct{}

func TestFields(t *testing.T) {
	suite.Run(t, new(RecoverTestSuite))
}

func (t *RecoverTestSuite) BeforeTest(suiteName, testName string) {
	b := bytes.Buffer{}
	t.logWriter = b
	log.SetOutput(&t.logWriter)
	t.SetPath()
	t.SetDeps()
}

func (t *RecoverTestSuite) SetPath() {
	wd, err := os.Getwd()
	t.NoError(err)
	t.apiPath = filepath.Join(filepath.Dir(wd))
}

func (t *RecoverTestSuite) SetDeps() {
	t.deps = &deps.Deps{
		Paths: deps.Paths{
			Theme: "theme",
		},
		Theme: &domain.ThemeConfig{
			FileExtension: "cms",
			TemplateDir:   "template",
		},
	}
}

func (t *RecoverTestSuite) Reset() {
	t.logWriter.Reset()
}

func (t *RecoverTestSuite) RequestSetup(body io.Reader, cookie *http.Cookie, fn func(ctx *gin.Context)) {
	gin.SetMode(gin.TestMode)

	rr := httptest.NewRecorder()
	_, engine := gin.CreateTestContext(rr)
	engine.Use(location.Default())

	engine.GET("/test", func(g *gin.Context) {
		fn(g)
		return
	})

	request, err := http.NewRequest("GET", "/test?page=test", body)
	t.NoError(err)

	request.Header.Set("header", "test")

	if cookie != nil {
		request.AddCookie(cookie)
	}

	engine.ServeHTTP(rr, request)
}"
}
{
file:./api/tpl/tplimpl/render.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tplimpl

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/partial"
	"html/template"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// FileHandler file handler interface
type fileHandler func(config tpl.TemplateConfig, template string) (content string, err error)

// DefaultFileHandler
//
// Accepts a template path and looks up the page template by the
// template path and file extension set in the engine.
// Returns
func DefaultFileHandler() fileHandler {
	const op = "TemplateEngine.defaultFileHandler"

	return func(config tpl.TemplateConfig, template string) (content string, err error) {
		// Get the absolute path of the root template
		path, err := filepath.Abs(config.GetRoot() + string(os.PathSeparator) + template + config.GetExtension())
		if err != nil {
			return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("No page template exists with the path:%v", path), Operation: op, Err: err}
		}

		data, err := ioutil.ReadFile(path)
		if err != nil {
			return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Render read name:%v, path:%v", template, path), Operation: op, Err: err}
		}

		return string(data), nil
	}
}

// executeRender
//
//
func (e *Execute) executeRender(out io.Writer, name string, data interface{}) (string, error) {
	useMaster := true
	if filepath.Ext(name) == e.config.GetExtension() {
		useMaster = false
		name = strings.TrimSuffix(name, e.config.GetExtension())
	}
	return e.executeTemplate(out, name, data, useMaster)
}

// executeTemplate
//
//
func (e *Execute) executeTemplate(out io.Writer, name string, data interface{}, useMaster bool) (string, error) {
	const op = "TemplateEngine.Execute"

	var tpl *template.Template
	var err error
	var ok bool

	e.tplMutex.RLock()
	tpl, ok = e.tplMap[name]
	e.tplMutex.RUnlock()

	exeName := name
	if useMaster && e.config.GetMaster() != "" {
		exeName = e.config.GetMaster()
	}

	pfn := partial.Partial(e.funcMap, e)
	e.funcMap["partial"] = pfn
	e.funcMap["include"] = pfn

	if !ok {
		tplList := make([]string, 0)
		if useMaster {
			if e.config.GetMaster() != "" {
				tplList = append(tplList, e.config.GetMaster())
			}
		}
		tplList = append(tplList, name)

		// Loop through each template and test the full path
		tpl = template.New(name).Funcs(e.funcMap).Delims(DelimitersLeft, DelimitersRight)
		for _, v := range tplList {
			var data string
			data, err = e.fileHandler(e.config, v)
			if err != nil {
				return v, err
			}
			var tmpl *template.Template
			if v == name {
				tmpl = tpl
			} else {
				tmpl = tpl.New(v)
			}
			_, err = tmpl.Parse(data)
			if err != nil {
				return v, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to parse template with the name: %s", v), Operation: op, Err: err}
			}
		}
		e.tplMutex.Lock()
		e.tplMap[name] = tpl
		e.tplMutex.Unlock()
	}

	// Display the content to the screen
	err = tpl.Funcs(e.funcMap).ExecuteTemplate(out, exeName, data)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: "Template engine execute template error", Operation: op, Err: err}
	}

	return "", nil
}"
}
{
file:./api/tpl/tplimpl/funcs_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tplimpl

//func Setup(t *testing.T) *Funcs {
//	gin.SetMode(gin.TestMode)
//
//	rr := httptest.NewRecorder()
//	ctx, engine := gin.CreateTestContext(rr)
//	ctx.Request, _ = http.NewRequest("GET", "/page", nil)
//	engine.Use(location.Default())
//
//	engine.GET("/page", func(g *gin.Context) {
//		ctx = g
//		return
//	})
//
//	req, err := http.NewRequest("GET", "http://verbiscms.com/page?page=2&foo=bar", nil)
//	assert.NoError(t, err)
//	engine.ServeHTTP(rr, req)
//
//	os.Setenv("foo", "bar")
//
//	f := Funcs{
//		&deps.Deps{
//			Options: domain.Options{
//				GeneralLocale: "en-gb",
//			},
//		},
//		&internal.TemplateDeps{
//			Context: ctx,
//			Post: &domain.PostData{
//				Post: domain.Post{
//					Id:           1,
//					Slug:         "/page",
//					Title:        "My Verbis Page",
//					Status:       "published",
//					Resource:     nil,
//					PageTemplate: "single",
//					PageLayout:   "main",
//					UserId:       1,
//				},
//				Fields: []domain.PostField{
//					{PostId: 1, Type: "text", Name: "text", Key: "", OriginalValue: "Hello World!"},
//				},
//			},
//		},
//	}
//
//	return &f
//}
//
//// Test all internal template function mappings
//func TestFuncs(t *testing.T) {
//	f := Setup(t)
//
//	v := variables.New(&deps.Deps{}, f.TemplateDeps.Context, f.TemplateDeps.Post)
//
//	for _, ns := range f.getNamespaces() {
//		for _, mm := range ns.MethodMappings {
//			for _, e := range mm.Examples {
//				file, err := template.New("test").Funcs(f.FuncMap()).Parse(e[0])
//				if err != nil {
//					t.Errorf("test failed for %s: %s", mm.Name, err.Error())
//					continue
//				}
//
//				var tpl bytes.Buffer
//				err = file.Execute(&tpl, v.Get())
//				if err != nil {
//					t.Error(err)
//				}
//
//				assert.Equal(t, e[1], html.UnescapeString(tpl.String()))
//			}
//		}
//	}
//}
//
//func TestFuncs_FuncMap(t *testing.T) {
//
//	tt := map[string]struct {
//		namespaces internal.FuncNamespaces
//		want       template.FuncMap
//		panics     bool
//	}{
//		"Success": {
//			internal.FuncNamespaces{
//				&internal.FuncsNamespace{Name: "namespace", MethodMappings: map[string]internal.FuncMethodMapping{
//					"func": {
//						Method: nil,
//						Name:   "func",
//					},
//				}},
//			},
//			template.FuncMap{"func": nil},
//			false,
//		},
//		"Duplicate Func": {
//			internal.FuncNamespaces{
//				&internal.FuncsNamespace{Name: "namespace", MethodMappings: map[string]internal.FuncMethodMapping{
//					"test":    {Method: nil, Name: "replace"},
//					"replace": {Method: nil, Name: "replace"},
//				}},
//			},
//			nil,
//			true,
//		},
//		"Duplicate Alias": {
//			internal.FuncNamespaces{
//				&internal.FuncsNamespace{Name: "namespace", MethodMappings: map[string]internal.FuncMethodMapping{
//					"test": {Method: nil, Name: "test", Aliases: []string{"test"}},
//				}},
//			},
//			template.FuncMap{},
//			true,
//		},
//	}
//
//	for name, test := range tt {
//		t.Run(name, func(t *testing.T) {
//			f := &Funcs{}
//
//			if test.panics {
//				assert.Panics(t, func() {
//					f.getFuncs(test.namespaces)
//				})
//				return
//			}
//
//			assert.Equal(t, test.want, f.getFuncs(test.namespaces))
//		})
//	}
//}"
}
{
file:./api/tpl/tplimpl/template_test.go
contents:
"package tplimpl

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNew(t *testing.T) {
	d := &deps.Deps{}
	tm := TemplateManager{deps: d}
	assert.Equal(t, tm, *New(d))
}"
}
{
file:./api/tpl/tplimpl/execute.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tplimpl

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/ainsleyclark/verbis/api/tpl/variables"
	"github.com/gin-gonic/gin"
	"html/template"
	"io"
	"sync"
)

// Prepare
//
// Satisfies the tpl.TemplateHandler interface by accepting
// a tpl.Config data and set's up the template so it's
// ready for execution.
func (t *TemplateManager) Prepare(c tpl.TemplateConfig) tpl.TemplateExecutor {
	return &Execute{
		t,
		c,
		make(map[string]*template.Template),
		sync.RWMutex{},
		DefaultFileHandler(),
		template.FuncMap{},
	}
}

// Execute
//
// Satisfies the tpl.TemplateExecutor interface by executing
// a template with a io.Writer, the name of the template
// and any data to be passed. As this function is not
// attached to any context, the generic function map
// is used.
func (e *Execute) Execute(w io.Writer, name string, data interface{}) (string, error) {
	e.funcMap = e.GenericFuncMap()
	return e.executeRender(w, name, data)
}

// ExecutePost
//
// Satisfies the tpl.TemplateExecutor interface by executing
// a template with a io.Writer, the name of the template
// the context and the domain.PostData. Data is not
// needed to be  passed as data is obtained from
// the variables package.
func (e *Execute) ExecutePost(w io.Writer, name string, ctx *gin.Context, post *domain.PostData) (string, error) {
	data := e.Data(ctx, post)
	e.funcMap = e.FuncMap(ctx, post, e.config)
	return e.executeRender(w, name, data)
}

// Exists
//
// Satisfies the tpl.TemplateExecutor interface by determining
// if a template file exists with the given name.
func (e *Execute) Exists(template string) bool {
	_, err := e.fileHandler(e.config, template)
	if err != nil {
		return false
	}
	return true
}

// Config
//
// Satisfies the tpl.TemplateExecutor interface by returning
// the Execute configuration to obtain the root, extension
// and master layout.
func (e *Execute) Config() tpl.TemplateConfig {
	return e.config
}

// Executor
//
// Satisfies the tpl.TemplateExecutor interface by returning
// itself for use with recovery
func (e *Execute) Executor() tpl.TemplateExecutor {
	return e
}

// Data
//
// Satisfies the tpl.TemplateDataGetter interface by returning
// data for the front end that relies on context and post
// data.
func (t *TemplateManager) Data(ctx *gin.Context, post *domain.PostData) interface{} {
	return variables.Data(t.deps, ctx, post)
}

// FuncMap
//
// Satisfies the tpl.TemplateFuncGetter interface by returning
// functions that relies on context and post data such as
// `Meta` and `Url`. Generic functions are also included.
func (t *TemplateManager) FuncMap(ctx *gin.Context, post *domain.PostData, cfg tpl.TemplateConfig) template.FuncMap {
	td := &internal.TemplateDeps{
		Context: ctx,
		Post:    post,
		Cfg:     cfg,
	}
	funcs := t.getFuncs(t.getNamespaces(td))
	return funcs
}

// GenericFuncMap
//
// Satisfies the tpl.TemplateFuncGetter interface by returning
// functions that do not rely on any data that is processed
// at runtime. These functions are loaded on initialisation
// and stored in memory.
func (t *TemplateManager) GenericFuncMap() template.FuncMap {
	return t.getFuncs(t.getGenericNamespaces())
}"
}
{
file:./api/tpl/tplimpl/template.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tplimpl

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl"
	"html/template"
	"sync"
)

const (
	// Delimiter left for the template
	DelimitersLeft = "{{"
	// Delimiter right for the template
	DelimitersRight = "}}"
)

// TemplateManager defines the service for executing and
// parsing Verbis templates. It's responsible for
// obtaining a template.FuncMap and Data to be
// used within the template.
type TemplateManager struct {
	deps *deps.Deps
}

// Creates a new TemplateManager
func New(d *deps.Deps) *TemplateManager {
	return &TemplateManager{
		deps: d,
	}
}

// Execute defines the data for rendering a template
// contains
type Execute struct {
	*TemplateManager
	config      tpl.TemplateConfig
	tplMap      map[string]*template.Template
	tplMutex    sync.RWMutex
	fileHandler fileHandler
	funcMap     template.FuncMap
}"
}
{
file:./api/tpl/tplimpl/funcs.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tplimpl

import (
	// Context/Post specific functions
	"github.com/ainsleyclark/verbis/api/tpl/funcs/attributes"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/auth"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/fields"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/meta"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/url"
	"github.com/ainsleyclark/verbis/api/tpl/internal"

	// Generic functions
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/cast"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/categories"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/date"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/debug"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/dict"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/math"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/media"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/os"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/paths"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/posts"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/rand"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/reflect"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/safe"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/slice"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/strings"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/users"
	_ "github.com/ainsleyclark/verbis/api/tpl/funcs/util"

	// Package
	"html/template"
)

// getFuncs
//
// Loops over the internal.FuncNamespaces passed and returns
// a new template.FuncMap. If duplicates are found for
// either the main method name or an alias, the func
// will panic.
func (t *TemplateManager) getFuncs(fs internal.FuncNamespaces) template.FuncMap {
	funcMap := template.FuncMap{}

	for _, ns := range fs {
		for _, mm := range ns.MethodMappings {
			if _, exists := funcMap[mm.Name]; exists {
				panic(ns.Name + " is a duplicate template func")
			}
			funcMap[mm.Name] = mm.Method
			for _, alias := range mm.Aliases {
				if _, exists := funcMap[alias]; exists {
					panic(alias + " is a duplicate template func")
				}
				funcMap[alias] = mm.Method
			}
		}
	}

	return funcMap
}

// getNamespaces
//
// Merges the generic and frontend namespaces and returns
// a slice of namespaces, both generic and frontend.
func (t *TemplateManager) getNamespaces(td *internal.TemplateDeps) internal.FuncNamespaces {
	ns := t.getGenericNamespaces()
	ns = append(ns, t.getFrontendNamespaces(td)...)
	return ns
}

// getGenericNamespaces
//
// Returns all generic namespaces, ones that are not
// dependant on a post or context.
func (t *TemplateManager) getGenericNamespaces() internal.FuncNamespaces {
	var fs internal.FuncNamespaces
	for _, nsf := range internal.GenericNamespaceRegistry {
		fs = append(fs, nsf(t.deps))
	}
	return fs
}

// getFrontendNamespaces
//
// Returns all frontend namespaces, ones that are
// dependant on a post or context.
func (t *TemplateManager) getFrontendNamespaces(td *internal.TemplateDeps) internal.FuncNamespaces {
	return internal.FuncNamespaces{
		attributes.Init(t.deps, td),
		auth.Init(t.deps, td),
		fields.Init(t.deps, td),
		meta.Init(t.deps, td),
		url.Init(t.deps, td),
	}
}"
}
{
file:./api/tpl/tplimpl/render_test.go
contents:
"package tplimpl

import (
	"fmt"
	mocks "github.com/ainsleyclark/verbis/api/mocks/tpl"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestDefaultFileHandler(t *testing.T) {

	tt := map[string]struct {
		mock func(config *mocks.TemplateConfig)
		template string
		want interface{}
	}{
		"Valid": {
			func(config *mocks.TemplateConfig) {
				config.On("GetRoot").Return("wrongval")
				config.On("GetExtension").Return("wrongval")
			},
			"",
			"dd",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			m := &mocks.TemplateConfig{}
			test.mock(m)
			fn := DefaultFileHandler()
			got, err := fn(m, test.template)

			if err != nil {
				fmt.Print(err)
				assert.Contains(t, err.Error(), test.want)
				return
			}

			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/internal/funcs_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package internal

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"reflect"
	"runtime"
	"testing"
)

func TestAddFuncsNamespace(t *testing.T) {
	fns := []func(d *deps.Deps) *FuncsNamespace{
		func(d *deps.Deps) *FuncsNamespace {
			return &FuncsNamespace{
				Name: "test",
			}
		},
	}
	AddFuncsNamespace(fns[0])
	fnc1 := runtime.FuncForPC(reflect.ValueOf(fns[0]).Pointer()).Name()
	fnc2 := runtime.FuncForPC(reflect.ValueOf(GenericNamespaceRegistry[0]).Pointer()).Name()
	assert.Equal(t, fnc1, fnc2)
	GenericNamespaceRegistry = nil
}

func TestFuncsNamespace_AddMethodMapping(t *testing.T) {

	fns := FuncsNamespace{Name: "test"}

	tt := map[string]struct {
		name     string
		aliases  []string
		examples [][2]string
		want     interface{}
		panic    bool
	}{
		"Success": {
			"test",
			nil,
			nil,
			FuncMethodMapping{Name: "test"},
			false,
		},
		"Empty Example": {
			"test",
			nil,
			[][2]string{{""}, {""}},
			FuncMethodMapping{Name: "test"},
			true,
		},
		"Empty Alias": {
			"test",
			[]string{""},
			nil,
			FuncMethodMapping{Name: "test"},
			true,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			if test.panic {
				assert.Panics(t, func() {
					fns.AddMethodMapping(nil, test.name, test.aliases, test.examples)
				})
				return
			}

			fns.AddMethodMapping(nil, test.name, test.aliases, test.examples)
			got := fns.MethodMappings[test.name]
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/internal/funcs.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package internal

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/gin-gonic/gin"
)

// GenericNamespaceRegistry represents the slice of generic
// functions that provide namespaces.
var GenericNamespaceRegistry []func(d *deps.Deps) *FuncsNamespace

// GenericNamespaceRegistry represents the slice of generic
// functions that provide namespaces.
type FuncNamespaces []*FuncsNamespace

// TemplateDeps represents the data to be passed to templates
// that rely on either context or domain.PostData such as
// "url", "fields" or "meta".
type TemplateDeps struct {
	// The context to be used used for obtaining URL's & query parameters etc...
	Context *gin.Context
	// The post to be used for rendering meta information for the page
	Post *domain.PostData
	// The config of the executor used in partials to obtain the root path.
	Cfg tpl.TemplateConfig
}

// FuncsNamespace represents a template function namespace.
type FuncsNamespace struct {
	// The name of the namespace, for example "math" or "slice"
	Name string
	// The method receiver of the namespace
	Context func(v ...interface{}) interface{}
	// Additional information about the namespace such as aliases and examples.
	MethodMappings map[string]FuncMethodMapping
}

// FuncMethodMapping represents individual methods found in
// each template namespaces.
type FuncMethodMapping struct {
	Method   interface{}
	Name     string
	Aliases  []string
	Examples [][2]string
}

// AddFuncsNamespace
//
// Appends a FuncsNamespace to the registry
func AddFuncsNamespace(ns func(d *deps.Deps) *FuncsNamespace) {
	GenericNamespaceRegistry = append(GenericNamespaceRegistry, ns)
}

// AddMethodMapping
//
// Adds a FuncsNamespace to the GenericNamespaceRegistry
// If any duplicates are found in the registry a panic
// will occur.
func (t *FuncsNamespace) AddMethodMapping(m interface{}, name string, aliases []string, examples [][2]string) {
	if t.MethodMappings == nil {
		t.MethodMappings = make(map[string]FuncMethodMapping)
	}

	for _, e := range examples {
		if e[0] == "" {
			panic(t.Name + ": Empty example for " + name)
		}
	}

	for _, a := range aliases {
		if a == "" {
			panic(t.Name + ": Empty alias for " + name)
		}
	}

	t.MethodMappings[name] = FuncMethodMapping{
		Method:   m,
		Name:     name,
		Aliases:  aliases,
		Examples: examples,
	}
}"
}
{
file:./api/tpl/templates_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tpl

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestConfig_GetRoot(t *testing.T) {
	c := Config{Root: "test"}
	got := c.GetRoot()
	assert.Equal(t, "test", got)
}

func TestConfig_GetExtension(t *testing.T) {
	c := Config{Extension: "test"}
	got := c.GetExtension()
	assert.Equal(t, "test", got)
}

func TestConfig_GetMaster(t *testing.T) {
	c := Config{Master: "test"}
	got := c.GetMaster()
	assert.Equal(t, "test", got)
}"
}
{
file:./api/tpl/variables/variables.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package variables

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-gonic/gin"
)

type (
	// TemplateData represents the main datta to be returned
	// in templates.
	TemplateData struct {
		Site    domain.Site
		Theme   domain.ThemeConfig
		Post    domain.PostData
		Options Options
	}
	// Options represents Verbis options to be returned
	// in templates.
	Options struct {
		Social  Social
		Contact Contact
	}
	// Social represents social details to be returned
	// in templates.
	Social struct {
		Facebook  string
		Twitter   string
		Youtube   string
		LinkedIn  string
		Instagram string
		Pintrest  string
	}
	// Contact represents contact details of the site
	// to be returned in templates.
	Contact struct {
		Email     string
		Telephone string
		Address   string
	}
)

// Data returns the TemplateData for the front end which are
// bound to posts and the context.
func Data(d *deps.Deps, ctx *gin.Context, post *domain.PostData) interface{} {
	return TemplateData{
		Site:  d.Site,
		Theme: *d.Theme,
		Post:  *post,
		Options: Options{
			Social: Social{
				Facebook:  d.Options.SocialFacebook,
				Twitter:   d.Options.SocialTwitter,
				Youtube:   d.Options.SocialYoutube,
				LinkedIn:  d.Options.SocialLinkedIn,
				Instagram: d.Options.SocialInstagram,
				Pintrest:  d.Options.SocialPinterest,
			},
			Contact: Contact{
				Email:     d.Options.ContactEmail,
				Telephone: d.Options.ContactTelephone,
				Address:   d.Options.ContactAddress,
			},
		},
	}
}"
}
{
file:./api/tpl/variables/variables_test.go
contents:
"package variables

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestData(t *testing.T) {
	td := TemplateData{
		Site:    domain.Site{},
		Theme:   domain.ThemeConfig{},
		Post:    domain.PostData{},
		Options: Options{},
	}

	got := Data(&deps.Deps{
		Site: domain.Site{},
		Theme: &domain.ThemeConfig{},
		Options: &domain.Options{},
	}, &gin.Context{}, &domain.PostData{})

	assert.Equal(t, td, got)
}"
}
{
file:./api/tpl/params/query.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import (
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/spf13/cast"
)

// Query defines the map of arguments passed to
// list functions in templates.
type Query map[string]interface{}

var (
	// Defaults represents the default params if
	// none were passed for templates.
	Defaults = params.Defaults{
		Page:           1,
		Limit:          15,
		OrderBy:        "created_at",
		OrderDirection: "desc",
	}
)

// Get
//
// Returns parameters for the store to used for obtaining
// multiple entities. If the orderBy or orderDirection
// arguments are not passed, defaults will be used.
func (q Query) Get(orderBy string, orderDirection string) params.Params {
	def := Defaults
	if orderBy != "" {
		def.OrderBy = orderBy
	}
	if orderDirection != "" {
		def.OrderDirection = orderDirection
	}
	p := params.NewParams(q, def)
	return p.Get()
}

// Param
//
// Is an implementation of a stringer to return
// parameters from the Query map.
func (q Query) Param(param string) string {
	val, ok := q[param]
	if !ok {
		return ""
	}
	s, err := cast.ToStringE(val)
	if err != nil {
		return ""
	}
	return s
}

// Default
//
// Sets or gets default parameters for the Query.
// If the parameter is not found, it will
// return the default string passed.
func (q Query) Default(param string, def string) interface{} {
	val, ok := q[param]
	if !ok {
		return def
	}
	return val
}"
}
{
file:./api/tpl/params/query_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import (
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/stretchr/testify/assert"
	"testing"
)

type noStringer struct{}

func TestQuery_Get(t *testing.T) {

	q := Query{}

	tt := map[string]struct {
		orderBy        string
		orderDirection string
		want           params.Params
	}{
		"Empty": {
			"",
			"",
			params.Params{
				Page:           1,
				Limit:          15,
				LimitAll:       false,
				OrderDirection: Defaults.OrderDirection,
				OrderBy:        Defaults.OrderBy,
				Filters:        nil,
			},
		},
		"Order By": {
			"test",
			"",
			params.Params{
				Page:           1,
				Limit:          15,
				LimitAll:       false,
				OrderDirection: Defaults.OrderDirection,
				OrderBy:        "test",
				Filters:        nil,
			},
		},
		"Order Direction": {
			"",
			"test",
			params.Params{
				Page:           1,
				Limit:          15,
				LimitAll:       false,
				OrderDirection: "test",
				OrderBy:        Defaults.OrderBy,
				Filters:        nil,
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := q.Get(test.orderBy, test.orderDirection)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestQuery_Param(t *testing.T) {

	tt := map[string]struct {
		query Query
		param string
		want  string
	}{
		"Simple": {
			Query{"test": "1"},
			"test",
			"1",
		},
		"Int": {
			Query{"test": 1},
			"test",
			"1",
		},
		"Not Found": {
			Query{"wrongval": ""},
			"test",
			"",
		},
		"Bad Cast": {
			Query{"test": noStringer{}},
			"test",
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := test.query.Param(test.param)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestQuery_Default(t *testing.T) {

	tt := map[string]struct {
		query Query
		param string
		def   string
		want  interface{}
	}{
		"Found": {
			Query{"test": "1"},
			"test",
			"",
			"1",
		},
		"Not Found": {
			Query{},
			"wrongval",
			"default",
			"default",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := test.query.Default(test.param, test.def)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/templates.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tpl

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-gonic/gin"
	"html/template"
	"io"
)

// TemplateHandler is the main template renderer for Verbis
// It's responsible for preparing and executing templates
// and obtaining information such as function maps and
// post specific data.
type TemplateHandler interface {
	TemplateFuncGetter
	TemplateDataGetter
	Prepare(c TemplateConfig) TemplateExecutor
}

// TemplateExecute represents the functions for executing
// template.
type TemplateExecutor interface {
	Exists(template string) bool
	Execute(w io.Writer, name string, data interface{}) (string, error)
	ExecutePost(w io.Writer, name string, ctx *gin.Context, post *domain.PostData) (string, error)
	Config() TemplateConfig
	Executor() TemplateExecutor
}

// TemplateFuncGetter represents the functions for obtaining
// template.FuncMap's for use in Verbis templates.
type TemplateFuncGetter interface {
	FuncMap(ctx *gin.Context, post *domain.PostData, cfg TemplateConfig) template.FuncMap
	GenericFuncMap() template.FuncMap
}

// TemplateDataGetter represents the the Data function
// for obtaining post relevant data to send back to
// the template.
type TemplateDataGetter interface {
	Data(ctx *gin.Context, post *domain.PostData) interface{}
}

// TemplateConfig represents the functions for obtaining
// the executor configuration including "root",
// "master" and "extension".
type TemplateConfig interface {
	GetRoot() string
	GetExtension() string
	GetMaster() string
}

// Config represents the options for passing
type Config struct {
	Root      string
	Extension string
	Master    string
}

// GetRoot
//
// Returns the view root
func (c Config) GetRoot() string {
	return c.Root
}

// GetExtension
//
// Returns the template extension
func (c Config) GetExtension() string {
	return c.Extension
}

// GetMaster
//
// Returns the template master layout
func (c Config) GetMaster() string {
	return c.Master
}"
}
{
file:./api/tpl/funcs/safe/safe.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package safe

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/spf13/cast"
	"html/template"
)

// HTML
//
// Returns a given string as html/template HTML content
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
//
// Example: {{ "<p>verbis&cms</p>" | safeHTML }}
// Returns: `verbis&cms`
func (ns *Namespace) HTML(i interface{}) (template.HTML, error) {
	const op = "Templates.HTML"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe HTML to string"), Operation: op, Err: err}
	}
	return template.HTML(s), nil
}

// HTMLAttr
//
// Returns a given string as html/template HTMLAttr content.
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
func (ns *Namespace) HTMLAttr(i interface{}) (template.HTMLAttr, error) {
	const op = "Templates.HTMLAttr"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe HTMLAttr to string"), Operation: op, Err: err}
	}
	return template.HTMLAttr(s), nil
}

// CSS
//
// Returns a given string as html/template HTML content.
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
//
// Example: {{ "<p>verbis&cms</p>" | safeHTML }}
// Returns: `verbis&amp;cms`
func (ns *Namespace) CSS(i interface{}) (template.CSS, error) {
	const op = "Templates.CSS"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe CSS to string"), Operation: op, Err: err}
	}
	return template.CSS(s), nil
}

// JS
//
// Returns a given string as html/template HTML content.
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
//
// Example: {{ "(2*2)" | safeJS }}
// Returns: `(2*2)`
func (ns *Namespace) JS(i interface{}) (template.JS, error) {
	const op = "Templates.JS"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe JS to string"), Operation: op, Err: err}
	}
	return template.JS(s), nil
}

// safeJSStr
//
// Returns the given string as a html/template JSStr content.
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
func (ns *Namespace) JSStr(i interface{}) (template.JSStr, error) {
	const op = "Templates.JSStr"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe JSStr to string"), Operation: op, Err: err}
	}
	return template.JSStr(s), nil
}

// safeUrl
//
// Returns a given string as html/template URL content.
// Returns errors.TEMPLATE if the inputted interface failed to be cast.
//
// Example: {{ "https://verbiscms.com" | safeUrl }}
// Returns: `https://verbiscms.com`
func (ns *Namespace) Url(i interface{}) (template.URL, error) {
	const op = "Templates.Url"
	s, err := cast.ToStringE(i)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Unable to cast to safe URL to string"), Operation: op, Err: err}
	}
	return template.URL(s), nil
}"
}
{
file:./api/tpl/funcs/safe/safe_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package safe

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"html/template"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

type noStringer struct{}

func TestNamespace_SafeHTML(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			"<h1>hello verbis &amp; world!</h1>",
			template.HTML("<h1>hello verbis &amp; world!</h1>"),
		},
		"int": {
			64,
			template.HTML("64"),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.HTML(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.HTML(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_SafeHTMLAttr(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			`dir="ltd"`,
			template.HTMLAttr(`dir="ltd"`),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.HTMLAttr(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.HTMLAttr(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_SafeCSS(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			`a[href =~ "//verbiscms.com"]#foo`,
			template.CSS(`a[href =~ "//verbiscms.com"]#foo`),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.CSS(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.CSS(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_SafeJS(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			`alert("Hello, Verbis!");`,
			template.JS(`alert("Hello, Verbis!");`),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.JS(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.JS(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_SafeJSStr(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			`Verbis CMS \x21`,
			template.JSStr(`Verbis CMS \x21`),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.JSStr(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.JSStr(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_SafeURL(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Valid": {
			`verbis=H%71&title=(CMS)`,
			template.URL(`verbis=H%71&title=(CMS)`),
		},
		"Error": {
			noStringer{},
			"unable to cast safe.noStringer{}",
		},
		"Nil": {
			nil,
			template.URL(""),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Url(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/safe/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package safe

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/safe/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package safe

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new safe Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for safe to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "safe"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.HTML,
			"safeHTML",
			nil,
			[][2]string{
				{`{{ "<p>verbis&cms</p>" | safeHTML }}`, `<p>verbis&cms</p>`},
			},
		)

		ns.AddMethodMapping(ctx.HTMLAttr,
			"safeHTMLAttr",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.CSS,
			"safeCSS",
			nil,
			[][2]string{
				{`{{ "<p>verbis&cms</p>" | safeCSS }}`, `<p>verbis&cms</p>`},
			},
		)

		ns.AddMethodMapping(ctx.JS,
			"safeJS",
			nil,
			[][2]string{
				{`{{ "(2*2)" | safeJS }}`, `(2*2)`},
			},
		)

		ns.AddMethodMapping(ctx.JSStr,
			"safeJSStr",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Url,
			"safeUrl",
			nil,
			[][2]string{
				{`{{ "https://verbiscms.com" | safeUrl }}`, `https://verbiscms.com`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/strings/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/strings/strings_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Replace(t *testing.T) {

	tt := map[string]struct {
		old  string
		new  string
		src  string
		want interface{}
	}{
		"Valid": {
			"-",
			" ",
			"verbis-cms-is-amazing",
			"verbis cms is amazing",
		},
		"Valid 2": {
			"v",
			"",
			"verbis",
			"erbis",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Replace(test.old, test.new, test.src)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Substr(t *testing.T) {

	tt := map[string]struct {
		str   string
		start interface{}
		end   interface{}
		want  interface{}
	}{
		"Valid": {
			"verbiscms",
			0,
			2,
			"ve",
		},
		"Valid 2": {
			"hello world",
			0,
			5,
			"hello",
		},
		"Strings as Params": {
			"hello world",
			"0",
			"5",
			"hello",
		},
		"Negative Start": {
			"hello world",
			"-1",
			"5",
			"hello",
		},
		"Negative End": {
			"hello world",
			"5",
			"-1",
			" world",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Substr(test.str, test.start, test.end)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Trunc(t *testing.T) {

	tt := map[string]struct {
		str   string
		trunc interface{}
		want  interface{}
	}{
		"Positive": {
			"hello world",
			5,
			"hello",
		},
		"Negative": {
			"hello world",
			-5,
			"world",
		},
		"Strings as Params": {
			"hello world",
			"-5",
			"world",
		},
		"Original": {
			"hello world",
			-1000,
			"hello world",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Trunc(test.str, test.trunc)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Ellipsis(t *testing.T) {

	tt := map[string]struct {
		str  string
		len  interface{}
		want interface{}
	}{
		"Valid": {
			"hello world",
			5,
			"hello...",
		},
		"Valid 2": {
			"hello world this is Verbis CMS",
			11,
			"hello world...",
		},
		"Strings as Params": {
			"hello world",
			"5",
			"hello...",
		},
		"Short String": {
			"cms",
			3,
			"cms",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Ellipsis(test.str, test.len)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/strings/regex_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_RegexMatch(t *testing.T) {

	tt := map[string]struct {
		regex string
		str   string
		want  bool
	}{
		"True 1": {
			`[A-Za-z0-9._%+-]`,
			"test@verbiscms.com",
			true,
		},
		"True 2": {
			`[A-Za-z0-9._%+-]`,
			"TesT@VERBISCMS.COM",
			true,
		},
		"False 1": {
			`[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}`,
			"verbis",
			false,
		},
		"False 2": {
			`[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}`,
			"verbis.com",
			false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Match(test.regex, test.str)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexFindAll(t *testing.T) {

	var s []string

	tt := map[string]struct {
		regex string
		str   string
		n     int
		want  interface{}
	}{
		"Length 1": {
			"v{2}",
			"vvvvvv",
			1,
			[]string{"vv"},
		},
		"Length 2": {
			"v{2}",
			"vv",
			-1,
			[]string{"vv"},
		},
		"None": {
			"v{2}",
			"none",
			-1,
			s,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.FindAll(test.regex, test.str, test.n)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexFind(t *testing.T) {

	tt := map[string]struct {
		regex string
		str   string
		want  interface{}
	}{
		"Found 1": {
			"verbis.?",
			"verbis",
			"verbis",
		},
		"Found 2": {
			"verbis.?",
			"verbiscmsverrbis",
			"verbisc",
		},
		"None": {
			"verbis.?",
			"none",
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Find(test.regex, test.str)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexReplaceAll(t *testing.T) {

	tt := map[string]struct {
		regex string
		str   string
		repl  string
		want  interface{}
	}{
		"1": {
			"a(x*)b",
			"-ab-axxb-",
			"${1}W",
			"-W-xxW-",
		},
		"2": {
			"a(x*)b",
			"-ab-ab-",
			"${1}W",
			"-W-W-",
		},
		"3": {
			"a(x*)b",
			"ababababab",
			"${1}W",
			"WWWWW",
		},
		"4": {
			"a(x*)b",
			"----",
			"${1}W",
			"----",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.ReplaceAll(test.regex, test.str, test.repl)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexReplaceAllLiteral(t *testing.T) {

	tt := map[string]struct {
		regex string
		str   string
		repl  string
		want  interface{}
	}{
		"1": {
			"a(x*)b",
			"-ab-axxb-",
			"${1}",
			"-${1}-${1}-",
		},
		"2": {
			"a(x*)b",
			"-ab-ab-",
			"${1}",
			"-${1}-${1}-",
		},
		"3": {
			"a(x*)b",
			"ababababab",
			"${1}",
			"${1}${1}${1}${1}${1}",
		},
		"4": {
			"a(x*)b",
			"----",
			"${1}",
			"----",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.ReplaceAllLiteral(test.regex, test.str, test.repl)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexSplit(t *testing.T) {

	tt := map[string]struct {
		regex string
		str   string
		i     int
		want  []string
	}{
		"Positive": {
			"v",
			"verbis",
			1,
			[]string{"verbis"},
		},
		"Negative": {
			"v",
			"verbis",
			-1,
			[]string{"", "erbis"},
		},
		"Multiple": {
			"v",
			"vvvvvvv",
			-1,
			[]string{"", "", "", "", "", "", "", ""},
		},
		"None": {
			"v",
			"none",
			-1,
			[]string{"none"},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Split(test.regex, test.str, test.i)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_RegexQuoteMeta(t *testing.T) {

	tt := map[string]struct {
		input string
		want  interface{}
	}{
		"Stripped": {
			"verbis+",
			"verbis\\+",
		},
		"None": {
			"verbis",
			"verbis",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.QuoteMeta(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/strings/regex.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import "regexp"

// Match
//
// Returns true if the input string contains and
// matches of the regular expression pattern.
//
// Example: {{ regexMatch "^Verbis" "Verbis CMS" }}
// Returns `true`
func (ns *Namespace) Match(regex string, str string) bool {
	match, _ := regexp.MatchString(regex, str)
	return match
}

// FindAll
//
// Returns a slice of all matches of the regular
// expressions with the given input string.
//
// Example: {{ regexFindAll "[1,3,5,7]" "123456789" -1 }}
// Returns: `[1 3 5 7]`
func (ns *Namespace) FindAll(regex string, str string, i int) []string {
	r := regexp.MustCompile(regex)
	return r.FindAllString(str, i)
}

// Find
//
// Return the first (left most) match of the
// regular expression in the input string
//
// Example: {{ regexFind "verbis.?" "verbiscms" }}
// Returns `verbisc`
func (ns *Namespace) Find(regex string, str string) string {
	r := regexp.MustCompile(regex)
	return r.FindString(str)
}

// ReplaceAll
//
// Returns a copy of the input string, replacing matches of the Regexp with the replacement string.
// Within the string replacement, $ signs are interpreted as in Expand, so for instance $1
// represents the first submatch.
//
// Example: {{ regexReplaceAll "a(x*)b" "-ab-axxb-" "\${1}W" }}
// Returns: `-W-xxW-`
func (ns *Namespace) ReplaceAll(regex string, str string, repl string) string {
	r := regexp.MustCompile(regex)
	return r.ReplaceAllString(str, repl)
}

// ReplaceAllLiteral
//
// Returns a copy of the input string, replacing matches of the Regexp with the replacement string
// replacement. The replacement string is substituted directly, without using Expand.
//
// Example: {{ regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "${1}" }}
// Returns: `-${1}-${1}-`
func (ns *Namespace) ReplaceAllLiteral(regex string, str string, repl string) string {
	r := regexp.MustCompile(regex)
	return r.ReplaceAllLiteralString(str, repl)
}

// Split
//
// Slices the input string into substrings separated by the expression and returns a slice of the
// substrings between expression matches. The last parameter `i` determines the number of
// substrings to return, where `-1` returns all matches.
//
// Example: {{ regexSplit "b+" "verbis" -1 }}
// Returns: `[ver is]`
func (ns *Namespace) Split(regex string, str string, i int) []string {
	r := regexp.MustCompile(regex)
	return r.Split(str, i)
}

// QuoteMeta
//
// QuoteMeta returns a string that escapes all regular expression metacharacters
// inside the argument text; the returned string is a regular expression matching
// the literal text.
//
// Example: {{ regexQuoteMeta "verbis+?" }}
// Returns: `verbis`
func (ns *Namespace) QuoteMeta(str string) string {
	return regexp.QuoteMeta(str)
}"
}
{
file:./api/tpl/funcs/strings/strings.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
	"github.com/spf13/cast"
	"strings"
)

// Replace
//
// Returns new replaced string with all matches.
//
// Example: {{ replace " " "-" "hello verbis cms" }}
// Returns: `hello-verbis-cms`
func (ns *Namespace) Replace(old, new, src string) string {
	return strings.Replace(src, old, new, -1)
}

// Substr
//
// Returns new substring of the given string.
//
// Example: {{ substr "hello verbis" 0 5 }}
// Returns: `hello`
func (ns *Namespace) Substr(str string, start, end interface{}) string {
	st := cast.ToInt(start)
	en := cast.ToInt(end)
	if st < 0 {
		return str[:en]
	}
	if en < 0 || en > len(str) {
		return str[st:]
	}
	return str[st:en]
}

// Trunc
//
// Returns a truncated string with no suffix, negatives apply.
//
// Example: {{ trunc "hello verbis" -5 }}
// Returns: `verbis`
func (ns *Namespace) Trunc(str string, a interface{}) string {
	i := cast.ToInt(a)
	if i < 0 && len(str)+i > 0 {
		return str[len(str)+i:]
	}
	if i >= 0 && len(str) > i {
		return str[:i]
	}
	return str
}

// Ellipsis
//
// Returns a ellipsis (...) string from the given length.
//
// Example: {{ ellipsis "hello verbis cms!" 11 }
// Returns: `hello verbis...`}
func (ns *Namespace) Ellipsis(str string, len interface{}) string {
	i := cast.ToInt(len)
	marker := "..."
	if i < 4 {
		return str
	}
	return ns.Substr(str, 0, i) + marker
}"
}
{
file:./api/tpl/funcs/strings/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package strings

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"strings"
)

// Creates a new strings Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for slices to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "strings"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(strings.TrimSpace,
			"trim",
			nil,
			[][2]string{
				{`{{ trim "    hello verbis     " }}`, `hello verbis`},
			},
		)

		ns.AddMethodMapping(strings.ToUpper,
			"upper",
			nil,
			[][2]string{
				{`{{ upper "hello verbis" }}`, `HELLO VERBIS`},
			},
		)

		ns.AddMethodMapping(strings.ToLower,
			"lower",
			nil,
			[][2]string{
				{`{{ lower "hELLo VERBIS" }}`, `hello verbis`},
			},
		)

		ns.AddMethodMapping(strings.Title,
			"title",
			nil,
			[][2]string{
				{`{{ title "hello verbis" }}`, `Hello Verbis`},
			},
		)

		ns.AddMethodMapping(ctx.Replace,
			"replace",
			nil,
			[][2]string{
				{`{{ replace " " "-" "hello verbis cms" }}`, `hello-verbis-cms`},
			},
		)

		ns.AddMethodMapping(ctx.Substr,
			"substr",
			nil,
			[][2]string{
				{`{{ substr "hello verbis" 0 5 }}`, `hello`},
			},
		)

		ns.AddMethodMapping(ctx.Trunc,
			"trunc",
			nil,
			[][2]string{
				{`{{ trunc "hello verbis" 5 }}`, `hello`},
				{`{{ trunc "hello verbis" -6 }}`, `verbis`},
			},
		)

		ns.AddMethodMapping(ctx.Ellipsis,
			"ellipsis",
			nil,
			[][2]string{
				{`{{ ellipsis "hello verbis cms!" 12 }}`, `hello verbis...`},
			},
		)

		ns.AddMethodMapping(ctx.Match,
			"regexMatch",
			nil,
			[][2]string{
				{`{{ regexMatch "^Verbis" "Verbis CMS" }}`, `true`},
			},
		)

		ns.AddMethodMapping(ctx.FindAll,
			"regexFindAll",
			nil,
			[][2]string{
				{`{{ regexFindAll "[1,3,5,7]" "123456789" -1 }}`, `[1 3 5 7]`},
			},
		)

		ns.AddMethodMapping(ctx.Find,
			"regexFind",
			nil,
			[][2]string{
				{`{{ regexFind "verbis.?" "verbiscms" }}`, `verbisc`},
			},
		)

		ns.AddMethodMapping(ctx.ReplaceAll,
			"regexReplaceAll",
			nil,
			[][2]string{
				{`{{ regexReplaceAll "a(x*)b" "-ab-axxb-" "${1}W" }}`, `-W-xxW-`},
			},
		)

		ns.AddMethodMapping(ctx.ReplaceAllLiteral,
			"regexReplaceAllLiteral",
			nil,
			[][2]string{
				{`{{ regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "${1}" }}`, `-${1}-${1}-`},
			},
		)

		ns.AddMethodMapping(ctx.Split,
			"regexSplit",
			nil,
			[][2]string{
				{`{{ regexSplit "b+" "verbis" -1 }}`, `[ver is]`},
			},
		)

		ns.AddMethodMapping(ctx.QuoteMeta,
			"regexQuoteMeta",
			nil,
			[][2]string{
				{`{{ regexQuoteMeta "verbis+?" }}`, "verbis\\+\\?"},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/posts/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package posts

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/posts/posts.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package posts

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/spf13/cast"
)

const (
	// The default order by field for the list function.
	OrderBy = "updated_at"
	// The default order direction field for the list function.
	OrderDirection = "desc"
)

// Find
//
// Obtains the post by ID and returns a domain.PostData type
// or nil if not found.
//
// Example: {{ post 123 }}
func (ns *Namespace) Find(id interface{}) interface{} {
	i, err := cast.ToIntE(id)
	if err != nil || id == nil {
		return nil
	}

	post, err := ns.deps.Store.Posts.GetById(i, false)
	if err != nil {
		return nil
	}

	return post.Tpl()
}

// Posts defines the struct for returning
// posts and pagination back to the
// template.
type Posts struct {
	Posts      []domain.PostTemplate
	Pagination *http.Pagination
}

// List
//
// Accepts a dict (map[string]interface{}) and returns an
// array of domain.Post. It sets defaults if some of the param
// arguments are missing, and returns an error if the data
// could not be marshalled.

// Returns errors.TEMPLATE if the template post params failed to parse.
//
// Example:
// {{ $result := post (dict "limit" 10 "resource" "posts") }}
// {{ with $result.Posts }}
//     {{ range $post := . }}
//         <h2>{{ $post.Title }}</h2>
//         <a href="{{ $post.Slug }}">Read more</a>
//     {{ end }}
//     {{ else }}
//         <h4>No posts found</h4>
// {{ end }}
func (ns *Namespace) List(query params.Query) (interface{}, error) {
	p := query.Get(OrderBy, OrderDirection)

	resource := query.Default("resource", "")
	status := query.Default("status", "published")

	posts, total, err := ns.deps.Store.Posts.Get(p, false, resource.(string), status.(string))
	if errors.Code(err) == errors.NOTFOUND {
		return nil, nil
	} else if err != nil {
		return nil, err
	}

	var tplPosts = make([]domain.PostTemplate, len(posts))
	for i, post := range posts {
		tplPosts[i] = post.Tpl()
	}

	return Posts{
		Posts:      tplPosts,
		Pagination: http.NewPagination().Get(p, total),
	}, nil
}"
}
{
file:./api/tpl/funcs/posts/posts_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package posts

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	params2 "github.com/ainsleyclark/verbis/api/helpers/params"
	vhttp "github.com/ainsleyclark/verbis/api/http"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	cat  = &domain.Category{}
	post = domain.Post{
		Id:     1,
		Title:  "test title",
		UserId: 1,
	}
	postData = domain.PostData{
		Post:     post,
		Author:   domain.UserPart{},
		Category: cat,
	}
	postDataSlice = []domain.PostData{
		postData, postData,
	}
	tplPost = domain.PostTemplate{
		Author:   domain.UserPart{},
		Category: cat,
		Post:     post,
	}
	tplPostSlice = []domain.PostTemplate{
		tplPost, tplPost,
	}
)

type noStringer struct{}

func Setup() (*Namespace, *mocks.PostsRepository) {
	mock := &mocks.PostsRepository{}
	return &Namespace{deps: &deps.Deps{
		Store: &models.Store{
			Posts: mock,
		},
	}}, mock
}

func TestNamespace_Find(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.PostsRepository)
		want  interface{}
	}{
		"Success": {
			1,
			func(m *mocks.PostsRepository) {
				m.On("GetById", 1, false).Return(postData, nil)
			},
			tplPost,
		},
		"Not Found": {
			1,
			func(m *mocks.PostsRepository) {
				m.On("GetById", 1, false).Return(domain.PostData{}, fmt.Errorf("error"))
			},
			nil,
		},
		"No Stringer": {
			noStringer{},
			func(m *mocks.PostsRepository) {
				m.On("GetById", 1, false).Return(postData, nil)
			},
			nil,
		},
		"Nil": {
			nil,
			func(m *mocks.PostsRepository) {
				m.On("GetById", 1, false).Return(postData, nil)
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got := ns.Find(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_List(t *testing.T) {

	p := params2.Params{
		Page:           1,
		Limit:          15,
		LimitAll:       false,
		OrderBy:        OrderBy,
		OrderDirection: OrderDirection,
	}

	tt := map[string]struct {
		input params.Query
		mock  func(m *mocks.PostsRepository)
		want  interface{}
	}{
		"Success": {
			params.Query{"limit": 15},
			func(m *mocks.PostsRepository) {
				m.On("Get", p, false, "", "published").Return(postDataSlice, 5, nil)
			},
			Posts{
				Posts: tplPostSlice,
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 5,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Nil": {
			nil,
			func(m *mocks.PostsRepository) {
				m.On("Get", p, false, "", "published").Return(postDataSlice, 5, nil)
			},
			Posts{
				Posts: tplPostSlice,
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 5,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Not Found": {
			params.Query{"limit": 15},
			func(m *mocks.PostsRepository) {
				m.On("Get", p, false, "", "published").Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no posts found"})
			},
			nil,
		},
		"Internal Error": {
			params.Query{"limit": 15},
			func(m *mocks.PostsRepository) {
				m.On("Get", p, false, "", "published").Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal error"})
			},
			"internal error",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got, err := ns.List(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/posts/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package posts

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new posts Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for posts to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "posts"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Find,
			"post",
			nil,
			nil,
		)

		ns.AddMethodMapping(ctx.List,
			"posts",
			nil,
			nil,
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/partial/partial_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package partial

import (
	"github.com/ainsleyclark/verbis/api/deps"
	mocks "github.com/ainsleyclark/verbis/api/mocks/tpl"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/dict"
	"github.com/stretchr/testify/assert"
	"html/template"
	"os"
	"path/filepath"
	"testing"
)

const (
	TestPath = "/test/testdata"
)

func Setup(t *testing.T) *mocks.TemplateExecutor {
	wd, err := os.Getwd()
	assert.NoError(t, err)
	apiPath := filepath.Join(filepath.Dir(wd), "../..")

	m := &mocks.TemplateExecutor{}
	mc := &mocks.TemplateConfig{}

	m.On("Config").Return(mc)
	mc.On("GetRoot").Return(apiPath + TestPath)

	return m
}

func TestNamespace_Partial(t *testing.T) {

	tt := map[string]struct {
		name string
		data interface{}
		want interface{}
	}{
		"Success": {
			`html/partial.cms`,
			nil,
			template.HTML(`<h1>This is a partial file.</h1>`),
		},
		"Wrong Path": {
			`html/wrongpath.cms`,
			nil,
			"Templates.Partial: no file exists with the path: html/wrongpath.cms",
		},
		"Bad Data": {
			`html/partial-baddata.cms`,
			nil,
			template.HTML(""),
		},
		"File Type": {
			`images/gopher.png`,
			nil,
			template.HTML(""),
		},
		"Dict": {
			`html/partial-dict.cms`,
			map[string]interface{}{"Text": "cms"},
			template.HTML("cms"),
		},
		"Single Input": {
			`html/partial-data.cms`,
			"verbis",
			template.HTML("verbis"),
		},
		"Multiple Inputs": {
			`html/partial-data.cms`,
			[]interface{}{"hello", "verbis"},
			template.HTML("[hello verbis]"),
		},
		"Multiple Inputs 2": {
			`html/partial-data.cms`,
			[]interface{}{"hello", "verbis", 1, 2, 3},
			template.HTML("[hello verbis 1 2 3]"),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			dic := dict.New(&deps.Deps{})

			p := Partial(template.FuncMap{
				"dict": dic.Dict,
			}, Setup(t))

			got, err := p(test.name, test.data)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/partial/partial.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package partial

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/tpl"
	"html/template"
	"strings"
)

// PartialFunc describes the function for includes or rendering
// partials within the template.
type PartialFunc func(name string, data ...interface{}) (template.HTML, error)

// Partial
//
// Takes in the name of a template relative to the theme as well
// as any data to be passed. The template is executed and
// returns an error if no

// Returns errors.TEMPLATE if no file was found or the template
// could not be executed.
//
// Example: {{ partial "partials/circle.svg" (dict "radius" 50 "fill" "red") }}
func Partial(tplFuncs template.FuncMap, exec tpl.TemplateExecutor) PartialFunc {
	const op = "Templates.Partial"

	return func(name string, data ...interface{}) (template.HTML, error) {
		path := exec.Config().GetRoot() + "/" + name

		if !files.Exists(path) {
			return "", &errors.Error{Code: errors.TEMPLATE, Message: "Partial file does not exist", Operation: op, Err: fmt.Errorf("no file exists with the path: %s", name)}
		}

		var context interface{}
		if len(data) == 1 {
			context = data[0]
		} else {
			context = data
		}

		pathArr := strings.Split(path, "/")

		file, err := template.New(pathArr[len(pathArr)-1]).Funcs(tplFuncs).ParseFiles(path)
		if err != nil {
			return "", &errors.Error{Code: errors.TEMPLATE, Message: "Unable to parse partial file", Operation: op, Err: err}
		}

		var b bytes.Buffer
		err = file.Execute(&b, context)
		if err != nil {
			return "", &errors.Error{Code: errors.TEMPLATE, Message: "Unable to execute partial file", Operation: op, Err: err}
		}

		return template.HTML(b.String()), nil
	}
}"
}
{
file:./api/tpl/funcs/util/util_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package util

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

type noStringer struct{}

func TestNamespace_Len(t *testing.T) {

	ptr := "hello"

	tt := map[string]struct {
		input interface{}
		want  int64
	}{
		"Slice": {
			[]int{1, 2, 3, 4, 5},
			5,
		},
		"Slice Pointer": {
			&[]int{1, 2, 3, 4, 5},
			5,
		},
		"Array": {
			[5]int{1, 2, 3, 4, 5},
			5,
		},
		"Array Pointer": {
			&[5]int{1, 2, 3, 4, 5},
			5,
		},
		"String": {
			"hello",
			5,
		},
		"String Pointer": {
			&ptr,
			5,
		},
		"Map": {
			map[string]string{
				"hello": "hello", "hello!": "hello",
			}, 2,
		},
		"Error": {
			123,
			0,
		},
		"Nil": {
			nil,
			0,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Len(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Explode(t *testing.T) {

	var str []string

	tt := map[string]struct {
		delim interface{}
		text  interface{}
		want  []string
	}{
		"Spaces": {
			delim: " ",
			text:  "hello world !",
			want:  []string{"hello", "world", "!"},
		},
		"Commas": {
			delim: ",",
			text:  "hello,world,!",
			want:  []string{"hello", "world", "!"},
		},
		"Int": {
			delim: "",
			text:  123,
			want:  []string{"1", "2", "3"},
		},
		"No Stringer Delim": {
			delim: noStringer{},
			text:  "hello,world,!",
			want:  str,
		},
		"No Stringer Text": {
			delim: " ",
			text:  noStringer{},
			want:  str,
		},
		"Length": {
			delim: "hello",
			text:  ",",
			want:  []string{"hello"},
		},
		"Nil Delim": {
			delim: nil,
			text:  ",",
			want:  []string{","},
		},
		"Nil Text": {
			delim: "hello",
			text:  nil,
			want:  []string{"h", "e", "l", "l", "o"},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Explode(test.delim, test.text)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Implode(t *testing.T) {

	tt := map[string]struct {
		glue  interface{}
		slice interface{}
		want  string
	}{
		"Spaces": {
			" ",
			[]string{"a", "b", "c"},
			"a b c",
		},
		"Commas": {
			",",
			[]string{"a", "b", "c"},
			"a,b,c",
		},
		"Int": {
			",",
			[]int{1, 2, 3},
			"1,2,3",
		},
		"No Stringer Glue": {
			noStringer{},
			[]string{"a", "b", "c"},
			"",
		},
		"No Stringer Slice": {
			" ",
			noStringer{},
			"",
		},
		"Nil Glue": {
			nil,
			",",
			"",
		},
		"Nil Text": {
			"hello",
			nil,
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Implode(test.glue, test.slice)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/util/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package util

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/util/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package util

import (
	"github.com/spf13/cast"
	"reflect"
	"strings"
)

// Len
//
// Returns the length of a variable according to its type.
// If the length of the type passed could not be
// retrieved, it will return `0`.
//
// Example: {{ len "hello" }}
// Returns: `5`
func (ns *Namespace) Len(i interface{}) int64 {
	if i == nil {
		return 0
	}

	typ := reflect.TypeOf(i).Kind()
	switch typ {
	default:
		return 0
	case reflect.Slice, reflect.Array, reflect.String, reflect.Map:
		return int64(reflect.ValueOf(i).Len())
	case reflect.Ptr:
		test := reflect.Indirect(reflect.ValueOf(i))
		return int64(test.Len())
	}
}

// Explode
//
// Breaks a string into array with a delimiter (separator).
//
// Example: {{ explode "," "hello there !" }}
// Returns: `[hello there !]`
func (ns *Namespace) Explode(delim interface{}, text interface{}) []string {
	d, err := cast.ToStringE(delim)
	if err != nil {
		return nil
	}

	tt, err := cast.ToStringE(text)
	if err != nil {
		return nil
	}

	if len(d) > len(tt) {
		return strings.Split(d, tt)
	} else {
		return strings.Split(tt, d)
	}
}

// Implode
//
// Returns a string from the elements of an array using a
// glue string to join them together.
//
// Example: {{ slice 1 2 3 | explode "," }}
// Returns: `[1 2 3]`
func (ns *Namespace) Implode(glue interface{}, slice interface{}) string {
	str, err := cast.ToStringE(glue)
	if err != nil || slice == nil {
		return ""
	}

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		ret := make([]string, val.Len())
		for i := 0; i < val.Len(); i++ {
			s, err := cast.ToStringE(val.Index(i).Interface())
			if err == nil {
				ret[i] = s
			}
		}

		return strings.Join(ret, str)
	default:
		return ""
	}
}"
}
{
file:./api/tpl/funcs/util/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package util

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new util Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for util to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "safe"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Len,
			"len",
			nil,
			[][2]string{
				{`{{ len "hello" }}`, `5`},
				{`{{ slice 1 2 3 | len  }}`, `3`},
			},
		)

		ns.AddMethodMapping(ctx.Explode,
			"explode",
			nil,
			[][2]string{
				{`{{ explode "," "hello there !" }}`, `[hello there !]`},
			},
		)

		ns.AddMethodMapping(ctx.Implode,
			"implode",
			nil,
			[][2]string{
				{`{{ slice 1 2 3 | implode "," }}`, `1,2,3`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/auth/auth_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package auth

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

func Setup(cookie string) (*Namespace, *mocks.UserRepository) {
	gin.SetMode(gin.TestMode)

	rr := httptest.NewRecorder()
	g, _ := gin.CreateTestContext(rr)
	g.Request, _ = http.NewRequest("GET", "/get", nil)
	g.Request.Header.Set("Cookie", cookie)

	mock := &mocks.UserRepository{}
	return &Namespace{
		deps: &deps.Deps{
			Store: &models.Store{
				User: mock,
			},
		},
		ctx: g,
	}, mock
}

func Test_Auth(t *testing.T) {

	tt := map[string]struct {
		want   interface{}
		cookie string
		mock   func(m *mocks.UserRepository)
	}{
		"Logged In": {
			want:   true,
			cookie: "verbis-session=token",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{}, nil)
			},
		},
		"No Cookie": {
			want:   false,
			cookie: "",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{}, nil)
			},
		},
		"No User": {
			want:   false,
			cookie: "verbis-session=token",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{}, fmt.Errorf("error"))
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup(test.cookie)
			test.mock(mock)
			got := ns.Auth()
			assert.Equal(t, test.want, got)
		})
	}
}

func Test_Admin(t *testing.T) {

	tt := map[string]struct {
		want   interface{}
		cookie string
		mock   func(m *mocks.UserRepository)
	}{
		"Is Admin": {
			want:   true,
			cookie: "verbis-session=token",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{
					UserPart: domain.UserPart{Id: 0, Role: domain.UserRole{Id: 6}},
				}, nil)
			},
		},
		"Not Admin": {
			want:   false,
			cookie: "verbis-session=token",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{
					UserPart: domain.UserPart{Id: 0, Role: domain.UserRole{Id: 1}},
				}, nil)
			},
		},
		"No Cookie": {
			want:   false,
			cookie: "",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{}, nil)
			},
		},
		"No User": {
			want:   false,
			cookie: "verbis-session=token",
			mock: func(m *mocks.UserRepository) {
				m.On("GetByToken", "token").Return(domain.User{}, fmt.Errorf("error"))
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup(test.cookie)
			test.mock(mock)
			got := ns.Admin()
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/auth/auth.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package auth

// Auth
//
// If the user is authenticated (logged in).
// Return false if the cookie was not found or not authenticated.
//
// Example: {{ auth }}
func (ns *Namespace) Auth() bool {
	cookie, err := ns.ctx.Cookie("verbis-session")

	if err != nil {
		return false
	}

	_, err = ns.deps.Store.User.GetByToken(cookie)
	if err != nil {
		return false
	}

	return true
}

// Admin
//
// If the user is authenticated (logged in) & an admin user.
// Returns false if the cookie was not found or not authenticated.
//
// Example: {{ admin }}
func (ns *Namespace) Admin() bool {
	cookie, err := ns.ctx.Cookie("verbis-session")

	if err != nil {
		return false
	}

	user, err := ns.deps.Store.User.GetByToken(cookie)
	if err != nil {
		return false
	}

	if user.Role.Id < 5 {
		return false
	}

	return true
}"
}
{
file:./api/tpl/funcs/auth/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package auth

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	d := &deps.Deps{}
	ctx := &gin.Context{}
	td := &internal.TemplateDeps{Context: ctx}

	ns := Init(d, td)
	assert.Equal(t, ns.Name, name)
	assert.Equal(t, &Namespace{deps: d, ctx: ctx}, ns.Context())
}"
}
{
file:./api/tpl/funcs/auth/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package auth

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/gin-gonic/gin"
)

// Creates a new auth Namespace
func New(d *deps.Deps, t *internal.TemplateDeps) *Namespace {
	return &Namespace{
		deps: d,
		ctx:  t.Context,
	}
}

// Namespace defines the methods for auth to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
	ctx  *gin.Context
}

const name = "auth"

//  Creates a new Namespace and returns a new internal.FuncsNamespace
func Init(d *deps.Deps, t *internal.TemplateDeps) *internal.FuncsNamespace {
	ctx := New(d, t)

	ns := &internal.FuncsNamespace{
		Name: name,
		Context: func(args ...interface{}) interface{} {
			return ctx
		},
	}

	ns.AddMethodMapping(ctx.Auth,
		"auth",
		nil,
		[][2]string{
			{`{{ toBool "true" }}`, `true`},
		},
	)

	ns.AddMethodMapping(ctx.Admin,
		"admin",
		nil,
		[][2]string{
			{`{{ auth }}`, `false`},
		},
	)

	return ns
}"
}
{
file:./api/tpl/funcs/cast/cast.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cast

// ToSlice
//
// Casts an interface to a []interface{} type.
//
// Example: {{ toSlice 1 }}
// Returns: `[1]`
func (ns *Namespace) ToSlice(i interface{}) []interface{} {
	var s []interface{}

	if i == nil {
		return nil
	}

	switch v := i.(type) {
	case []interface{}:
		return append(s, v...)
	case []map[string]interface{}:
		for _, u := range v {
			s = append(s, u)
		}
		return s
	default:
		s = append(s, i)
		return s
	}
}"
}
{
file:./api/tpl/funcs/cast/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cast

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/cast/cast_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cast

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_ToSlice(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"String": {
			"a",
			[]interface{}{"a"},
		},
		"String Slice": {
			[]interface{}{"a", "b"},
			[]interface{}{"a", "b"},
		},
		"Int": {
			1,
			[]interface{}{1},
		},
		"Int Slice": {
			[]interface{}{1, 2},
			[]interface{}{1, 2},
		},
		"Map": {
			[]map[string]interface{}{{"a": 1}, {"a": 2}},
			[]interface{}{map[string]interface{}{"a": 1}, map[string]interface{}{"a": 2}},
		},
		"Nil": {
			nil,
			[]interface{}(nil),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.ToSlice(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/cast/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cast

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/spf13/cast"
)

// Creates a new cast Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for cast to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "cast"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(cast.ToBool,
			"toBool",
			nil,
			[][2]string{
				{`{{ toBool "true" }}`, `true`},
			},
		)

		ns.AddMethodMapping(cast.ToString,
			"toString",
			nil,
			[][2]string{
				{`{{ toString 1 }}`, `1`},
			},
		)

		ns.AddMethodMapping(ctx.ToSlice,
			"toSlice",
			nil,
			[][2]string{
				{`{{ toSlice "a" }}`, `[a]`},
				{`{{ toSlice 1 }}`, `[1]`},
			},
		)

		ns.AddMethodMapping(cast.ToTime,
			"toTime",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(cast.ToDuration,
			"toTime",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(cast.ToInt,
			"toInt",
			nil,
			[][2]string{
				{`{{ toInt "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToInt8,
			"toInt8",
			nil,
			[][2]string{
				{`{{ toInt8 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToInt16,
			"toInt16",
			nil,
			[][2]string{
				{`{{ toInt16 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToInt32,
			"toInt32",
			nil,
			[][2]string{
				{`{{ toInt32 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToInt64,
			"toInt64",
			nil,
			[][2]string{
				{`{{ toInt64 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToUint,
			"toUInt",
			nil,
			[][2]string{
				{`{{ toUInt "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToUint8,
			"toUInt8",
			nil,
			[][2]string{
				{`{{ toUInt8 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToUint16,
			"toUInt16",
			nil,
			[][2]string{
				{`{{ toUInt16 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToUint32,
			"toUInt32",
			nil,
			[][2]string{
				{`{{ toUInt32 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToUint64,
			"toUInt64",
			nil,
			[][2]string{
				{`{{ toUInt64 "1" }}`, `1`},
			},
		)

		ns.AddMethodMapping(cast.ToFloat32,
			"toFloat32",
			nil,
			[][2]string{
				{`{{ toFloat32 "1.1" }}`, `1.1`},
			},
		)

		ns.AddMethodMapping(cast.ToFloat64E,
			"toFloat64",
			nil,
			[][2]string{
				{`{{ toFloat64 "1.1" }}`, `1.1`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/slice/slice.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package slice

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"reflect"
)

// Slice
//
// Creates a slice (array) of passed arguments.
//
// Example: {{ slice "hello" "world" "!" }}
// Returns: `[hello world !]`
func (ns *Namespace) Slice(i ...interface{}) []interface{} {
	return i
}

// Append
//
// Adds and element to the end of the slice.
//
// Example: {{ append (slice "hello" "world" "!") "verbis" }}
// Returns: `[hello world ! verbis]`
func (ns *Namespace) Append(slice interface{}, i interface{}) ([]interface{}, error) {
	const op = "Templates.Append"

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	default:
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot append on type: %s", typ), Operation: op, Err: fmt.Errorf("unable to append to slice with type: %s", typ)}
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		ret := make([]interface{}, val.Len())
		for i := 0; i < val.Len(); i++ {
			ret[i] = val.Index(i).Interface()
		}

		return append(ret, i), nil
	}
}

// Prepend
//
// Adds and element to the beginning of the slice.
//
// Example: {{ prepend (slice "hello" "world" "!") "verbis" }}
// Returns: `[verbis hello world !]`
func (ns *Namespace) Prepend(slice interface{}, i interface{}) ([]interface{}, error) {
	const op = "Templates.Prepend"

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	default:
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot prepend on type: %s", typ), Operation: op, Err: fmt.Errorf("unable to prepend to slice with type: %s", typ)}
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		ret := make([]interface{}, val.Len())
		for i := 0; i < val.Len(); i++ {
			ret[i] = val.Index(i).Interface()
		}

		return append([]interface{}{i}, ret...), nil
	}
}

// First
//
// Retrieves the first element of the slice.
//
// Example: {{ first (slice "hello" "world" "!") }}
// Returns: `hello`
func (ns *Namespace) First(slice interface{}) (interface{}, error) {
	const op = "Templates.First"

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	default:
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot get the last element on type: %s", typ), Operation: op, Err: fmt.Errorf("unable to get first element of slice with type: %s", typ)}
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		if val.Len() == 0 {
			return nil, nil
		}

		return val.Index(0).Interface(), nil
	}
}

// Last
//
// Retrieves the last element of the slice.
//
// Example: {{ last (slice "hello" "world" "!") }}
// Returns: `!`
func (ns *Namespace) Last(slice interface{}) (interface{}, error) {
	const op = "Templates.Last"

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		if val.Len() == 0 {
			return nil, nil
		}

		return val.Index(val.Len() - 1).Interface(), nil
	default:
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot get the last element on type: %s", typ), Operation: op, Err: fmt.Errorf("unable to get last element of slice with type: %s", typ)}
	}
}

// Reverse
//
// Reverses the slice.
//
// Example: {{ reverse (slice "hello" "world" "!") }}
// Returns: `[! world hello]`
func (ns *Namespace) Reverse(slice interface{}) ([]interface{}, error) {
	const op = "Templates.Reverse"

	typ := reflect.TypeOf(slice).Kind()

	switch typ {
	default:
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot get the last element on type: %s", typ), Operation: op, Err: fmt.Errorf("unable to get reverse slice of type: %s", typ)}
	case reflect.Slice, reflect.Array:
		val := reflect.ValueOf(slice)

		reversed := make([]interface{}, val.Len())
		for i := 0; i < val.Len(); i++ {
			reversed[val.Len()-i-1] = val.Index(i).Interface()
		}

		return reversed, nil
	}
}"
}
{
file:./api/tpl/funcs/slice/slice_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package slice

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Slice(t *testing.T) {

	tt := map[string]struct {
		input []interface{}
		want  interface{}
	}{
		"String": {
			[]interface{}{"a", "b", "c"},
			[]interface{}{"a", "b", "c"},
		},
		"Int": {
			[]interface{}{1, 2, 3},
			[]interface{}{1, 2, 3},
		},
		"Float": {
			[]interface{}{1.1, 2.2, 3.3},
			[]interface{}{1.1, 2.2, 3.3},
		},
		"Mixed": {
			[]interface{}{"a", 1, 1.1},
			[]interface{}{"a", 1, 1.1},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Slice(test.input...)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Append(t *testing.T) {

	slice := []string{"a", "b", "c"}

	tt := map[string]struct {
		input interface{}
		slice interface{}
		want  interface{}
	}{
		"String": {
			"d",
			slice,
			[]interface{}{"a", "b", "c", "d"},
		},
		"Int": {
			1,
			slice,
			[]interface{}{"a", "b", "c", 1},
		},
		"Float": {
			1.1,
			slice,
			[]interface{}{"a", "b", "c", 1.1},
		},
		"Error": {
			"a",
			"wrongval",
			"unable to append to slice with type: string",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Append(test.slice, test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Prepend(t *testing.T) {

	slice := []string{"a", "b", "c"}

	tt := map[string]struct {
		input interface{}
		slice interface{}
		want  interface{}
	}{
		"String": {
			"d",
			slice,
			[]interface{}{"d", "a", "b", "c"},
		},
		"Int": {
			1,
			slice,
			[]interface{}{1, "a", "b", "c"},
		},
		"Float": {
			1.1,
			slice,
			[]interface{}{1.1, "a", "b", "c"},
		},
		"Error": {
			"a",
			"wrongval",
			"unable to prepend to slice with type: string",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Prepend(test.slice, test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_First(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"String": {
			[]interface{}{"a", "b", "c"},
			"a",
		},
		"Int": {
			[]interface{}{1, 2, 3},
			1,
		},
		"Float": {
			[]interface{}{1.1, 2.2, 3.3},
			1.1,
		},
		"Mixed": {
			[]interface{}{1, 1.1, "a"},
			1,
		},
		"Nil": {
			[]interface{}{},
			nil,
		},
		"Error": {
			"wrongval",
			"unable to get first element of slice with type: string",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.First(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Last(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"String": {
			[]interface{}{"a", "b", "c"},
			"c",
		},
		"Int": {
			[]interface{}{1, 2, 3},
			3,
		},
		"Float": {
			[]interface{}{1.1, 2.2, 3.3},
			3.3,
		},
		"Mixed": {
			[]interface{}{1, 1.1, "a"},
			"a",
		},
		"Nil": {
			[]interface{}{},
			nil,
		},
		"Error": {
			"wrongval",
			"unable to get last element of slice with type: string",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Last(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Reverse(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"String": {
			[]interface{}{"a", "b", "c"},
			[]interface{}{"c", "b", "a"},
		},
		"Int": {
			[]interface{}{1, 2, 3},
			[]interface{}{3, 2, 1},
		},
		"Float": {
			[]interface{}{1.1, 2.2, 3.3},
			[]interface{}{3.3, 2.2, 1.1},
		},
		"Mixed": {
			[]interface{}{1, 1.1, "a"},
			[]interface{}{"a", 1.1, 1},
		},
		"Error": {
			input: "wrongval",
			want:  "unable to get reverse slice of type: string",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Reverse(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/slice/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package slice

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/slice/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package slice

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new slice Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for slices to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "slice"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Slice,
			"slice",
			nil,
			[][2]string{
				{`{{ slice "hello" "world" "!" }}`, `[hello world !]`},
			},
		)

		ns.AddMethodMapping(ctx.Append,
			"append",
			nil,
			[][2]string{
				{`{{ append (slice "hello" "world" "!") "verbis" }}`, `[hello world ! verbis]`},
			},
		)

		ns.AddMethodMapping(ctx.Prepend,
			"prepend",
			nil,
			[][2]string{
				{`{{ prepend (slice "hello" "world" "!") "verbis" }}`, `[verbis hello world !]`},
			},
		)

		ns.AddMethodMapping(ctx.First,
			"first",
			nil,
			[][2]string{
				{`{{ first (slice "hello" "world" "!") }}`, `hello`},
			},
		)

		ns.AddMethodMapping(ctx.Last,
			"last",
			nil,
			[][2]string{
				{`{{ last (slice "hello" "world" "!") }}`, `!`},
			},
		)

		ns.AddMethodMapping(ctx.Reverse,
			"reverse",
			nil,
			[][2]string{
				{`{{ reverse (slice "hello" "world" "!") }}`, `[! world hello]`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/date/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package date

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/date/date_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package date

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

var (
	ns = New(&deps.Deps{})
)

type noStringer struct{}

func TestNamespace_Date(t *testing.T) {

	tm, err := time.Parse("02 Jan 06 15:04:05 MST", "22 May 90 20:39:39 GMT")
	if err != nil {
		t.Error(err)
	}

	got, err := ns.Date("02/01/2006", tm)
	assert.Equal(t, "22/05/1990", got)
}

func TestNamespace_DateInZone(t *testing.T) {

	tt := map[string]struct {
		zone string
		time func(tm time.Time) interface{}
	}{
		"time.Time": {
			"UTC",
			func(tm time.Time) interface{} {
				return tm
			},
		},
		"*time.Time": {
			"UTC",
			func(tm time.Time) interface{} {
				return &tm
			},
		},
		"int64": {
			"UTC",
			func(tm time.Time) interface{} {
				return int64(643408779)
			},
		},
		"int32": {
			"UTC",
			func(tm time.Time) interface{} {
				return int32(643408779)
			},
		},
		"int": {
			"UTC",
			func(tm time.Time) interface{} {
				return 643408779
			},
		},
		"No Input": {
			"UTC",
			func(tm time.Time) interface{} {
				return 643408779
			},
		},
		"Invalid Timezone": {
			"wrongval",
			func(tm time.Time) interface{} {
				return 643408779
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			tm, err := time.Parse("02 Jan 06 15:04:05 MST", "22 May 90 20:39:39 GMT")
			if err != nil {
				t.Error(err)
			}
			got, _ := ns.DateInZone("02 Jan 06 15:04 -0700", test.time(tm), test.zone)
			assert.Equal(t, got, "22 May 90 20:39 +0000")
		})
	}

	t.Run("Error", func(t *testing.T) {
		_, err := ns.DateInZone("02 Jan 06 15:04 -0700", noStringer{}, "GMT")
		assert.Contains(t, err.Error(), "unable to cast date.noStringer{} of type date.noStringer to Time")
	})
}

func TestNamespace_Ago(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  string
	}{
		"Default": {
			"defaultval",
			"0s",
		},
		"Negative": {
			time.Now().Add(10 * time.Second),
			"-10s",
		},
		"time.Time": {
			time.Now().Add(-125 * time.Second),
			"2m5s",
		},
		"int64": {
			int64(1608235408),
			time.Since(time.Unix(1608235408, 0)).Round(time.Second).String(),
		},
		"int": {
			1608235408,
			time.Since(time.Unix(1608235408, 0)).Round(time.Second).String(),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Ago(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Duration(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  string
	}{
		"Minutes": {
			"90",
			"1m30s",
		},
		"Minutes 2": {
			"120",
			"2m0s",
		},
		"Hours": {
			"3600",
			"1h0m0s",
		},
		"Hours 2": {
			"9845",
			"2h44m5s",
		},
		"Days": {
			"103784",
			"28h49m44s",
		},
		"Days 2": {
			"117412",
			"32h36m52s",
		},
		"No Value": {
			nil,
			"",
		},
		"int64": {
			int64(10),
			"10s",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Duration(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_HTMLDate(t *testing.T) {
	got, _ := ns.HTMLDate(0)
	assert.Equal(t, "1970-01-01", got)
}

func TestNamespace_HTMLDateInZone(t *testing.T) {
	got, _ := ns.HTMLDateInZone(0, "GMT")
	assert.Equal(t, "1970-01-01", got)
}"
}
{
file:./api/tpl/funcs/date/date.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package date

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/spf13/cast"
	"time"
)

// Date
//
// Format date by `interface{}` input, a date can be
// a `time.Time` or an `int, int32, int64`.
//
// Example: {{ date "02/01/2006" now }}
func (ns *Namespace) Date(fmt string, date interface{}) (string, error) {
	return ns.DateInZone(fmt, date, "Local")
}

// DateInZone
//
// Takes a format, the date and zone. Casts the
// date to the correct format.
//
// Returns errors.TEMPLATE if the the interface could not be cast
// to type time.Time
//
// Example: {{ dateInZone "02/01/2006" now "Europe/London" }}
func (ns *Namespace) DateInZone(format string, date interface{}, zone string) (string, error) {
	const op = "Templates.DateInZone"

	tm, err := cast.ToTimeE(date)
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: fmt.Sprintf("Cannot cast interfaace to time.Time"), Operation: op, Err: err}
	}

	loc, err := time.LoadLocation(zone)
	if err != nil {
		loc, _ = time.LoadLocation("UTC")
	}

	return tm.In(loc).Format(format), nil
}

// Ago
//
// Returns a duration from the given time input
// in seconds. a date can be a `time.Time` or
// an `int, int64`.
//
// Example: {{ ago .UpdatedAt }}
func (ns *Namespace) Ago(i interface{}) string {
	tm, err := cast.ToTimeE(i)
	if err != nil {
		return "0s"
	}

	return time.Since(tm).Round(time.Second).String()
}

// Duration
//
// Formats a given amount of seconds as a `time.Duration`
// For example `duration 85` will return `1m25s`.
//
// Example: {{ duration 85 }}
func (ns *Namespace) Duration(sec interface{}) string {
	tm, err := cast.ToDurationE(sec)
	if err != nil {
		return ""
	}
	return (tm * time.Second).String()
}

// HTMLDate
//
// Format's a date for inserting into a HTML date
// picker input field.
//
// Example: {{ htmlDate now }}
func (ns *Namespace) HTMLDate(date interface{}) (string, error) {
	return ns.DateInZone("2006-01-02", date, "Local")
}

// HTMLDateInZone
//
// Returns HTML date with a timezone
//
// Example: {{ htmlDateInZone now "Europe/London" }}
func (ns *Namespace) HTMLDateInZone(date interface{}, zone string) (string, error) {
	return ns.DateInZone("2006-01-02", date, zone)
}"
}
{
file:./api/tpl/funcs/date/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package date

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"time"
)

// Creates a new date Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for dates to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "date"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(time.Now,
			"now",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Date,
			"date",
			nil,
			[][2]string{
				{`{{ date "02/01/2006" 643408779 }}`, `22/05/1990`},
			},
		)

		ns.AddMethodMapping(ctx.DateInZone,
			"dateInZone",
			nil,
			[][2]string{
				{`{{ dateInZone "02/01/2006" 643408779 "Europe/London" }}`, `22/05/1990`},
			},
		)

		ns.AddMethodMapping(ctx.Ago,
			"ago",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Duration,
			"duration",
			nil,
			[][2]string{
				{`{{ duration "85" }}`, `1m25s`},
			},
		)

		ns.AddMethodMapping(ctx.HTMLDate,
			"htmlDate",
			nil,
			[][2]string{
				{`{{ htmlDate 643408779 }}`, `1990-05-22`},
			},
		)

		ns.AddMethodMapping(ctx.HTMLDateInZone,
			"htmlDateInZone",
			nil,
			[][2]string{
				{`{{ htmlDateInZone 643408779 "GMT" }}`, `1990-05-22`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/reflect/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflect

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/reflect/reflect_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflect

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

type testReflect struct {
	Name, Value string
}

var (
	ns = New(&deps.Deps{})
	tr = &testReflect{"hello", "verbis"}
)

func TestNamespace_KindIs(t *testing.T) {

	tt := map[string]struct {
		target string
		src    interface{}
		want   bool
	}{
		"True": {
			"ptr",
			tr,
			true,
		},
		"False": {
			"hello",
			tr,
			false,
		},
		"Nil": {
			"",
			nil,
			false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.KindIs(test.target, test.src)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_KindOf(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Slice": {
			[]string{"hello"},
			"slice",
		},
		"Int": {
			123,
			"int",
		},
		"String": {
			"hello",
			"string",
		},
		"Struct": {
			tr,
			"ptr",
		},
		"Nil": {
			nil,
			"invalid",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.KindOf(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_TypeOf(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"Slice": {
			[]string{"hello"},
			"[]string",
		},
		"Int": {
			123,
			"int",
		},
		"String": {
			"hello",
			"string",
		},
		"Struct": {
			tr,
			"*reflect.testReflect",
		},
		"Nil": {
			nil,
			"<nil>",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.TypeOf(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_TypeIs(t *testing.T) {

	tt := map[string]struct {
		target string
		src    interface{}
		want   bool
	}{
		"True": {
			"*reflect.testReflect",
			tr,
			true,
		},
		"False": {
			"wrongval",
			tr,
			false,
		},
		"Nil": {
			"",
			nil,
			false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.TypeIs(test.target, test.src)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_TypeIsLike(t *testing.T) {

	tt := map[string]struct {
		target string
		src    interface{}
		want   bool
	}{
		"True": {
			"reflect.testReflect",
			*tr,
			true,
		},
		"True Pointer": {
			"*reflect.testReflect",
			tr,
			true,
		},
		"False": {
			"wrongval",
			tr,
			false,
		},
		"Nil": {
			"",
			nil,
			false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.TypeIsLike(test.target, test.src)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/reflect/reflect.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflect

import (
	"fmt"
	"reflect"
)

// KindIs
//
// Returns true if the target and source types match.
//
// Returns `true`
// Example: {{ kindIs "int" 123 }}
func (ns *Namespace) KindIs(target string, src interface{}) bool {
	return target == ns.KindOf(src)
}

// KindOf
//
// Returns the type of the given `interface` as a string.
//
// Example: {{ kindOf 123 }}
// Returns: `int`
func (ns *Namespace) KindOf(src interface{}) string {
	return reflect.ValueOf(src).Kind().String()
}

// TypeOf
//
// Returns the underlying type of the given value.
//
// Example: {{ typeOf .Post }}
// Returns: `domain.Post`
func (ns *Namespace) TypeOf(src interface{}) string {
	return fmt.Sprintf("%T", src)
}

// TypeIs
//
// Similar to `kindIs` but its used for types, instead of primitives.
//
// Example: {{ typeOf "domain.Post" .Post }}
// Returns: `true`
func (ns *Namespace) TypeIs(target string, src interface{}) bool {
	return target == ns.TypeOf(src)
}

// TypeIsLike
//
// Similar to `kindIs` but its used for types, instead of primitives.
//
// Example: {{ typeOf "domain.Post" .Post }}
// Returns: true
func (ns *Namespace) TypeIsLike(target string, src interface{}) bool {
	s := ns.TypeOf(src)
	return target == s || "*"+target == s
}"
}
{
file:./api/tpl/funcs/reflect/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflect

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new reflect Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for reflect to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "reflect"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.KindIs,
			"kindIs",
			nil,
			[][2]string{
				{`{{ kindIs "int" 123 }}`, `true`},
			},
		)

		ns.AddMethodMapping(ctx.KindOf,
			"kindOf",
			nil,
			[][2]string{
				{`{{ kindOf 123 }}`, `int`},
			},
		)

		ns.AddMethodMapping(ctx.TypeOf,
			"typeOf",
			nil,
			[][2]string{
				{`{{ typeOf .Post }}`, `domain.PostData`},
			},
		)

		ns.AddMethodMapping(ctx.TypeIs,
			"typeIs",
			nil,
			[][2]string{
				{`{{ trim "    hello verbis     " }}`, `hello verbis`},
			},
		)

		ns.AddMethodMapping(ctx.TypeIsLike,
			"typeIsLike",
			nil,
			[][2]string{
				{`{{ trim "    hello verbis     " }}`, `hello verbis`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/paths/paths.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paths

// Templates
//
// Returns the directory where page templates
// are stored.
//
// Example: {{ templatesPath }}
func (ns *Namespace) Templates() string {
	return ns.deps.Paths.Theme + ns.deps.Theme.TemplateDir
}

// Layouts
//
// Returns the directory where page layouts
// are stored.
//
// Example: {{ layoutsPath }}
func (ns *Namespace) Layouts() string {
	return ns.deps.Paths.Theme + ns.deps.Theme.LayoutDir
}"
}
{
file:./api/tpl/funcs/paths/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paths

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/paths/paths_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paths

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{
		Paths: deps.Paths{
			Theme: "/test/",
		},
		Theme: &domain.ThemeConfig{
			TemplateDir: "templates",
			LayoutDir:   "layouts",
		},
	})
)

func TestNamespace_Templates(t *testing.T) {
	got := ns.Templates()
	assert.Equal(t, "/test/templates", got)
}

func TestNameSpace_Layouts(t *testing.T) {
	got := ns.Layouts()
	assert.Equal(t, "/test/layouts", got)
}"
}
{
file:./api/tpl/funcs/paths/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paths

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new paths Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for paths to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "paths"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(func() string {return d.Paths.Base},
			"basePath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Paths.Admin},
			"adminPath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Paths.API},
			"apiPath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Paths.Theme},
			"themePath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Paths.Uploads},
			"uploadsPath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Theme.AssetsPath},
			"assetsPath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(func() string {return d.Paths.Storage},
			"storagePath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Templates,
			"templatesPath",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Layouts,
			"layoutsPath",
			nil,
			[][2]string{},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/meta/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package meta

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	d := &deps.Deps{}
	p := &domain.PostData{}
	td := &internal.TemplateDeps{Post: p}

	ns := Init(d, td)
	assert.Equal(t, ns.Name, name)
	assert.Equal(t, &Namespace{deps: d, post: p}, ns.Context())
}"
}
{
file:./api/tpl/funcs/meta/meta_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package meta

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/safe"
	"github.com/stretchr/testify/assert"
	"html/template"
	"os"
	"path/filepath"
	"testing"
	"time"
)

func Setup(opts domain.Options, site domain.Site, post domain.Post) (*Namespace, *mocks.MediaRepository) {
	wd, _ := os.Getwd()
	apiPath := filepath.Join(filepath.Dir(wd), "../../../..")

	mock := &mocks.MediaRepository{}
	d := &deps.Deps{
		Store: &models.Store{
			Media: mock,
		},
		Site:    site,
		Options: &opts,
		Paths: deps.Paths{
			Base: apiPath,
		},
	}

	s := safe.New(d)

	ns := Namespace{
		deps: d,
		post: &domain.PostData{
			Post: post,
		},
		funcs: template.FuncMap{
			"safeHTML": s.HTML,
		},
	}

	return &ns, mock
}

func TestNamespace_Header(t *testing.T) {

	code := "codeinjection post"
	cannonical := "test"

	tt := map[string]struct {
		post    domain.Post
		options domain.Options
		site    domain.Site
		want    template.HTML
	}{
		"Success": {
			post: domain.Post{
				Id:                123,
				Title:             "title",
				Resource:          nil,
				PageTemplate:      "template",
				PageLayout:        "layout",
				CodeInjectionHead: &code,
			},
			options: domain.Options{},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `codeinjection post
<meta name="robots" content="noindex">
<link rel="canonical" href="https://verbiscms.com" />`,
		},
		"No CodeInjection for Post": {
			post: domain.Post{CodeInjectionHead: nil},
			site: domain.Site{Url: "https://verbiscms.com"},
			want: `<meta name="robots" content="noindex">
<link rel="canonical" href="https://verbiscms.com" />`,
		},
		"No CodeInjection Globally": {
			post:    domain.Post{},
			options: domain.Options{CodeInjectionHead: "test"},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `test
<meta name="robots" content="noindex">
<link rel="canonical" href="https://verbiscms.com" />`,
		},
		"Not Public for Post": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Seo: &domain.PostSeo{
						Public: false,
					},
				},
			},
			options: domain.Options{},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `<meta name="robots" content="noindex">
<link rel="canonical" href="https://verbiscms.com" />`,
		},
		"Public": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Seo: &domain.PostSeo{
						Public: true,
					},
				},
			},
			options: domain.Options{SeoPublic: true},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want:    `<link rel="canonical" href="https://verbiscms.com" />`,
		},
		"Canonical": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Seo: &domain.PostSeo{
						Canonical: cannonical,
						Public:    true,
					},
				},
			},
			options: domain.Options{SeoPublic: true},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want:    `<link rel="canonical" href="test" />`,
		},
		"Canonical With Slash": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Seo: &domain.PostSeo{
						Canonical: cannonical,
						Public:    true,
					},
				},
			},
			options: domain.Options{SeoPublic: true, SeoEnforceSlash: true},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want:    `<link rel="canonical" href="test/" />`,
		},
		"Meta with Post Description": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Meta: &domain.PostMeta{
						Description: "description",
					},
					Seo: &domain.PostSeo{
						Public: true,
					},
				},
			},
			options: domain.Options{SeoPublic: true},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `<link rel="canonical" href="https://verbiscms.com" />
<meta name="description" content="description">`,
		},
		"Meta with Global Description": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Meta: &domain.PostMeta{
						Description: "",
					},
					Seo: &domain.PostSeo{
						Public: true,
					},
				},
			},
			options: domain.Options{SeoPublic: true, MetaDescription: "description"},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `<link rel="canonical" href="https://verbiscms.com" />
<meta name="description" content="description">`,
		},
		"Meta with Facebook Post Description": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Meta: &domain.PostMeta{
						Title:       "",
						Description: "",
						Facebook: struct {
							Title       string `json:"title,omitempty"`
							Description string `json:"description,omitempty"`
							ImageId     int    `json:"image_id,numeric,omitempty"`
						}{
							Description: "description",
						},
					},
					Seo: &domain.PostSeo{
						Public: true,
					},
				},
			},
			options: domain.Options{SeoPublic: true, MetaDescription: "description"},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `<link rel="canonical" href="https://verbiscms.com" />
<meta name="description" content="description">`,
		},
		"Meta with Twitter Post Description": {
			post: domain.Post{
				SeoMeta: domain.PostOptions{
					Meta: &domain.PostMeta{
						Title:       "",
						Description: "",
						Twitter: struct {
							Title       string `json:"title,omitempty"`
							Description string `json:"description,omitempty"`
							ImageId     int    `json:"image_id,numeric,omitempty"`
						}{
							Description: "description",
						},
					},
					Seo: &domain.PostSeo{
						Public: true,
					},
				},
			},
			options: domain.Options{SeoPublic: true, MetaDescription: "description"},
			site:    domain.Site{Url: "https://verbiscms.com"},
			want: `<link rel="canonical" href="https://verbiscms.com" />
<meta name="description" content="description">
<meta name="twitter:card" content="summary">
<meta name="twitter:description" content="">`,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup(test.options, test.site, test.post)
			mock.On("GetById", 0).Return(domain.Media{}, fmt.Errorf("no image"))
			got := ns.Header()
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_WriteMeta(t *testing.T) {

	tm, err := time.Parse("02 Jan 06 15:04:05 MST", "22 May 90 20:39:39 GMT")
	if err != nil {
		t.Error(err)
	}

	tt := map[string]struct {
		description string
		publishedAt *time.Time
		want        string
	}{
		"With Description": {
			publishedAt: nil,
			description: "verbis",
			want:        `<meta name="description" content="verbis">`,
		},
		"Without Description": {
			publishedAt: nil,
			description: "",
			want:        ``,
		},
		"With Time": {
			publishedAt: &tm,
			want:        `<meta property="article:modified_time" content="1990-05-22 21:39:39 +0100 BST" />`,
		},
		"Nothing": {
			publishedAt: nil,
			want:        ``,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			post := domain.Post{}
			if test.publishedAt != nil {
				post.PublishedAt = test.publishedAt
			}

			ns, mock := Setup(domain.Options{}, domain.Site{}, post)
			mock.On("GetById", 0).Return(domain.Media{}, fmt.Errorf("no image"))

			assert.Equal(t, test.want, ns.Header())
		})
	}
}

//func TestNamespace_WriteFacebook(t *testing.T) {
//
//	media := domain.Media{
//		Id:  1,
//		Url: "/media/url",
//	}
//	opts := domain.Options{
//		SiteTitle:     "verbis",
//		GeneralLocale: "en-gb",
//	}
//
//	tt := map[string]struct {
//		title       string
//		description string
//		mock        func(m *mocks.MediaRepository)
//		options     domain.Options
//		want        string
//	}{
//		"With Title & Description": {
//			title:       "cms",
//			description: "verbis",
//			options:     opts,
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(media, nil)
//			},
//			want: `<meta property="og:type" content="website"><meta property="og:site_name" content="verbis"><meta property="og:locale" content="en-gb"><meta property="og:title" content="cms"><meta property="og:description" content="verbis"><meta property="og:image" content="/media/url">`,
//		},
//		"Without Title & Description": {
//			title:       "",
//			description: "",
//			options:     opts,
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("err"))
//			},
//			want: ``,
//		},
//		"No Image": {
//			title:       "cms",
//			description: "verbis",
//			options:     opts,
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("err"))
//			},
//			want: `<meta property="og:type" content="website"><meta property="og:site_name" content="verbis"><meta property="og:locale" content="en-gb"><meta property="og:title" content="cms"><meta property="og:description" content="verbis">`,
//		},
//	}
//
//	for name, test := range tt {
//		t.Run(name, func(t *testing.T) {
//			ns, mock := Setup(test.options, domain.Site{}, domain.Post{})
//			test.mock(mock)
//
//			var b bytes.Buffer
//			ns.writeFacebook(&b, test.title, test.description, 1)
//			assert.Equal(t, test.want, b.String())
//		})
//	}
//}

//func TestNamespace_WriteTwitter(t *testing.T) {
//
//	media := domain.Media{
//		Id:  1,
//		Url: "/media/url",
//	}
//
//	tt := map[string]struct {
//		title       string
//		description string
//		mock        func(m *mocks.MediaRepository)
//		want        string
//	}{
//		"With Title & Description": {
//			title:       "cms",
//			description: "verbis",
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(media, nil)
//			},
//			want: `<meta name="twitter:card" content="summary"><meta name="twitter:title" content="cms"><meta name="twitter:description" content="cms"><meta name="twitter:image" content="/media/url">`,
//		},
//		"Without Title & Description": {
//			title:       "",
//			description: "",
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("err"))
//			},
//			want: ``,
//		},
//		"No Image": {
//			title:       "cms",
//			description: "verbis",
//			mock: func(m *mocks.MediaRepository) {
//				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("err"))
//			},
//			want: `<meta name="twitter:card" content="summary"><meta name="twitter:title" content="cms"><meta name="twitter:description" content="cms">`,
//		},
//	}
//
//	for name, test := range tt {
//		t.Run(name, func(t *testing.T) {
//			ns, mock := Setup(domain.Options{}, domain.Site{}, domain.Post{})
//			test.mock(mock)
//
//			var b bytes.Buffer
//			ns.writeTwitter(&b, test.title, test.description, 1)
//			assert.Equal(t, test.want, b.String())
//		})
//	}
//}

func TestNamespace_MetaTitle(t *testing.T) {

	tt := map[string]struct {
		meta    domain.PostOptions
		options domain.Options
		want    string
	}{
		"Nil Meta": {
			meta:    domain.PostOptions{Meta: nil},
			options: domain.Options{},
			want:    "",
		},
		"With Post Title": {
			meta:    domain.PostOptions{Meta: &domain.PostMeta{Title: "post-title-verbis"}},
			options: domain.Options{},
			want:    "post-title-verbis",
		},
		"With Options": {
			meta:    domain.PostOptions{Meta: &domain.PostMeta{Title: ""}},
			options: domain.Options{MetaTitle: "post-title-verbis"},
			want:    "post-title-verbis",
		},
		"None": {
			meta:    domain.PostOptions{Meta: &domain.PostMeta{Title: ""}},
			options: domain.Options{MetaTitle: ""},
			want:    "",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			post := domain.Post{
				SeoMeta: test.meta,
			}
			ns, _ := Setup(test.options, domain.Site{}, post)
			got := ns.MetaTitle()
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Footer(t *testing.T) {

	code := `codeinjection `

	tt := map[string]struct {
		post    domain.Post
		options domain.Options
		want    template.HTML
	}{
		"CodeInjection Options & Post": {
			post:    domain.Post{CodeInjectionFoot: &code},
			options: domain.Options{CodeInjectionFoot: code},
			want:    "codeinjection codeinjection ",
		},
		"CodeInjection Post": {
			post:    domain.Post{CodeInjectionFoot: &code},
			options: domain.Options{},
			want:    "codeinjection ",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, _ := Setup(test.options, domain.Site{}, test.post)
			got := ns.Footer()
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/meta/meta.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package meta

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl"
	"html/template"
)

type TemplateMeta struct {
	Site          domain.Site
	Post          *domain.PostData
	Options       domain.Options
	FacebookImage string
	TwitterImage  string
	deps          *deps.Deps
}

const (
	// The path of the emmbedded files to execute.
	EmbeddedPath = "/api/tpl/embedded/"
)

func (tm *TemplateMeta) GetImage(id int) string {
	img, err := tm.deps.Store.Media.GetById(id)
	if err != nil {
		return ""
	}
	return img.Url
}

// Header
//
// Header obtains all of the site and post wide Code Injection
// as well as any meta information from the page.
//
// Example: {{ verbisHead }}
func (ns *Namespace) Header() template.HTML {
	const op = "Templates.Header"

	tm := &TemplateMeta{
		Site:    ns.deps.Site,
		Post:    ns.post,
		Options: *ns.deps.Options,
		deps:    ns.deps,
	}

	head := ns.executeTemplates(tm, []string{"meta", "opengraph", "twitter"})

	return template.HTML(head)
}

// MetaTitle
//
// metaTitle obtains the meta title from the post, if there is no
// title set on the post, it will look for the global title, if
// none, return empty string.
//
// Example: <title>Verbis - {{ metaTitle }}</title>
func (ns *Namespace) MetaTitle() string {
	postMeta := ns.post.SeoMeta.Meta

	if postMeta == nil {
		return ""
	}

	if postMeta.Title != "" {
		return postMeta.Title
	}

	if ns.deps.Options.MetaTitle != "" {
		return ns.deps.Options.MetaTitle
	}

	return ""
}

// Footer
//
// Obtains all of the site and post wide Code Injection
// Returns formatted HTML template for use after the
// closing `</body>`.
//
// Example: {{ verbisFoot }}
func (ns *Namespace) Footer() template.HTML {
	tm := &TemplateMeta{
		Post:    ns.post,
		Options: *ns.deps.Options,
	}

	foot := ns.executeTemplates(tm, []string{"footer"})

	return template.HTML(foot)
}

func (ns *Namespace) executeTemplates(tm *TemplateMeta, tpls []string) string {
	head := ""
	for _, name := range tpls {

		var b bytes.Buffer
		_, err := ns.deps.Tmpl().Prepare(tpl.Config{
			Root:      ns.deps.Paths.Base + EmbeddedPath,
			Extension: ".cms",
		}).Execute(&b, name, tm)

		if err != nil {
			fmt.Println(err)
		}

		head += fmt.Sprintf("%s\n", b.String())
	}

	return head
}"
}
{
file:./api/tpl/funcs/meta/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package meta

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"html/template"
)

// Creates a new meta Namespace
func New(d *deps.Deps, t *internal.TemplateDeps) *Namespace {
	if t.Post.SeoMeta.Seo == nil {
		t.Post.SeoMeta.Seo = &domain.PostSeo{Public: true, ExcludeSitemap: false, Canonical: ""}
	}
	if t.Post.SeoMeta.Meta == nil {
		t.Post.SeoMeta.Meta = &domain.PostMeta{Title: "", Description: ""}
	}
	return &Namespace{
		deps: d,
		post: t.Post,
	}
}

// Namespace defines the methods for meta to be used
// as template functions.
type Namespace struct {
	deps  *deps.Deps
	post  *domain.PostData
	funcs template.FuncMap
}

const name = "meta"

//  Creates a new Namespace and returns a new internal.FuncsNamespace
func Init(d *deps.Deps, t *internal.TemplateDeps) *internal.FuncsNamespace {
	ctx := New(d, t)

	ns := &internal.FuncsNamespace{
		Name: name,
		Context: func(args ...interface{}) interface{} {
			return ctx
		},
	}

	ns.AddMethodMapping(ctx.Header,
		"verbisHead",
		[]string{"head"},
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.MetaTitle,
		"metaTitle",
		nil,
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.Footer,
		"verbisFoot",
		[]string{"foot"},
		[][2]string{},
	)

	return ns
}"
}
{
file:./api/tpl/funcs/math/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/math/math_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Add(t *testing.T) {

	tt := map[string]struct {
		input []interface{}
		want  int64
	}{
		"Valid": {
			[]interface{}{1, 2, 3},
			int64(6),
		},
		"Valid 2": {
			[]interface{}{10, 10},
			int64(20),
		},
		"Strings": {
			[]interface{}{"10", "10"},
			int64(20),
		},
		"Nil": {
			[]interface{}{},
			int64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Add(test.input...)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Subtract(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    interface{}
		want int64
	}{
		"Valid": {
			10,
			1,
			int64(9),
		},
		"Valid 2": {
			100,
			50, int64(50),
		},
		"Strings": {
			"10",
			"5", int64(5),
		},
		"Nil": {
			nil,
			nil, int64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Subtract(test.a, test.b)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Divide(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    interface{}
		want interface{}
	}{
		"Valid": {
			16,
			2,
			int64(8),
		},
		"Valid 2": {
			100,
			50,
			int64(2),
		},
		"Strings": {
			"10",
			"5",
			int64(2),
		},
		"Nil": {
			nil,
			nil,
			"integer divide by zero",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Divide(test.a, test.b)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Multiply(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    []interface{}
		want int64
	}{
		"Valid": {
			10,
			[]interface{}{10},
			int64(100)},

		"Valid 2": {
			2,
			[]interface{}{4, 4},
			int64(32),
		},
		"Strings": {
			10,
			[]interface{}{5, 2},
			int64(100),
		},
		"Nil": {
			nil,
			nil,
			int64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Multiply(test.a, test.b...)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Modulus(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    interface{}
		want interface{}
	}{
		"Valid": {
			10,
			2,
			int64(0),
		},
		"Valid 2": {
			16,
			3,
			int64(1),
		},
		"Strings": {
			100,
			4,
			int64(0),
		},
		"Nil": {
			nil,
			nil,
			"integer divide by zero",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Modulus(test.a, test.b)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Round(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  float64
	}{
		"Valid": {
			10.1234,
			float64(10),
		},
		"Valid 2": {
			16,
			float64(16),
		},
		"Strings": {
			100.564988,
			float64(101),
		},
		"Nil": {
			0,
			float64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Round(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Ceil(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  float64
	}{
		"Valid": {
			10.1234,
			float64(11),
		},
		"Valid 2": {
			16,
			float64(16),
		},
		"Strings": {
			100.564988,
			float64(101),
		},
		"Nil": {
			0,
			float64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Ceil(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Floor(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  float64
	}{
		"Valid": {
			10.1234,
			float64(10),
		},
		"Valid 2": {
			16,
			float64(16),
		},
		"Strings": {
			100.564988,
			float64(100),
		},
		"Nil": {
			0,
			float64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Floor(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Min(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    []interface{}
		want int64
	}{
		"Valid": {
			1,
			[]interface{}{2, 3, 4, 5, 6, 7, 8, 9, 10},
			int64(1),
		},
		"Valid 2": {
			102,
			[]interface{}{3004, 323, 2848},
			int64(102),
		},
		"Smaller Comparison": {
			102,
			[]interface{}{2, 40, 2949},
			int64(2),
		},
		"Strings": {
			"1",
			[]interface{}{"2", "3"},
			int64(1),
		},
		"Nil": {
			nil,
			nil,
			int64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Min(test.a, test.b...)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Max(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    []interface{}
		want int64
	}{
		"Valid": {
			1,
			[]interface{}{2, 3, 4, 5, 6, 7, 8, 9, 10},
			int64(10),
		},
		"Valid 2": {
			102,
			[]interface{}{3004, 323, 2848},
			int64(3004),
		},
		"Smaller Comparison": {
			102,
			[]interface{}{2, 40, 2949},
			int64(2949),
		},
		"Strings": {
			"1",
			[]interface{}{"2", "3"},
			int64(3),
		},
		"Nil": {
			nil,
			nil,
			int64(0),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Max(test.a, test.b...)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/math/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new math Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for math to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "math"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Add,
			"add",
			nil,
			[][2]string{
				{`{{ add 2 2 }}`, `4`},
			},
		)

		ns.AddMethodMapping(ctx.Subtract,
			"subtract",
			nil,
			[][2]string{
				{`{{ subtract 100 10 }}`, `90`},
			},
		)

		ns.AddMethodMapping(ctx.Divide,
			"divide",
			nil,
			[][2]string{
				{`{{ divide 16 4 }}`, `4`},
			},
		)

		ns.AddMethodMapping(ctx.Multiply,
			"multiply",
			nil,
			[][2]string{
				{`{{ multiply 4 4 }}`, `16`},
			},
		)

		ns.AddMethodMapping(ctx.Modulus,
			"mod",
			[]string{"modulus"},
			[][2]string{
				{`{{ mod 10 9 }}`, `1`},
			},
		)

		ns.AddMethodMapping(ctx.Round,
			"round",
			nil,
			[][2]string{
				{`{{ round 10.2 }}`, `10`},
			},
		)

		ns.AddMethodMapping(ctx.Ceil,
			"ceil",
			nil,
			[][2]string{
				{`{{ ceil 9.32 }}`, `10`},
			},
		)

		ns.AddMethodMapping(ctx.Floor,
			"floor",
			nil,
			[][2]string{
				{`{{ floor 9.62 }}`, `9`},
			},
		)

		ns.AddMethodMapping(ctx.Min,
			"min",
			nil,
			[][2]string{
				{`{{ min 20 1 100 }}`, `1`},
			},
		)

		ns.AddMethodMapping(ctx.Max,
			"max",
			nil,
			[][2]string{
				{`{{ max 20 1 100 }}`, `100`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/math/math.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/spf13/cast"
	"math"
)

// Add
//
// Returns a range of numbers that have been added in `int64`
//
// Example: {{ add 2 2 }}
// Returns: `4`
func (ns *Namespace) Add(i ...interface{}) int64 {
	var num int64 = 0
	for _, a := range i {
		num += cast.ToInt64(a)
	}
	return num
}

// Subtract
//
// Returns subtracted numbers in `int64`
//
// Example: {{ subtract 100 10 }}
// Returns: `90`
func (ns *Namespace) Subtract(a, b interface{}) int64 {
	return cast.ToInt64(a) - cast.ToInt64(b)
}

// Divide
//
// Returns divided numbers in `int64`
//
// Example: {{ divide 16 4 }}
// Returns: `4`
func (ns *Namespace) Divide(a, b interface{}) (int64, error) {
	const op = "Templates.Divide"

	aa := cast.ToInt64(a)
	bb := cast.ToInt64(b)

	if bb == 0 {
		return 0, &errors.Error{Code: errors.TEMPLATE, Message: "Cannot divide by zero", Operation: op, Err: fmt.Errorf("integer divide by zero")}
	}

	return aa / bb, nil
}

// Multiply
//
// Returns a range of numbers that have been multiplied in `int64`
//
// Example: {{ multiply 4 4 }}
// Returns: `16`
func (ns *Namespace) Multiply(a interface{}, i ...interface{}) int64 {
	val := cast.ToInt64(a)
	for _, b := range i {
		val = val * cast.ToInt64(b)
	}
	return val
}

// Modulus
//
// Returns remainder of two numbers in `int64`
//
// Example: {{ mod 10 9 }}
// Returns: `1`
func (ns *Namespace) Modulus(a, b interface{}) (int64, error) {
	const op = "Templates.Modulus"

	aa := cast.ToInt64(a)
	bb := cast.ToInt64(b)

	if bb == 0 {
		return 0, &errors.Error{Code: errors.TEMPLATE, Message: "Cannot divide by zero", Operation: op, Err: fmt.Errorf("integer divide by zero")}
	}

	return aa % bb, nil
}

// Round
//
// Rounds up to the nearest integer rounding halfway
// from zero. Returns `float 64`.
//
// Example: {{ round 10.2 }}
// Returns: `10`
func (ns *Namespace) Round(i interface{}) float64 {
	return math.Round(cast.ToFloat64(i))
}

// Ceil
//
// Rounds up to the nearest float value, returns `float 64`
//
// Example: {{ ceil 9.32 }}
// Returns: `10`
func (ns *Namespace) Ceil(i interface{}) float64 {
	return math.Ceil(cast.ToFloat64(i))
}

// Floor
//
// Rounds down to the nearest float value , returns `float 64`
//
// Example: {{ floor 9.62 }}
// Returns: `9`
func (ns *Namespace) Floor(i interface{}) float64 {
	return math.Floor(cast.ToFloat64(i))
}

// Min
//
// Finds the smallest numeric value in a slice of numbers, returns `int64`
//
// Example: {{ min 20 1 100 }}
// Returns: `1`
func (ns *Namespace) Min(a interface{}, i ...interface{}) int64 {
	val := cast.ToInt64(a)
	for _, a := range i {
		b := cast.ToInt64(a)
		if cast.ToInt64(a) < val {
			val = b
		}
	}
	return val
}

// Max
//
// Finds the largest numeric value in a slice of numbers, returns `int64`
//
// Example: {{ max 20 1 100 }}
// Returns: `100`
func (ns *Namespace) Max(a interface{}, i ...interface{}) int64 {
	val := cast.ToInt64(a)
	for _, a := range i {
		b := cast.ToInt64(a)
		if cast.ToInt64(a) > val {
			val = b
		}
	}
	return val
}"
}
{
file:./api/tpl/funcs/url/query.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/spf13/cast"
	"golang.org/x/net/html"
)

// Query
//
// Gets the page query parameter and returns, if the page
// query param wasn't found or the string could
// not be cast to an integer, it will return 1.
//
// Example: {{ paginationPage }}
func (ns *Namespace) Query(i interface{}) string {
	key, err := cast.ToStringE(i)
	if err != nil {
		return ""
	}

	query := ns.ctx.Request.URL.Query()
	val, ok := query[key]
	if !ok {
		return ""
	}

	return html.EscapeString(val[0])
}

// Pagination
//
// Gets the page query parameter and returns, if the page
// query param wasn't found or the string could
// not be cast to an integer, it will return 1.
//
// Example: {{ paginationPage }}
func (ns *Namespace) Pagination() int {
	page := ns.ctx.Query("page")
	if page == "" {
		return 1
	}
	return cast.ToInt(page)
}"
}
{
file:./api/tpl/funcs/url/query_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

type noStringer struct{}

func TestNamespace_Query(t *testing.T) {

	tt := map[string]struct {
		url   string
		input interface{}
		want  interface{}
	}{
		"Int Param": {
			"/?test=123",
			"test",
			"123",
		},
		"String Param": {
			"/?test=hello",
			"test",
			"hello",
		},
		"No Value": {
			"/?test=hello",
			"wrongval",
			"",
		},
		"Nasty Value": {
			"/?test=<script>alert('hacked!')</script>",
			"test",
			"&lt;script&gt;alert(&#39;hacked!&#39;)&lt;/script&gt;",
		},
		"Bad Cast": {
			"/?test=test",
			noStringer{},
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			g, _ := gin.CreateTestContext(httptest.NewRecorder())
			g.Request, _ = http.NewRequest("GET", test.url, nil)

			ns := Namespace{ctx: g}

			got := ns.Query(test.input)

			assert.Equal(t, test.want, got)
		})
	}
}

func TestGetPagination(t *testing.T) {

	tt := map[string]struct {
		url  string
		want interface{}
	}{
		"Int Param": {
			"/?page=123",
			123,
		},
		"Empty": {
			"/",
			1,
		},
		"No Value": {
			"/?test=hello",
			1,
		},
		"Bad Cast": {
			`/page=wrongval`,
			1,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			g, _ := gin.CreateTestContext(httptest.NewRecorder())
			g.Request, _ = http.NewRequest("GET", test.url, nil)

			ns := Namespace{ctx: g}

			got := ns.Pagination()
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/url/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	d := &deps.Deps{}
	ctx := &gin.Context{}
	td := &internal.TemplateDeps{Context: ctx}

	fns := Init(d, td)
	assert.Equal(t, fns.Name, name)
	assert.Equal(t, &Namespace{deps: d, ctx: ctx}, fns.Context())
}"
}
{
file:./api/tpl/funcs/url/url.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/gin-contrib/location"
)

// Base
//
// Returns the current base URL.
//
// Example: {{ baseUrl }}
// Returns: `http://verbiscms.com` (for example)
func (ns *Namespace) Base() string {
	return location.Get(ns.ctx).String()
}

// Scheme
//
// Returns the scheme of the current URL
// `http` or `https`
//
// Example: {{ scheme }}
// Returns: `http` or `https` (for example)
func (ns *Namespace) Scheme() string {
	return location.Get(ns.ctx).Scheme
}

// Host
//
// Returns the host of the current URL
//
// Example: {{ host }}
// Returns: `verbiscms.com` (for example)
func (ns *Namespace) Host() string {
	return location.Get(ns.ctx).Host
}

// Full
//
// Returns the current full URL
//
// Example: {{ fullUrl }}
// Returns: `http://verbiscms.com/page` (for example)
func (ns *Namespace) Full() string {
	return location.Get(ns.ctx).String() + ns.ctx.Request.URL.Path
}

// Path
//
// Returns the path of the current URL
//
// Example: {{ path }}
// Returns: `/page` (for example)
func (ns *Namespace) Path() string {
	return ns.ctx.Request.URL.Path
}"
}
{
file:./api/tpl/funcs/url/url_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/gin-contrib/location"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

func Setup(t *testing.T, request string, f func(ns *Namespace) string) string {
	gin.SetMode(gin.TestMode)

	rr := httptest.NewRecorder()
	_, engine := gin.CreateTestContext(rr)
	engine.Use(location.Default())

	got := ""
	engine.GET("/page", func(g *gin.Context) {
		ns := &Namespace{ctx: g}
		got = f(ns)
		return
	})

	req, err := http.NewRequest("GET", request, nil)
	assert.NoError(t, err)

	engine.ServeHTTP(rr, req)

	return got
}

func TestNamespace_Base(t *testing.T) {

	tt := map[string]struct {
		request string
		want    string
	}{
		"HTTP": {
			"http://verbiscms.com/page",
			"http://verbiscms.com",
		},
		"HTTPS": {
			"https://verbiscms.com/page",
			"https://verbiscms.com",
		},
		"Relative": {
			"/page",
			"http://localhost:8080",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Setup(t, test.request, func(ns *Namespace) string {
				return ns.Base()
			})
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Scheme(t *testing.T) {

	tt := map[string]struct {
		request string
		want    string
	}{
		"HTTP": {
			"http://verbiscms.com/page",
			"http",
		},
		"HTTPS": {
			"https://verbiscms.com/page",
			"https",
		},
		"Relative": {
			"/page",
			"http",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Setup(t, test.request, func(ns *Namespace) string {
				return ns.Scheme()
			})
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Host(t *testing.T) {

	tt := map[string]struct {
		request string
		want    string
	}{
		"Valid": {
			"http://verbiscms.com/page",
			"verbiscms.com",
		},
		"Valid 2": {
			"http://verbiscms.co.uk/page",
			"verbiscms.co.uk",
		},
		"Relative": {
			"/page",
			"localhost:8080",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Setup(t, test.request, func(ns *Namespace) string {
				return ns.Host()
			})
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Full(t *testing.T) {

	tt := map[string]struct {
		request string
		want    string
	}{
		"HTTP": {
			"http://verbiscms.com/page",
			"http://verbiscms.com/page",
		},
		"HTTPS": {
			"https://verbiscms.com/page",
			"https://verbiscms.com/page",
		},
		"Relative": {
			"/page",
			"http://localhost:8080/page",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Setup(t, test.request, func(ns *Namespace) string {
				return ns.Full()
			})
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Path(t *testing.T) {

	tt := map[string]struct {
		request string
		want    string
	}{
		"HTTP": {
			"http://verbiscms.com/page",
			"/page",
		},
		"HTTPS": {
			"https://verbiscms.com/page",
			"/page",
		},
		"Relative": {
			"/page",
			"/page",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := Setup(t, test.request, func(ns *Namespace) string {
				return ns.Path()
			})
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/url/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package url

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/gin-gonic/gin"
)

// Creates a new reflect Namespace
func New(d *deps.Deps, t *internal.TemplateDeps) *Namespace {
	return &Namespace{
		deps: d,
		ctx:  t.Context,
	}
}

// Namespace defines the methods for reflect to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
	ctx  *gin.Context
}

const name = "url"

//  Creates a new Namespace and returns a new internal.FuncsNamespace
func Init(d *deps.Deps, t *internal.TemplateDeps) *internal.FuncsNamespace {
	ctx := New(d, t)

	ns := &internal.FuncsNamespace{
		Name:    name,
		Context: func(args ...interface{}) interface{} { return ctx },
	}

	ns.AddMethodMapping(ctx.Base,
		"baseUrl",
		nil,
		[][2]string{
			{`{{ baseUrl }}`, `http://verbiscms.com`},
		},
	)

	ns.AddMethodMapping(ctx.Scheme,
		"scheme",
		nil,
		[][2]string{
			{`{{ scheme }}`, `http`},
		},
	)

	ns.AddMethodMapping(ctx.Host,
		"host",
		nil,
		[][2]string{
			{`{{ host }}`, `verbiscms.com`},
		},
	)

	ns.AddMethodMapping(ctx.Full,
		"fullUrl",
		nil,
		[][2]string{
			{`{{ fullUrl }}`, `http://verbiscms.com/page`},
		},
	)

	ns.AddMethodMapping(ctx.Path,
		"path",
		nil,
		[][2]string{
			{`{{ path }}`, `/page`},
		},
	)

	ns.AddMethodMapping(ctx.Query,
		"query",
		nil,
		[][2]string{
			{`{{ query "foo" }}`, `bar`},
		},
	)

	ns.AddMethodMapping(ctx.Pagination,
		"paginationPage",
		nil,
		[][2]string{
			{`{{ paginationPage }}`, `2`},
		},
	)

	return ns
}"
}
{
file:./api/tpl/funcs/attributes/attributes.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package attributes

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
)

// Body
//
// Returns class names for the body element. Includes the
// resource, page ID, page title, page template, page
// layout and if the user is logged in or not.
//
// Example: `{{ body }}`
// Returns: `page page-id-4 page-title page-template-news-archive page-layout-main logged-in` (for example)
func (ns *Namespace) Body() string {
	body := new(bytes.Buffer)
	p := ns.tpld.Post.Post

	// Resource, writes page if no resource (e.g. page)
	if p.Resource == nil {
		body.WriteString("page ")
	} else {
		body.WriteString(fmt.Sprintf("%s ", *p.Resource))
	}

	// Page ID (e.g. page-id-2)
	body.WriteString(fmt.Sprintf("page-id-%v ", p.Id))

	// Title
	body.WriteString(fmt.Sprintf("page-title-%s ", cssValidString(p.Title)))

	// Page template (e.g. page-template-test)
	body.WriteString(fmt.Sprintf("page-template-%s ", cssValidString(p.PageTemplate)))

	// Page Layout (e.g page-layout-test)
	body.WriteString(fmt.Sprintf("page-layout-%s", cssValidString(p.PageLayout)))

	// Logged in (e.g. logged-in) if auth
	if ns.auth.Auth() {
		body.WriteString(" logged-in")
	}

	return body.String()
}

// lang
//
// Returns language attributes set in the options for
// use with the `<html lang="">` attribute.
//
// Example: `{{ lang }}`
// Returns: 'en-gb` (for example)
func (ns *Namespace) Lang() string {
	return ns.deps.Options.GeneralLocale
}

// cssValidString
//
// Strips all special characters from the given string
// and replaces forward slashes with hyphens & spaces
// with dashes for a valid CSS class.
//
// Example:
// `My Page !Template` would return `my-page-template`.
func cssValidString(str string) string {
	r := regexp.MustCompile("[^A-Za-z0-9\\s-/]")

	str = r.ReplaceAllString(str, "")
	str = strings.ReplaceAll(str, "/", "-")
	str = strings.ReplaceAll(str, " ", "-")

	return strings.ToLower(str)
}"
}
{
file:./api/tpl/funcs/attributes/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package attributes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/auth"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	d := &deps.Deps{}
	p := &domain.PostData{}
	td := &internal.TemplateDeps{Post: p}

	ns := Init(d, td)
	assert.Equal(t, ns.Name, name)
	assert.Equal(t, &Namespace{deps: d, tpld: td, auth: auth.New(d, td)}, ns.Context())
}"
}
{
file:./api/tpl/funcs/attributes/attributes_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package attributes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/auth"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestNamespace_Body(t *testing.T) {
	gin.SetMode(gin.TestMode)
	resource := "resource"

	tt := map[string]struct {
		post   domain.Post
		cookie bool
		want   string
	}{
		"ID": {
			domain.Post{
				Id:           123,
				Title:        "title",
				Resource:     nil,
				PageTemplate: "template",
				PageLayout:   "layout",
			},
			false,
			"page page-id-123 page-title-title page-template-template page-layout-layout",
		},
		"Resource": {
			domain.Post{
				Id:           1,
				Title:        "title",
				Resource:     &resource,
				PageTemplate: "template",
				PageLayout:   "layout",
			},
			false,
			"resource page-id-1 page-title-title page-template-template page-layout-layout",
		},
		"Template": {
			domain.Post{
				Id:           1,
				Title:        "title",
				Resource:     &resource,
				PageTemplate: "%$@template*&",
				PageLayout:   "layout",
			},
			false,
			"resource page-id-1 page-title-title page-template-template page-layout-layout",
		},
		"Logged In": {
			domain.Post{
				Id:           1,
				Title:        "title",
				Resource:     nil,
				PageTemplate: "template",
				PageLayout:   "layout",
			},
			true,
			"page page-id-1 page-title-title page-template-template page-layout-layout logged-in",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			post := &domain.PostData{Post: test.post}

			ns := Namespace{
				deps: nil,
				tpld: &internal.TemplateDeps{Post: post},
			}

			mock := &mocks.UserRepository{}
			mock.On("GetByToken", "token").Return(domain.User{}, nil)

			rr := httptest.NewRecorder()
			g, _ := gin.CreateTestContext(rr)
			g.Request, _ = http.NewRequest("GET", "/get", nil)
			ns.auth = auth.New(
				&deps.Deps{Store: &models.Store{User: mock}},
				&internal.TemplateDeps{Context: g, Post: post},
			)

			if test.cookie {
				g.Request.Header.Set("Cookie", "verbis-session=token")
			}

			got := ns.Body()
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_CSSValidString(t *testing.T) {

	tt := map[string]struct {
		input string
		want  string
	}{
		"Regex 1": {
			"$verbis$$",
			"verbis",
		},
		"Regex 2": {
			"@$@$$verbis{}|%$@%",
			"verbis",
		},
		"Spaces": {
			"verbis cms",
			"verbis-cms",
		},
		"Forward Slash": {
			"verbis/cms/is/the/best",
			"verbis-cms-is-the-best",
		},
		"Capital Letters": {
			"Verbis CMS",
			"verbis-cms",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := cssValidString(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func Test_Lang(t *testing.T) {
	ns := New(&deps.Deps{
		Options: &domain.Options{
			GeneralLocale: "en-gb",
		},
	}, &internal.TemplateDeps{})
	got := ns.Lang()
	assert.Equal(t, "en-gb", got)
}"
}
{
file:./api/tpl/funcs/attributes/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package attributes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/funcs/auth"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new attributes Namespace
func New(d *deps.Deps, t *internal.TemplateDeps) *Namespace {
	return &Namespace{
		deps: d,
		tpld: t,
		auth: auth.New(d, t),
	}
}

// Namespace defines the methods for attributes to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
	tpld *internal.TemplateDeps
	auth *auth.Namespace
}

const name = "attributes"

//  Creates a new Namespace and returns a new internal.FuncsNamespace
func Init(d *deps.Deps, t *internal.TemplateDeps) *internal.FuncsNamespace {
	ctx := New(d, t)

	ns := &internal.FuncsNamespace{
		Name:    name,
		Context: func(args ...interface{}) interface{} { return ctx },
	}

	ns.AddMethodMapping(ctx.Body,
		"body",
		nil,
		[][2]string{
			{`{{ body }}`, `page page-id-1 page-title-my-verbis-page page-template-single page-layout-main`},
		},
	)

	ns.AddMethodMapping(ctx.Lang,
		"lang",
		nil,
		[][2]string{
			{`{{ lang }}`, `en-gb`},
		},
	)

	return ns
}"
}
{
file:./api/tpl/funcs/users/users.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package users

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/spf13/cast"
)

const (
	// The default order by field for the list function.
	OrderBy = "updated_at"
	// The default order direction field for the list function.
	OrderDirection = "desc"
)

// Find
//
// Obtains the user by ID and returns a domain.UserPart type
// or nil if not found.
//
// Example: {{ user 123 }}
func (ns *Namespace) Find(id interface{}) interface{} {
	i, err := cast.ToIntE(id)
	if err != nil || id == nil {
		return nil
	}

	user, err := ns.deps.Store.User.GetById(i)
	if err != nil {
		return nil
	}

	return user.HideCredentials()
}

// Categories defines the struct for returning
// categories and pagination back to the
// template.
type Users struct {
	Users      []domain.UserPart
	Pagination *http.Pagination
}

// List
//
// Accepts a dict (map[string]interface{}) and returns an
// array of domain.UserPart. It sets defaults if some of the param
// arguments are missing, and returns an error if the data
// could not be marshalled.

// Returns errors.TEMPLATE if the template user params failed to parse.
//
// Example:
// {{ $result := users (dict "limit" 10) }}
// {{ with $result.Users }}
//     {{ range $user := . }}
//         <h2>{{ $user.Name }}</h2>
//     {{ end }}
//     {{ else }}
//         <h4>No users found</h4>
// {{ end }}
func (ns *Namespace) List(query params.Query) (interface{}, error) {
	p := query.Get(OrderBy, OrderDirection)

	users, total, err := ns.deps.Store.User.Get(p)
	if errors.Code(err) == errors.NOTFOUND {
		return nil, nil
	} else if err != nil {
		return nil, err
	}

	return Users{
		Users:      users.HideCredentials(),
		Pagination: http.NewPagination().Get(p, total),
	}, nil
}"
}
{
file:./api/tpl/funcs/users/users_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package users

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	params2 "github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/stretchr/testify/assert"
	"testing"

	//"github.com/ainsleyclark/verbis/api/errors"
	vhttp "github.com/ainsleyclark/verbis/api/http"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	//"time"
)

type noStringer struct{}

func Setup() (*Namespace, *mocks.UserRepository) {
	mock := &mocks.UserRepository{}
	return &Namespace{deps: &deps.Deps{
		Store: &models.Store{
			User: mock,
		},
	}}, mock
}

func TestNamespace_Find(t *testing.T) {

	user := domain.User{
		UserPart: domain.UserPart{Id: 1, FirstName: "verbis"},
	}

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.UserRepository)
		want  interface{}
	}{
		"Success": {
			1,
			func(m *mocks.UserRepository) {
				m.On("GetById", 1).Return(user, nil).Once()
			},
			user.HideCredentials(),
		},
		"Not Found": {
			1,
			func(m *mocks.UserRepository) {
				m.On("GetById", 1).Return(domain.User{}, fmt.Errorf("error")).Once()
			},
			nil,
		},
		"No Stringer": {
			noStringer{},
			func(m *mocks.UserRepository) {
				m.On("GetById", 1).Return(user, nil).Once()
			},
			nil,
		},
		"Nil": {
			nil,
			func(m *mocks.UserRepository) {
				m.On("GetById", 1).Return(user, nil).Once()
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got := ns.Find(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_List(t *testing.T) {

	users := domain.Users{
		domain.User{UserPart: domain.UserPart{Id: 1, FirstName: "verbis"}},
		domain.User{UserPart: domain.UserPart{Id: 1, FirstName: "cms"}},
	}

	p := params2.Params{
		Page:           1,
		Limit:          15,
		LimitAll:       false,
		OrderBy:        OrderBy,
		OrderDirection: OrderDirection,
	}

	tt := map[string]struct {
		input params.Query
		mock  func(m *mocks.UserRepository)
		want  interface{}
	}{
		"Success": {
			params.Query{"limit": 15},
			func(m *mocks.UserRepository) {
				m.On("Get", p).Return(users, 2, nil).Once()
			},
			Users{
				Users: users.HideCredentials(),
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 2,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Nil": {
			nil,
			func(m *mocks.UserRepository) {
				m.On("Get", p).Return(users, 2, nil).Once()
			},
			Users{
				Users: users.HideCredentials(),
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 2,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Not Found": {
			params.Query{"limit": 15},
			func(m *mocks.UserRepository) {
				m.On("Get", p).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no users found"}).Once()
			},
			nil,
		},
		"Internal Error": {
			params.Query{"limit": 15},
			func(m *mocks.UserRepository) {
				m.On("Get", p).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal error"}).Once()
			},
			"internal error",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got, err := ns.List(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/users/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package users

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/users/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package users

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new users Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for users to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "users"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Find,
			"user",
			nil,
			nil,
		)

		ns.AddMethodMapping(ctx.List,
			"users",
			nil,
			nil,
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/fields/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/fields"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	d := &deps.Deps{}
	p := &domain.PostData{}
	td := &internal.TemplateDeps{Post: p}

	ns := Init(d, td)
	assert.Equal(t, ns.Name, name)
	assert.Equal(t, &Namespace{deps: d, fields: fields.NewService(d, p)}, ns.Context())
}"
}
{
file:./api/tpl/funcs/fields/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/fields"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new fields Namespace
func New(d *deps.Deps, t *internal.TemplateDeps) *Namespace {
	f := fields.NewService(d, t.Post)
	return &Namespace{
		deps:   d,
		fields: f,
	}
}

// Namespace defines the methods for fields to be used
// as template functions.
type Namespace struct {
	deps   *deps.Deps
	fields fields.FieldService
}

const name = "fields"

//  Creates a new Namespace and returns a new internal.FuncsNamespace
func Init(d *deps.Deps, t *internal.TemplateDeps) *internal.FuncsNamespace {
	ctx := New(d, t)

	ns := &internal.FuncsNamespace{
		Name:    name,
		Context: func(args ...interface{}) interface{} { return ctx },
	}

	ns.AddMethodMapping(ctx.fields.GetField,
		"field",
		nil,
		[][2]string{
			{`{{ field "text" }}`, `Hello World!`},
		},
	)

	ns.AddMethodMapping(ctx.fields.GetFieldObject,
		"fieldObject",
		nil,
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.fields.GetFields,
		"fields",
		nil,
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.fields.GetLayout,
		"layout",
		nil,
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.fields.GetLayouts,
		"layouts",
		[]string{},
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.fields.GetRepeater,
		"repeater",
		nil,
		[][2]string{},
	)

	ns.AddMethodMapping(ctx.fields.GetFlexible,
		"flexible",
		nil,
		[][2]string{},
	)

	return ns
}"
}
{
file:./api/tpl/funcs/os/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package os

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/os/os.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package os

import "os"

// Env
//
// Retrieve an environment variable by key
//
// Example: {{ env "APP_DEBUG" }}
func (ns *Namespace) Env(key string) string {
	return os.Getenv(key)
}

// ExpandEnv
//
// Retrieve an environment variable by key and
// substitute variables in a string.
//
// Example: {{ expandEnv "Welcome to $APP_NAME" }}
func (ns *Namespace) ExpandEnv(str string) string {
	return os.ExpandEnv(str)
}"
}
{
file:./api/tpl/funcs/os/os_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package os

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"os"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Env(t *testing.T) {

	tt := map[string]struct {
		env   func() error
		input string
		want  string
	}{
		"Valid": {
			func() error { return os.Setenv("verbis", "cms") },
			"verbis",
			"cms",
		},
		"Valid 2": {
			func() error { return os.Setenv("foo", "bar") },
			"foo",
			"bar",
		},
		"Not found": {
			func() error { return nil },
			"",
			"",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			err := test.env()
			got := ns.Env(test.input)
			assert.NoError(t, err)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_ExpandEnv(t *testing.T) {

	tt := map[string]struct {
		env   func() error
		input string
		want  string
	}{
		"Valid": {
			func() error { return os.Setenv("path", "verbis") },
			"$path is my name",
			"verbis is my name",
		},
		"Valid 2": {
			func() error { return os.Setenv("foo", "bar") },
			"hello $foo",
			"hello bar",
		},
		"Not found": {
			func() error { return nil },
			"hello $test verbis",
			"hello  verbis",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			err := test.env()
			got := ns.ExpandEnv(test.input)
			assert.NoError(t, err)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/os/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package os

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new date Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for the os to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "os"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Env,
			"env",
			nil,
			[][2]string{
				{`{{ env "foo" }}`, `bar`},
			},
		)

		ns.AddMethodMapping(ctx.ExpandEnv,
			"expandEnv",
			nil,
			[][2]string{
				{`{{ expandEnv "Welcome to $foo" }}`, `Welcome to bar`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/rand/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rand

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/rand/rand_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rand

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_RandInt(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    interface{}
		want []int
	}{
		"Valid": {
			1,
			100,
			[]int{1, 100},
		},
		"Valid 2": {
			1,
			5,
			[]int{1, 5},
		},
		"Large": {
			1,
			99999999,
			[]int{1, 99999999},
		},
		"Nil A": {
			nil,
			1,
			[]int{0, 0},
		},
		"Nil B": {
			1,
			nil,
			[]int{0, 0},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Int(test.a, test.b)
			if test.want[0] > got || test.want[1] < got {
				t.Error(fmt.Errorf("got %v expecting in between %v", got, test.want))
			}
		})
	}
}

func TestNamespace_RandFloat(t *testing.T) {

	tt := map[string]struct {
		a    interface{}
		b    interface{}
		want []float64
	}{
		"Valid": {
			1,
			100,
			[]float64{1, 100},
		},
		"Valid2": {
			1.555555,
			10.44444,
			[]float64{1.555555, 10.44444},
		},
		"Large": {
			1,
			99999999.99999,
			[]float64{1, 99999999.99999},
		},
		"Nil A": {
			nil,
			1,
			[]float64{0.0, 0.0},
		},
		"Nil B": {
			1,
			nil,
			[]float64{0.0, 0.0},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Float(test.a, test.b)
			if test.want[0] > got || test.want[1] < got {
				t.Error(fmt.Errorf("got %v expecting in between %v", got, test.want))
			}
		})
	}
}

func TestNamespace_RandAlpha(t *testing.T) {

	tt := map[string]struct {
		len  int64
		want int
	}{
		"Valid": {
			5,
			5,
		},
		"Valid 2": {
			10,
			10,
		},
		"Valid 3": {
			100,
			100,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Alpha(test.len)
			assert.Equal(t, test.len, int64(len(got)))
		})
	}
}

func TestNamespace_RandAlphaNum(t *testing.T) {

	tt := map[string]struct {
		len  int64
		want int
	}{
		"Valid": {
			5,
			5,
		},
		"Valid 2": {
			10,
			10,
		},
		"Valid 3": {
			100,
			100,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.AlphaNum(test.len)
			assert.Equal(t, test.len, int64(len(got)))
		})
	}
}"
}
{
file:./api/tpl/funcs/rand/rand.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rand

import (
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/spf13/cast"
	"math/rand"
	"time"
)

// Int
//
// Returns a random integer between min and max values.
//
// Example: {{ randInt 1 10 }}
func (ns *Namespace) Int(a, b interface{}) int {
	min, err := cast.ToIntE(a)
	if err != nil || a == nil {
		return 0
	}

	max, err := cast.ToIntE(b)
	if err != nil || b == nil {
		return 0
	}

	rand.Seed(time.Now().UnixNano())
	return rand.Intn(max-min) + min
}

// Float
//
// Returns a random float between min and max values.
//
// Example: {{ randFloat 2.5 10 }}
func (ns *Namespace) Float(a, b interface{}) float64 {
	min, err := cast.ToFloat64E(a)
	if err != nil || a == nil {
		return 0.0
	}

	max, err := cast.ToFloat64E(b)
	if err != nil || b == nil {
		return 0.0
	}

	rand.Seed(time.Now().UnixNano())
	return min + rand.Float64()*(max-min)
}

// Alpha
//
// Returns a random alpha string by the given length.
//
// Example: {{ randAlpha 20 }}
func (ns *Namespace) Alpha(len int64) string {
	return encryption.RandomString(len, false)
}

// AlphaNum
//
// Returns a random alpha numeric string by the given length.
//
// Example: {{ randAlphaNum 20 }}
func (ns *Namespace) AlphaNum(len int64) string {
	return encryption.RandomString(len, true)
}"
}
{
file:./api/tpl/funcs/rand/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rand

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new reflect Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for reflect to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "reflect"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Int,
			"randInt",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Float,
			"randFloat",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Alpha,
			"randAlpha",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.AlphaNum,
			"randAlphaNum",
			nil,
			[][2]string{},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/dict/dict_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package dict

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Dict(t *testing.T) {

	tt := map[string]struct {
		input []interface{}
		want  interface{}
	}{
		"Valid": {
			[]interface{}{"test", 123},
			map[string]interface{}{"test": 123},
		},
		"Odd Value": {
			[]interface{}{"test"},
			"dict values are not divisable by two",
		},
		"Not a String": {
			[]interface{}{123, 123},
			"dict keys passed are not strings",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Dict(test.input...)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/dict/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package dict

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/dict/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package dict

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new dict Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for dicts to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "dict"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Dict,
			"dict",
			nil,
			[][2]string{
				{`{{ dict "colour" "green" "height" 20 }}`, `map[colour:green height:20]`},
			},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/dict/dict.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package dict

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
)

// Dict
//
// Allows to pass multiple values to templates to use inside a
// template call for use with the post loop or partial
// calls.
//
// Returns errors.TEMPLATE if the dict values are not divisible by two or
// any dict keys were not strings.
//
// Example: {{ dict "colour" "green" "height" 20 }}
// Returns: map[string]interface{}{"colour":"green", "height":20}
func (ns *Namespace) Dict(values ...interface{}) (map[string]interface{}, error) {
	const op = "Templates.Dict"

	if len(values)%2 != 0 {
		return nil, &errors.Error{Code: errors.TEMPLATE, Message: "Invalid dict call", Operation: op, Err: fmt.Errorf("dict values are not divisable by two")}
	}
	dict := make(map[string]interface{}, len(values)/2)

	for i := 0; i < len(values); i += 2 {
		key, ok := values[i].(string)
		if !ok {
			return nil, &errors.Error{Code: errors.TEMPLATE, Message: "Dict keys must be strings", Operation: op, Err: fmt.Errorf("dict keys passed are not strings")}
		}
		dict[key] = values[i+1]
	}
	return dict, nil
}"
}
{
file:./api/tpl/funcs/categories/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package categories

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/categories/categories.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package categories

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/spf13/cast"
)

const (
	// The default order by field for the list function.
	OrderBy = "updated_at"
	// The default order direction field for the list function.
	OrderDirection = "desc"
)

// Find
//
// Obtains the category by ID and returns a domain.Category type
// or nil if not found.
//
// Example: {{ category 123 }}
func (ns *Namespace) Find(id interface{}) interface{} {
	i, err := cast.ToIntE(id)
	if err != nil || id == nil {
		return nil
	}

	category, err := ns.deps.Store.Categories.GetById(i)
	if err != nil {
		return nil
	}

	return category
}

// ByName
//
// Obtains the category by name and returns a domain.Category type
// or nil if not found.
//
// Example: {{ categoryByName "sports" }}
func (ns *Namespace) ByName(name interface{}) interface{} {
	n, err := cast.ToStringE(name)
	if err != nil || name == nil {
		return nil
	}

	category, err := ns.deps.Store.Categories.GetByName(n)
	if err != nil {
		return nil
	}

	return category
}

// ByParent
//
// Obtains the category by parent and returns a domain.Category type
// or nil if not found.
//
// Example: {{ categoryByParent "sports" }}
func (ns *Namespace) Parent(id interface{}) interface{} {
	i, err := cast.ToIntE(id)
	if err != nil || id == nil {
		return nil
	}

	category, err := ns.deps.Store.Categories.GetParent(i)
	if err != nil {
		return nil
	}

	return category
}

// Categories defines the struct for returning
// categories and pagination back to the
// template.
type Categories struct {
	Categories []domain.Category
	Pagination *http.Pagination
}

// List
//
// Accepts a dict (map[string]interface{}) and returns an
// array of domain.Category. It sets defaults if some of the param
// arguments are missing, and returns an error if the data
// could not be marshalled.

// Returns errors.TEMPLATE if the template post category failed to parse.
//
// Example:
// {{ $result := categories (dict "limit" 10) }}
// {{ with $result.Categories }}
//     {{ range $category := . }}
//         <h2>{{ $category.Name }}</h2>
//     {{ end }}
//     {{ else }}
//         <h4>No categories found</h4>
// {{ end }}
func (ns *Namespace) List(query params.Query) (interface{}, error) {
	p := query.Get(OrderBy, OrderDirection)

	categories, total, err := ns.deps.Store.Categories.Get(p)
	if errors.Code(err) == errors.NOTFOUND {
		return nil, nil
	} else if err != nil {
		return nil, err
	}

	return Categories{
		Categories: categories,
		Pagination: http.NewPagination().Get(p, total),
	}, nil
}"
}
{
file:./api/tpl/funcs/categories/categories_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package categories

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	params2 "github.com/ainsleyclark/verbis/api/helpers/params"
	vhttp "github.com/ainsleyclark/verbis/api/http"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl/params"
	"github.com/stretchr/testify/assert"
	"testing"
)

type noStringer struct{}

func Setup() (*Namespace, *mocks.CategoryRepository) {
	mock := &mocks.CategoryRepository{}
	return &Namespace{deps: &deps.Deps{
		Store: &models.Store{
			Categories: mock,
		},
	}}, mock
}

func TestNamespace_Find(t *testing.T) {

	category := domain.Category{Id: 1, Name: "cat"}

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.CategoryRepository)
		want  interface{}
	}{
		"Success": {
			1,
			func(m *mocks.CategoryRepository) {
				m.On("GetById", 1).Return(category, nil)
			},
			category,
		},
		"Not Found": {
			1,
			func(m *mocks.CategoryRepository) {
				m.On("GetById", 1).Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
		"No Stringer": {
			noStringer{},
			func(m *mocks.CategoryRepository) {
				m.On("GetById", 1).Return(category, nil)
			},
			nil,
		},
		"Nil": {
			nil,
			func(m *mocks.CategoryRepository) {
				m.On("GetById", 1).Return(category, nil)
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got := ns.Find(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_ByName(t *testing.T) {

	category := domain.Category{Id: 1, Name: "cat"}

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.CategoryRepository)
		want  interface{}
	}{
		"Success": {
			"cat",
			func(m *mocks.CategoryRepository) {
				m.On("GetByName", "cat").Return(category, nil)
			},
			category,
		},
		"Not Found": {
			"cat",
			func(m *mocks.CategoryRepository) {
				m.On("GetByName", "cat").Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
		"No Stringer": {
			noStringer{},
			func(m *mocks.CategoryRepository) {
				m.On("GetByName", "cat").Return(category, nil)
			},
			nil,
		},
		"Nil": {
			nil,
			func(m *mocks.CategoryRepository) {
				m.On("GetByName", "cat").Return(category, nil)
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got := ns.ByName(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Parent(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.CategoryRepository)
		want  interface{}
	}{
		"Success": {
			1,
			func(m *mocks.CategoryRepository) {
				m.On("GetParent", 1).Return(domain.Category{Id: 1, Name: "cat"}, nil)
			},
			domain.Category{Id: 1, Name: "cat"},
		},
		"Not Found": {
			1,
			func(m *mocks.CategoryRepository) {
				m.On("GetParent", 1).Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
		"Nil Parent": {
			1,
			func(m *mocks.CategoryRepository) {
				m.On("GetParent", 1).Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
		"No Stringer": {
			noStringer{},
			func(m *mocks.CategoryRepository) {
				m.On("GetParent", 1).Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
		"Nil": {
			nil,
			func(m *mocks.CategoryRepository) {
				m.On("GetParent", 1).Return(domain.Category{}, fmt.Errorf("error"))
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Run(name, func(t *testing.T) {
				ns, mock := Setup()
				test.mock(mock)
				got := ns.Parent(test.input)
				assert.Equal(t, test.want, got)
			})
		})
	}
}

func TestNamespace_List(t *testing.T) {

	categories := []domain.Category{
		{Id: 1, Name: "cat1"},
		{Id: 1, Name: "cat2"},
	}

	p := params2.Params{
		Page:           1,
		Limit:          15,
		LimitAll:       false,
		OrderBy:        OrderBy,
		OrderDirection: OrderDirection,
	}

	tt := map[string]struct {
		input params.Query
		mock  func(m *mocks.CategoryRepository)
		want  interface{}
	}{
		"Success": {
			params.Query{"limit": 15},
			func(m *mocks.CategoryRepository) {
				m.On("Get", p).Return(categories, 2, nil)
			},
			Categories{
				Categories: categories,
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 2,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Nil": {
			nil,
			func(m *mocks.CategoryRepository) {
				m.On("Get", p).Return(categories, 2, nil)
			},
			Categories{
				Categories: categories,
				Pagination: &vhttp.Pagination{
					Page:  1,
					Pages: 1,
					Limit: 15,
					Total: 2,
					Next:  false,
					Prev:  false,
				},
			},
		},
		"Not Found": {
			params.Query{"limit": 15},
			func(m *mocks.CategoryRepository) {
				m.On("Get", p).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no categories found"})
			},
			nil,
		},
		"Internal Error": {
			params.Query{"limit": 15},
			func(m *mocks.CategoryRepository) {
				m.On("Get", p).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal error"})
			},
			"internal error",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got, err := ns.List(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/categories/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package categories

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new categories Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for categories to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "categories"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Find,
			"category",
			nil,
			nil,
		)

		ns.AddMethodMapping(ctx.ByName,
			"categoryByName",
			nil,
			nil,
		)

		ns.AddMethodMapping(ctx.Parent,
			"categoryParent",
			nil,
			nil,
		)

		ns.AddMethodMapping(ctx.List,
			"categories",
			nil,
			nil,
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/debug/experimental/old.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package experimental

//import (
//	"reflect"
//	"sort"
//	"time"
//)
//
//func (d *debug) Sort(m map[string]interface{}) []string {
//	keys := make([]string, len(m))
//	i := 0
//
//	for k := range m {
//		keys[i] = k
//		i++
//	}
//	sort.Strings(keys)
//
//	return keys
//}
//
//// Indent
////
////
//func (d *dump) Indent(lvl int) *debug {
//	for i := 0; i < lvl; i++ {
//		d.Bytes.WriteString("    ")
//	}
//	return d
//}
//
//// LineBreak
////
////
//func (d *dump) LineBreak() *debug {
//	d.Bytes.WriteString("\n")
//	return d
//}
//
//// Write
////
////
//func (d *dump) Write(key string, typ string, val string) *debug {
//	d.Bytes.WriteString("+ ")
//	d.Bytes.WriteString(fmt.Sprintf("<span class=\"sf-dump-name\">%s</span> ", key))
//	d.Bytes.WriteString(fmt.Sprintf("<span class=\"sf-dump-type\">%s</span> ", typ))
//	d.Bytes.WriteString(fmt.Sprintf("<span class=\"sf-dump-value\">\"%s\"</span> ", val))
//	return d
//}
//
//// test
////
////
//func (d *dump) test(key string, typ string, lvl int, e interface{}) {
//
//	lvl = lvl + 1
//
//	val := reflect.ValueOf(e)
//	if val.Kind() == reflect.Ptr {
//		e = reflect.Indirect(val)
//	}
//
//	if e == nil {
//		d.Indent(lvl).Write(key, typ, "nil")
//		return
//	}
//
//	if reflect.TypeOf(e).Kind() == reflect.Struct {
//		d.DeepFields(e)
//		//	d.Struct(typ, lvl, e)
//	}
//
//	switch v := e.(type) {
//	case int, int8, int16, int32, int64:
//		d.Indent(lvl).Write(key, typ, fmt.Sprintf("%d", v))
//	case string:
//		d.Indent(lvl).Write(key, typ, fmt.Sprintf("%s", v))
//	case bool:
//		d.Indent(lvl).Write(key, typ, fmt.Sprintf("%v", v))
//	case time.Time:
//		d.Indent(lvl).Write(key, typ, fmt.Sprintf("%v", v))
//	case map[string]interface{}:
//		d.Indent(lvl).Bytes.WriteString(fmt.Sprintf("%s {\n", key))
//		for _, k := range d.Sort(v) {
//			d.test(k, reflect.TypeOf(v[k]).String(), lvl, v[k])
//			d.LineBreak()
//		}
//		d.Indent(lvl).Bytes.WriteString("}")
//	}
//}
//
//
//// Struct
////
////
//func (d *dump) Struct(typ string, lvl int, e interface{}) {
//	numField := reflect.TypeOf(e).NumField()
//
//	d.Indent(lvl).Bytes.WriteString(fmt.Sprintf("%s {\n", typ))
//	d.Bytes.WriteString(fmt.Sprintf("<samp data-depth=\"%d\">", numField))
//
//	for i := 0 ; i < numField ; i++ {
//		field := reflect.TypeOf(e).Field(i)
//		val := reflect.ValueOf(e).Field(i)
//
//		//if val.Kind() == reflect.Struct {
//		//	continue
//		//}
//
//
//		if val.Kind() == reflect.Ptr {
//			val = reflect.Indirect(val)
//		}
//
//		if val.Kind() == reflect.Map {
//			color.Yellow.Println(val)
//			color.Yellow.Println(field.Name)
//		}
//
//		if !val.IsValid() {
//			d.Indent(lvl + 1).Bytes.WriteString(fmt.Sprintf(`<span class="sf-dump-name">%s</span> `, field.Name))
//			str := fmt.Sprintf(`<span class="sf-dump-type">%s</span> <span class="sf-dump-value">nil</span>`, field.Type)
//			d.Bytes.WriteString(str)
//			d.LineBreak()
//			continue
//		}
//
//		if val.CanInterface() {
//			d.Indent(lvl + 1).Bytes.WriteString(fmt.Sprintf(`<span class="sf-dump-name">%s</span> `, field.Name))
//			str := fmt.Sprintf(`<span class="sf-dump-type">%T</span> <span class="sf-dump-value">%[1]v</span>`, val.Interface())
//			d.Bytes.WriteString(str)
//			d.LineBreak()
//		}
//	}
//
//	d.Indent(lvl).Bytes.WriteString(fmt.Sprintf("</samp>"))
//	d.Bytes.WriteString(fmt.Sprintf("}"))
//}
//
//func (d *dump) DeepFields(iface interface{})  {
//	ifv := reflect.ValueOf(iface)
//	ift := reflect.TypeOf(iface)
//
//	for i := 0; i < ift.NumField(); i++ {
//		v := ifv.Field(i)
//
//		switch v.Kind() {
//		case reflect.Struct:
//			d.DeepFields(v.Interface())
//		default:
//			d.Indent(1).Bytes.WriteString(fmt.Sprintf(`<span class="sf-dump-name">%s</span> `, ift.Field(i).Name))
//			str := fmt.Sprintf(`<span class="sf-dump-type">%T</span> <span class="sf-dump-value">%[1]v</span>`, v.Interface())
//			d.Bytes.WriteString(str)
//			d.LineBreak()
//		}
//	}
//}

//type tester struct {
//	test string
//	testStruct struct{
//		testinner string
//	}
//}

//type debugger interface {
//	Dump(i interface{}) (string, error)
//}

// Have a struct!

//type dump struct {
//	Bytes *bytes.Buffer
//}

//func (d *dump) Dump(i interface{}) (string, error) {

//d.Bytes.WriteString(`
//	<style>
//		.pre.sf-dump {
//			background-color: #18171B;
//			color: #FF8400;
//			line-height: 1.4em;
//			font: 12px Menlo, Monaco, Consolas, monospace;
//			word-wrap: break-word;
//			white-space: pre-wrap;
//			position: relative;
//			z-index: 99999;
//			word-break: break-all;
//			white-space: pre-wrap;
//			padding: 5px;
//			overflow: initial !important;
//
//		}
//		.pre.sf-dump .sf-dump-name {
//			color: #fff;
//		}
//		.pre.sf-dump .sf-dump-public {
//			color: #fff;
//		}
//		.pre.sf-dump .sf-dump-value {
//			color: #56DB3A;
//			font-weight: bold;
//		}
//	</style>
//	<pre class="pre sf-dump">`)

//t := debug.New()
//t.Format(reflect.ValueOf(i))
//test := t.Get()
//
//return test, nil

//d.test("", "", -1, i)
//d.Bytes.WriteString("</pre>")

//file, err := template.New("debug").Parse(test)
//if err != nil {
//	return "", err
//}
//
//var tpl bytes.Buffer
//err = file.Execute(&tpl, nil)
//if err != nil {
//	return "", fmt.Errorf("Unable to execute partial file: %v", err)
//}
//
//return tpl.String(), nil
//}"
}
{
file:./api/tpl/funcs/debug/experimental/format.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package experimental

//type formatState struct {
//	value          interface{}
//	wrt            *bytes.Buffer
//	depth          int
//	pointers       map[uintptr]int
//	ignoreNextType bool
//}
//
//func newFormatState(i interface{}) *formatState {
//	return &formatState{
//		value:    i,
//		wrt:      new(bytes.Buffer),
//		depth:    0,
//		pointers: make(map[uintptr]int),
//	}
//}
//
//func (f *formatState) Get() string {
//
//	f.formatPtr(reflect.ValueOf(f.value))
//
//	return f.wrt.String()
//}
//
//// formatPtr handles formatting of pointers by indirecting them as necessary.
//func (f *formatState) formatPtr(v reflect.Value) {
//	// Display nil if top level pointer is nil.
//	if v.IsNil() && f.ignoreNextType {
//		f.wrt.Write(debug.nilAngleBytes)
//		return
//	}
//
//	// Remove pointers at or below the current depth from map used to detect
//	// circular refs.
//	for k, depth := range f.pointers {
//		if depth >= f.depth {
//			delete(f.pointers, k)
//		}
//	}
//
//	// Keep list of all dereferenced pointers to possibly show later.
//	pointerChain := make([]uintptr, 0)
//
//	// Figure out how many levels of indirection there are by derferencing
//	// pointers and unpacking interfaces down the chain while detecting circular
//	// references.
//	nilFound := false
//	cycleFound := false
//	indirects := 0
//	ve := v
//	for ve.Kind() == reflect.Ptr {
//		if ve.IsNil() {
//			nilFound = true
//			break
//		}
//		indirects++
//		addr := ve.Pointer()
//		pointerChain = append(pointerChain, addr)
//		if pd, ok := f.pointers[addr]; ok && pd < f.depth {
//			cycleFound = true
//			indirects--
//			break
//		}
//		f.pointers[addr] = f.depth
//
//		ve = ve.Elem()
//		if ve.Kind() == reflect.Interface {
//			if ve.IsNil() {
//				nilFound = true
//				break
//			}
//			ve = ve.Elem()
//		}
//	}
//
//	// Display type or indirection level depending on flags.
//	if nilFound || cycleFound {
//		indirects += strings.Count(ve.Type().String(), "*")
//	}
//	f.wrt.Write(debug.openAngleBytes)
//	f.wrt.Write([]byte(strings.Repeat("*", indirects)))
//	f.wrt.Write(debug.closeAngleBytes)
//
//	// Display dereferenced value.
//	switch {
//	case nilFound:
//		f.wrt.Write(debug.nilAngleBytes)
//
//	case cycleFound:
//		f.wrt.Write(debug.circularShortBytes)
//
//	default:
//		f.ignoreNextType = true
//		f.Format(ve)
//	}
//}
//
//func (f *formatState) Format(v reflect.Value) {
//	kind := v.Kind()
//
//	// Handle pointers
//	if kind == reflect.Ptr {
//		//f.formatPtr(v)
//		return
//	}
//
//	switch kind {
//	case reflect.String:
//		f.wrt.Write([]byte(v.String()))
//	case reflect.Invalid:
//		f.wrt.Write(debug.invalidAngleBytes)
//	case reflect.Bool:
//		debug.printBool(f.wrt, v.Bool())
//
//	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
//		debug.printInt(f.wrt, v.Int(), 10)
//
//	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
//		debug.printUint(f.wrt, v.Uint(), 10)
//
//	case reflect.Float32:
//		debug.printFloat(f.wrt, v.Float(), 32)
//
//	case reflect.Float64:
//		debug.printFloat(f.wrt, v.Float(), 64)
//
//	case reflect.Complex64:
//		debug.printComplex(f.wrt, v.Complex(), 32)
//
//	case reflect.Complex128:
//		debug.printComplex(f.wrt, v.Complex(), 64)
//
//	//case reflect.Slice:
//	//	if v.IsNil() {
//	//		f.wrt.Write(nilAngleBytes)
//	//		break
//	//	}
//	//	fallthrough
//	//
//	//case reflect.Array:
//	//	f.wrt.Write(openBracketBytes)
//	//	f.depth++
//	//	numEntries := v.Len()
//	//
//	//	for i := 0; i < numEntries; i++ {
//	//		if i > 0 {
//	//			f.wrt.Write(spaceBytes)
//	//		}
//	//		f.Format(f.unpackValue(v.Index(i)))
//	//	}
//	//
//	//	f.depth--
//	//	f.wrt.Write(closeBracketBytes)
//	//
//	//case reflect.Interface:
//	//	// The only time we should get here is for nil interfaces due to
//	//	// unpackValue calls.
//	//	if v.IsNil() {
//	//		f.wrt.Write(nilAngleBytes)
//	//	}
//	//
//	//case reflect.Ptr:
//	//	// Do nothing.  We should never get here since pointers have already
//	//	// been handled above.
//	//
//	case reflect.Map:
//		// nil maps should be indicated as different than empty maps
//		if v.IsNil() {
//			f.wrt.Write(debug.nilAngleBytes)
//			break
//		}
//
//		f.wrt.Write(debug.openMapBytes)
//		f.depth++
//		keys := v.MapKeys()
//
//		// Sorting herte
//
//		for i, key := range keys {
//			if i > 0 {
//				f.wrt.Write(debug.spaceBytes)
//			}
//			f.Format(f.unpackValue(key))
//			f.wrt.Write(debug.colonBytes)
//			f.Format(f.unpackValue(v.MapIndex(key)))
//		}
//
//		f.depth--
//		f.wrt.Write(debug.closeMapBytes)
//
//		//case reflect.Struct:
//		//	numFields := v.NumField()
//		//	f.wrt.Write(openBraceBytes)
//		//	f.depth++
//		//
//		//	for i := 0; i < numFields; i++ {
//		//		if i > 0 {
//		//			f.wrt.Write(spaceBytes)
//		//		}
//		//		f.Format(f.unpackValue(v.Field(i)))
//		//	}
//		//
//		//	f.depth--
//		//	f.wrt.Write(closeBraceBytes)
//		//
//		//case reflect.Uintptr:
//		//	printHexPtr(f.wrt, uintptr(v.Uint()))
//		//
//		//case reflect.UnsafePointer, reflect.Chan, reflect.Func:
//		//	printHexPtr(f.wrt, v.Pointer())
//		//}
//	}
//}
//
//// unpackValue returns values inside of non-nil interfaces when possible and
//// ensures that types for values which have been unpacked from an interface
//// are displayed when the show types flag is also set.
//// This is useful for data types like structs, arrays, slices, and maps which
//// can contain varying types packed inside an interface.
//func (f *formatState) unpackValue(v reflect.Value) reflect.Value {
//	if v.Kind() == reflect.Interface {
//		if !v.IsNil() {
//			v = v.Elem()
//		}
//	}
//	return v
//}
//
//func sortValues(m map[string]interface{}) []string {
//	keys := make([]string, len(m))
//	i := 0
//
//	for k := range m {
//		keys[i] = k
//		i++
//	}
//	sort.Strings(keys)
//
//	return keys
//}"
}
{
file:./api/tpl/funcs/debug/experimental/html.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package experimental

import (
	"fmt"
)

var (
	name = ``
	css  = `
		<style>
			.pre.sf-dump {
				background-color: #18171B;
				color: #FF8400;
				line-height: 1.4em;
				font: 12px Menlo, Monaco, Consolas, monospace;
				word-wrap: break-word;
				white-space: pre-wrap;
				position: relative;
				z-index: 99999;
				word-break: break-all;
				white-space: pre-wrap;
				padding: 5px;
				overflow: initial !important;
	
			}
			.pre.sf-dump .sf-dump-name {
				color: #fff;
			}
			.pre.sf-dump .sf-dump-public {
				color: #fff;
			}
			.pre.sf-dump .sf-dump-value {
				color: #56DB3A;
				font-weight: bold;
			}
		</style>`
)

type htmlWriter struct{}

func (h *htmlWriter) write(i interface{}) string {
	return h.write(i)
}

func (h *htmlWriter) writeDeep(i interface{}, name string) string {
	return h.name(name) + h.value(i)
}

func (h *htmlWriter) name(n string) string {
	return fmt.Sprintf(`<span class="sf-dump-name">%s</span>`, n)
}

func (h *htmlWriter) value(val interface{}) string {
	return fmt.Sprintf(`<span class="sf-dump-type">%T</span> <span class="sf-dump-value">%[1]v</span>`, val)
}"
}
{
file:./api/tpl/funcs/debug/experimental/common.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package experimental

//
//var (
//	panicBytes            = []byte("(PANIC=")
//	plusBytes             = []byte("+")
//	iBytes                = []byte("i")
//	trueBytes             = []byte("true")
//	falseBytes            = []byte("false")
//	interfaceBytes        = []byte("(interface {})")
//	commaNewlineBytes     = []byte(",\n")
//	newlineBytes          = []byte("\n")
//	openBraceBytes        = []byte("{")
//	openBraceNewlineBytes = []byte("{\n")
//	closeBraceBytes       = []byte("}")
//	asteriskBytes         = []byte("*")
//	colonBytes            = []byte(":")
//	colonSpaceBytes       = []byte(": ")
//	openParenBytes        = []byte("(")
//	closeParenBytes       = []byte(")")
//	spaceBytes            = []byte(" ")
//	pointerChainBytes     = []byte("->")
//	nilAngleBytes         = []byte("<nil>")
//	maxNewlineBytes       = []byte("<max depth reached>\n")
//	maxShortBytes         = []byte("<max>")
//	circularBytes         = []byte("<already shown>")
//	circularShortBytes    = []byte("<shown>")
//	invalidAngleBytes     = []byte("<invalid>")
//	openBracketBytes      = []byte("[")
//	closeBracketBytes     = []byte("]")
//	percentBytes          = []byte("%")
//	precisionBytes        = []byte(".")
//	openAngleBytes        = []byte("<")
//	closeAngleBytes       = []byte(">")
//	openMapBytes          = []byte("map[")
//	closeMapBytes         = []byte("]")
//	lenEqualsBytes        = []byte("len=")
//	capEqualsBytes        = []byte("cap=")
//)
//
//// hexDigits is used to map a decimal value to a hex digit.
//var hexDigits = "0123456789abcdef"
//
//// printBool
////
//// Outputs a boolean value as true or false to Writer w.
//func printBool(w io.Writer, val bool) {
//	if val {
//		w.Write(trueBytes)
//	} else {
//		w.Write(falseBytes)
//	}
//}
//
//// printInt
////
//// Outputs a signed integer value to Writer w.
//func printInt(w io.Writer, val int64, base int) {
//	w.Write([]byte(strconv.FormatInt(val, base)))
//}
//
//// printUint
////
//// Outputs an unsigned integer value to Writer w.
//func printUint(w io.Writer, val uint64, base int) {
//	w.Write([]byte(strconv.FormatUint(val, base)))
//}
//
//// printFloat
////
//// Outputs a floating point value using the specified precision,
//// which is expected to be 32 or 64bit, to Writer w.
//func printFloat(w io.Writer, val float64, precision int) {
//	w.Write([]byte(strconv.FormatFloat(val, 'g', -1, precision)))
//}
//
//// printComplex
////
//// Outputs a complex value using the specified float precision
//// for the real and imaginary parts to Writer w.
//func printComplex(w io.Writer, c complex128, floatPrecision int) {
//	r := real(c)
//	w.Write(openParenBytes)
//	w.Write([]byte(strconv.FormatFloat(r, 'g', -1, floatPrecision)))
//	i := imag(c)
//	if i >= 0 {
//		w.Write(plusBytes)
//	}
//	w.Write([]byte(strconv.FormatFloat(i, 'g', -1, floatPrecision)))
//	w.Write(iBytes)
//	w.Write(closeParenBytes)
//}
//
//// printHexPtr
////
//// Outputs a uintptr formatted as hexadecimal with a leading '0x'
//// prefix to Writer w.
//func printHexPtr(w io.Writer, p uintptr) {
//	// Null pointer.
//	num := uint64(p)
//	if num == 0 {
//		w.Write(nilAngleBytes)
//		return
//	}
//
//	// Max uint64 is 16 bytes in hex + 2 bytes for '0x' prefix
//	buf := make([]byte, 18)
//
//	// It's simpler to construct the hex string right to left.
//	base := uint64(16)
//	i := len(buf) - 1
//	for num >= base {
//		buf[i] = hexDigits[num%base]
//		num /= base
//		i--
//	}
//	buf[i] = hexDigits[num]
//
//	// Add '0x' prefix.
//	i--
//	buf[i] = 'x'
//	i--
//	buf[i] = '0'
//
//	// Strip unused leading bytes.
//	buf = buf[i:]
//	w.Write(buf)
//}"
}
{
file:./api/tpl/funcs/debug/experimental/dump.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package experimental

//type dump struct {
//	options string
//	v       interface{}
//}
//
//func Dump(i interface{}) string {
//	return newFormatState(i).Get()
//}
//
//func DumpHTML(i interface{}) string {
//	return newFormatState(i).Get()
//}"
}
{
file:./api/tpl/funcs/debug/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package debug

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/debug/debug.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package debug

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"html/template"
)

const (
	// CSS describes the styling for dumps to be sent back
	// to the front end.
	CSS = `
		<style>
			.sf-dump {
				background-color: #18171B;
				color: #FF8400;
				line-height: 1.4em;
				font: 12px Menlo, Monaco, Consolas, monospace;
				word-wrap: break-word;
				white-space: pre-wrap;
				position: relative;
				z-index: 99999;
				word-break: break-all;
				white-space: pre-wrap;
				padding: 5px;
				overflow: initial !important;
			}
			.pre.sf-dump .sf-dump-name {
				color: #fff;
			}
			.pre.sf-dump .sf-dump-public {
				color: #fff;
			}
			.pre.sf-dump .sf-dump-value {
				color: #56DB3A;
				font-weight: bold;
			}
		</style>`
)

// Debug
//
// Returns a pretty print of the interface passed.
// This function is a shortcut for fmt.Sprintf
//
// Example: {{ debug .Post }}
func (ns *Namespace) Debug(i interface{}) template.HTML {
	return template.HTML(fmt.Sprintf("%+v\n", i))
}

// Dump
//
// Marshals indents the struct and wraps the string
// inside a div with CSS attached.
//
// Returns errors.TEMPLATE if the marshal failed.
//
// Example: {{ dump .Post }}
func (ns *Namespace) Dump(i interface{}) (template.HTML, error) {
	const op = "Templates.Dump"

	b, err := json.MarshalIndent(i, "", "\t")
	if err != nil {
		return "", &errors.Error{Code: errors.TEMPLATE, Message: "Unable to par", Operation: op, Err: err}
	}

	el := fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, string(b))

	return template.HTML(el), nil
}"
}
{
file:./api/tpl/funcs/debug/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package debug

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new debug Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for debug to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "paths"

// Adds the namespace debug to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Debug,
			"debug",
			nil,
			[][2]string{},
		)

		ns.AddMethodMapping(ctx.Dump,
			"dump",
			nil,
			[][2]string{},
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/tpl/funcs/debug/debug_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package debug

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/stretchr/testify/assert"
	"html/template"
	"testing"
)

var (
	ns = New(&deps.Deps{})
)

func TestNamespace_Debug(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  template.HTML
	}{
		"String": {
			"test",
			template.HTML("test\n"),
		},
		"Int": {
			1,
			template.HTML("1\n"),
		},
		"Slice": {
			[]interface{}{"test", 123},
			template.HTML("[test 123]\n"),
		},
		"Map": {
			map[string]interface{}{"test": 123},
			template.HTML("map[test:123]\n"),
		},
		"Struct": {
			struct{ Test string }{Test: "test"},
			template.HTML("{Test:test}\n"),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got := ns.Debug(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}

func TestNamespace_Dump(t *testing.T) {

	tt := map[string]struct {
		input interface{}
		want  interface{}
	}{
		"String": {
			"test",
			template.HTML(fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, `"test"`)),
		},
		"Int": {
			1,
			template.HTML(fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, `1`)),
		},
		"Slice": {
			[]interface{}{"test", 123},
			template.HTML(fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, "[\n\t\"test\",\n\t123\n]")),
		},
		"Map": {
			map[string]interface{}{"test": 123},
			template.HTML(fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, "{\n\t\"test\": 123\n}")),
		},
		"Struct": {
			struct{ Test string }{Test: "test"},
			template.HTML(fmt.Sprintf(`%s<pre class="sf-dump">%s</pre>`, CSS, "{\n\t\"Test\": \"test\"\n}")),
		},
		"Error": {
			map[string]interface{}{"foo": make(chan int)},
			"Templates.Dump: json: unsupported type: chan int",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ns.Dump(test.input)
			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/media/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package media

import (
	"github.com/spf13/cast"
)

// Find
//
// Obtains the media by ID and returns a domain.Media type
// or nil if not found or the ID parameter failed to be
// parsed.
//
// Example:
// {{ $image := media 10 }}
// {{ $image.Url }}
func (ns *Namespace) Find(i interface{}) interface{} {
	id, err := cast.ToIntE(i)
	if err != nil || i == nil {
		return nil
	}

	m, err := ns.deps.Store.Media.GetById(id)
	if err != nil {
		return nil
	}

	return m
}"
}
{
file:./api/tpl/funcs/media/init_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package media

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestNamespace_Init(t *testing.T) {
	var found bool
	var ns *internal.FuncsNamespace

	for _, nsf := range internal.GenericNamespaceRegistry {
		ns = nsf(&deps.Deps{})
		if ns.Name == name {
			found = true
			break
		}
	}

	assert.True(t, found)
	assert.Equal(t, &Namespace{&deps.Deps{}}, ns.Context())
}"
}
{
file:./api/tpl/funcs/media/media_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package media

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/stretchr/testify/assert"
	"testing"
)

type noStringer struct{}

func Setup() (*Namespace, *mocks.MediaRepository) {
	mock := &mocks.MediaRepository{}
	return &Namespace{deps: &deps.Deps{
		Store: &models.Store{
			Media: mock,
		},
	}}, mock
}

func TestNamespace_Find(t *testing.T) {

	media := domain.Media{
		Id:  1,
		Url: "/uploads/test.jpg",
	}

	id := 1
	idFloat32 := float32(1)
	idFloat64 := float64(1)

	tt := map[string]struct {
		input interface{}
		mock  func(m *mocks.MediaRepository)
		want  interface{}
	}{
		"Success": {
			1,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"No Item": {
			1,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("no media"))
			},
			nil,
		},
		"nil": {
			nil,
			func(m *mocks.MediaRepository) {
				m.On("GetById", nil).Return(domain.Media{}, fmt.Errorf("no media"))
			},
			nil,
		},
		"int": {
			id,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"*int": {
			&id,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"float32": {
			idFloat32,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"*float32": {
			&idFloat32,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"float64": {
			idFloat64,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"*float64": {
			&idFloat64,
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(media, nil)
			},
			media,
		},
		"string": {
			"wrongval",
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("no media"))
			},
			nil,
		},
		"noStringer": {
			noStringer{},
			func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("no media"))
			},
			nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			ns, mock := Setup()
			test.mock(mock)
			got := ns.Find(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/tpl/funcs/media/init.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package media

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/tpl/internal"
)

// Creates a new media Namespace
func New(d *deps.Deps) *Namespace {
	return &Namespace{deps: d}
}

// Namespace defines the methods for media items to be used
// as template functions.
type Namespace struct {
	deps *deps.Deps
}

const name = "media"

// Adds the namespace methods to the internal.FuncsNamespace
// on initialisation.
func init() {
	f := func(d *deps.Deps) *internal.FuncsNamespace {
		ctx := New(d)

		ns := &internal.FuncsNamespace{
			Name:    name,
			Context: func(args ...interface{}) interface{} { return ctx },
		}

		ns.AddMethodMapping(ctx.Find,
			"media",
			nil,
			nil,
		)

		return ns
	}

	internal.AddFuncsNamespace(f)
}"
}
{
file:./api/render/headers_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

// TestHeaders_Cache - Test of cache headers
func TestHeaders_Cache(t *testing.T) {

	tt := map[string]struct {
		url     string
		want    string
		options domain.Options
	}{
		"Max Age": {
			want: "max-age=1000, public",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "max-age",
				CacheFrontendExtension: []string{"jpg"},
				CacheFrontendSeconds:   1000,
			},
		},
		"Max Stale": {
			want: "max-stale=1000, public",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "max-stale",
				CacheFrontendExtension: []string{"jpg"},
				CacheFrontendSeconds:   1000,
			},
		},
		"Min Fresh": {
			want: "min-fresh=1000, public",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "min-fresh",
				CacheFrontendExtension: []string{"jpg"},
				CacheFrontendSeconds:   1000,
			},
		},
		"No Cache": {
			want: "no-cache",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "no-cache",
				CacheFrontendExtension: []string{"jpg"},
			},
		},
		"No Store": {
			want: "no-store",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "no-store",
				CacheFrontendExtension: []string{"jpg"},
			},
		},
		"No Transform": {
			want: "no-transform",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "no-transform",
				CacheFrontendExtension: []string{"jpg"},
			},
		},
		"Only If Cached": {
			want: "only-if-cached",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "only-if-cached",
				CacheFrontendExtension: []string{"jpg"},
			},
		},
		"Cache Disabled": {
			want: "",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend: false,
			},
		},
		"Admin": {
			want: "",
			url:  "/admin",
			options: domain.Options{
				CacheFrontend: true,
			},
		},
		"Wrong Request": {
			want: "max-age=1000, public",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "wrongval",
				CacheFrontendExtension: []string{"jpg"},
				CacheFrontendSeconds:   1000,
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)
			gin.DefaultWriter = ioutil.Discard
			r := gin.Default()

			h := newHeaders(test.options)

			server := httptest.NewServer(r)
			defer server.Close()
			url := "http://" + server.Listener.Addr().String() + test.url

			r.GET("/assets/*any", func(context *gin.Context) {
				h.Cache(context)
			})

			client := &http.Client{}
			req, err := http.NewRequest("GET", url, nil)
			assert.NoError(t, err)

			get, err := client.Do(req)
			assert.NoError(t, err)

			o := get.Header.Get("Cache-Control")
			assert.Equal(t, test.want, o)
		})
	}
}"
}
{
file:./api/render/page.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/recovery"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/gin-gonic/gin"
	"net/http"
	"net/url"
	"path"
	"path/filepath"
	"strings"
)

func (r *Render) Page(g *gin.Context) ([]byte, error) {
	const op = "Render.GetPage"

	api.ServeChan <- 1
	defer func() {
		<-api.ServeChan
	}()

	//url := g.Request.URL.Path
	url, hasRedirected := r.handleTrailingSlash(g)
	if hasRedirected {
		return nil, nil
	}

	post, err := r.Store.Posts.GetBySlug(url)
	if err != nil {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("No page found with the url: %s", url), Operation: op, Err: err}
	}

	// Check if the file has been cached
	var foundCache bool
	cacheKey := cache.GetPostKey(post.Id)
	if r.Options.CacheServerTemplates {
		var cachedTemplate interface{}
		cachedTemplate, foundCache = cache.Store.Get(cacheKey)

		if cachedTemplate != nil && foundCache {
			return cachedTemplate.([]byte), nil
		}
	}

	// Check if the resource is public
	resource := post.Resource
	if resource != nil {
		for _, v := range r.Theme.Resources {
			if v.Hidden && v.Name == *resource {
				return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("The post resource is not public: %v", resource), Operation: op, Err: err}
			}
		}
	}

	_, err = g.Cookie("verbis-session")
	if err != nil && post.Status != "published" {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Page not published, or user is not logged in", Operation: op, Err: err}
	}

	// TODO this should be in tpl
	pt := "index"
	if post.PageTemplate != "default" {
		pt = r.Theme.TemplateDir + "/" + post.PageTemplate
	}

	master := ""
	if post.PageLayout != "default" {
		master = r.Theme.LayoutDir + "/" + post.PageLayout
	} else {
		pt = pt + r.Theme.FileExtension
	}

	exec := r.Tmpl().Prepare(&tpl.Config{
		Root:      paths.Theme(),
		Extension: r.Theme.FileExtension,
		Master:    master,
	})

	var b bytes.Buffer
	failedTpl, err := exec.ExecutePost(&b, pt, g, &post)
	if err != nil {
		return recovery.New(r.Deps).Recover(recovery.Config{
			Code:    http.StatusInternalServerError,
			Context: g,
			Error:   err,
			TplFile: failedTpl,
			TplExec: exec,
			Post:    &post,
		}), err
	}

	minified, err := r.minify.MinifyBytes(&b, "text/html")
	if err != nil || minified == nil {
		return b.Bytes(), nil
	}

	go func() {
		if r.Options.CacheServerTemplates && !foundCache {
			cache.Store.Set(cacheKey, minified, cache.RememberForever)
		}
	}()

	return minified, nil
}

func (r *Render) handleTrailingSlash(g *gin.Context) (string, bool) {
	p := g.Request.URL.Path

	// True if options enforce slash is set in admin
	trailing := r.Options.SeoEnforceSlash
	lastChar := p[len(p)-1:]

	uri, err := url.Parse(p)
	if err != nil {
		return p, false
	}

	base := path.Base(uri.Path)
	ext := filepath.Ext(base)
	if ext != "" {
		return p, false
	}

	// Must be homepage
	if p == "/" {
		return "/", false
	}

	if lastChar != "/" && trailing {
		g.Redirect(301, p+"/")
		return "", true
	}

	if lastChar == "/" && !trailing {
		g.Redirect(301, strings.TrimSuffix(p, "/"))
		return "", true
	}

	if lastChar == "/" {
		p = strings.TrimSuffix(p, "/")
	}

	return p, false
}"
}
{
file:./api/render/sitemap.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/models"
	"io/ioutil"
	"time"
)

// TODO
//
// - Add images to the pages array by scanning the getField function as well as the <img>'s
// - Split the sitemaps up into 49,999 chunks
// - Add sitemap-index & move to web with XSL.
// - Viewdata & pages should be private, no need to expose.

// SiteMapper represents functions for executing the sitemap data.
type SiteMapper interface {
	GetIndex() ([]byte, error)
	GetPages(resource string) ([]byte, error)
	GetXSL(index bool) ([]byte, error)
	ClearCache()
}

// Sitemap represents the generation of sitemap.xml files for use
// with the sitemap controller.
type Sitemap struct {
	store        *models.Store
	options      domain.Options
	resources    map[string]domain.Resource
	templatePath string
	indexXSL     string
	resourceXSL  string
}

// index defines the the XML data for rendering a the main (index) sitemap.
type index struct {
	XMLName xml.Name   `xml:"http://www.sitemaps.org/schemas/sitemap/0.9 sitemapindex"`
	Items   []viewItem `xml:"sitemap"`
}

// resources defines the the XML data for rendering a resource sitemap.
type resources struct {
	XMLName           xml.Name   `xml:"http://www.sitemaps.org/schemas/sitemap/0.9 urlset"`
	XMLNSImage        string     `xml:"xmlns:image,attr"`
	XSI               string     `xml:"xmlns:xsi,attr"`
	XSISchemaLocation string     `xml:"xsi:schemaLocation,attr"`
	Items             []viewItem `xml:"url"`
}

// TODO! Add images
type image struct {
	Slug      string `xml:"loc"`
	CreatedAt string `xml:"lastmod"`
}

// sitemapViewItem defines the array of posts or items for both
// the index sitemap & resources sitemap.
type viewItem struct {
	Slug      string   `xml:"loc"`
	CreatedAt string   `xml:"lastmod"`
	Image     *[]image `xml:"image"`
}

const (
	// MAPLIMIT defines how many items can be used within a
	// sitemap.xml before splitting into a new one.
	MAPLIMIT = 49999
)

// NewSitemap - Construct
func NewSitemap(m *models.Store) *Sitemap {
	const op = "SiteMapper.NewSitemap"

	theme := m.Site.GetThemeConfig()

	// TODO: Causing issue! Returning pages to frontend?
	//resources := theme.Resources
	//resources["pages"] = domain.Resource{
	//	Name:         "pages",
	//	Slug: 			"/pages",
	//}

	s := &Sitemap{
		store:        m,
		options:      m.Options.GetStruct(),
		resources:    theme.Resources,
		templatePath: paths.Api() + "/web/sitemaps/",
		indexXSL:     "main-sitemap.xsl",
		resourceXSL:  "resource-sitemap.xsl",
	}

	return s
}

// GetIndex first checks to see if the sitemap serving is enabled in the
// options, then goes on to retrieve the pages. Template data is then
// constructed and executed.
//
// Returns errors.CONFLICT if the sitemap serve options was not enabled.
func (s *Sitemap) GetIndex() ([]byte, error) {
	const op = "SiteMapper.GetIndex"

	if !s.options.SeoSitemapServe {
		return nil, &errors.Error{Code: errors.CONFLICT, Message: "Sitemap should not be served due to user options preferences", Operation: op, Err: fmt.Errorf("sitemap could not be served due to preferences")}
	}

	if cached := s.getCachedFile("sitemap-index"); cached != nil {
		return cached, nil
	}

	viewData := index{}
	for _, v := range s.resources {
		posts, err := s.retrievePages(v.Name)
		if err != nil || len(posts) == 0 {
			continue
		}

		viewData.Items = append(viewData.Items, viewItem{
			Slug:      s.options.SiteUrl + "/sitemaps" + v.Slug + "/sitemap.xml",
			CreatedAt: time.Now().Format(time.RFC3339),
		})
	}

	if s.hasRedirects() {
		viewData.Items = append(viewData.Items, viewItem{
			Slug:      s.options.SiteUrl + "/sitemaps/redirects/sitemap.xml",
			CreatedAt: time.Now().Format(time.RFC3339),
		})
	}

	xmlData, err := s.formatXML(viewData, true)
	if err != nil {
		return nil, err
	}

	go cache.Store.Set("sitemap-index", &xmlData, cache.RememberForever)

	return xmlData, nil
}

// GetXSL reads the main index XSL file from the sitemaps template
// path for use with the sitemap-xml file.
//
// Returns errors.INTERNAL if the ioutil function failed to read the path.
func (s *Sitemap) GetXSL(index bool) ([]byte, error) {
	const op = "SiteMapper.GeXLS"

	fileName := s.indexXSL
	if !index {
		fileName = s.resourceXSL
	}

	if cached := s.getCachedFile(fileName); cached != nil {
		return cached, nil
	}

	path := s.templatePath + fileName
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to read the xsl file with the path: %s", path), Operation: op, Err: err}
	}

	go cache.Store.Set(fileName, &data, cache.RememberForever)

	return data, nil
}

// GetPages first checks to see if the sitemap serving is enabled in the
// options, then goes on to retrieve the pages. Template data is then
// constructed and executed.
//
// Returns errors.CONFLICT if the sitemap serve options was not enabled.
// Returns errors.INTERNAL if the pages template was unable to be executed.
// Returns errors.NOTFOUND if the given resource was not found within the resource or redirects.
func (s *Sitemap) GetPages(resource string) ([]byte, error) {
	const op = "SiteMapper.GetPages"

	if !s.options.SeoSitemapServe {
		return nil, &errors.Error{Code: errors.CONFLICT, Message: "Sitemap should not be served due to user options preferences", Operation: op, Err: fmt.Errorf("sitemap could not be served due to preferences")}
	}

	if err := s.canServeResource(resource); err != nil {
		return nil, err
	}

	viewData := resources{}
	viewData.XSI = "http://www.w3.org/2001/XMLSchema-instance"
	viewData.XMLNSImage = "http://www.google.com/schemas/sitemap-image/1.1"
	viewData.XSISchemaLocation = "http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd http://www.google.com/schemas/sitemap-image/1.1 http://www.google.com/schemas/sitemap-image/1.1/sitemap-image.xsd"

	if resource == "redirects" {
		viewData.Items = s.getRedirects()
	} else {
		posts, err := s.retrievePages(resource)
		if err != nil {
			return nil, err
		}

		if len(posts) == 0 {
			return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("No resource items available with the name: %s", resource), Operation: op, Err: fmt.Errorf("no resource items found")}
		}

		for _, v := range posts {
			viewData.Items = append(viewData.Items, viewItem{
				Slug:      v.Slug,
				CreatedAt: time.Now().Format(time.RFC3339),
			})
		}
	}

	xmlData, err := s.formatXML(viewData, true)
	if err != nil {
		return nil, err
	}

	return xmlData, nil
}

// ClearCache - Clears all of the cached data from the index.xml file
// as well as the resources xml files.
//
// Returns no error.
func (s *Sitemap) ClearCache() {
	cache.Store.Delete("sitemap-index")
	for _, v := range s.resources {
		cache.Store.Delete("sitemap-" + v.Name)
	}
}

// getPosts obtains all of the posts for the sitemap in created at
// descending order.
// Returns errors.INTERNAL if the posts could not be retrieved from the store.
func (s *Sitemap) retrievePages(resource string) ([]viewItem, error) {
	const op = "SiteMapper.retrievePages"

	posts, _, err := s.store.Posts.Get(params.Params{
		Page:           1,
		Limit:          0,
		LimitAll:       true,
		OrderDirection: "desc",
		OrderBy:        "created_at",
	}, false, resource, "published")

	if err != nil {
		return nil, err
	}

	var items []viewItem
	for _, v := range posts {
		resource := ""
		if v.Resource == nil {
			resource = "pages"
		} else {
			resource = *v.Resource
		}

		exclude := false
		if v.SeoMeta.Seo != nil {
			exclude = v.SeoMeta.Seo.ExcludeSitemap
		}

		if !helpers.StringInSlice(resource, s.options.SeoSitemapExcluded) && !exclude {
			items = append(items, viewItem{
				Slug:      s.options.SiteUrl + v.Slug,
				CreatedAt: v.CreatedAt.Format(time.RFC3339),
			})
		}
	}

	return items, nil
}

// getRedirects first checks to see if the sitemap redirect serving
// is enabled in the options and the sets the view data to the range
// loop.
//
// Returns []sitemapViewItem containing slug & created at date.
func (s *Sitemap) getRedirects() []viewItem {
	var data []viewItem
	if s.options.SeoSitemapRedirects {
		for _, v := range s.options.SeoRedirects {
			data = append(data, viewItem{
				Slug:      v.From,
				CreatedAt: time.Now().Format(time.RFC3339),
			})
		}
	}
	return data
}

// hasRedirects determines if there is any redirects set in the options.
//
// Returns true if found.
func (s *Sitemap) hasRedirects() bool {
	return len(s.getRedirects()) > 0
}

// canServeResource - Determines if the resource passed exists in the
// sitemap struct or if the resource is a redirect & there are
// redirect items to serve.
//
// Returns errors.NOTFOUND if there was no matching resource found.
func (s *Sitemap) canServeResource(resource string) error {
	const op = "SiteMapper.canServeResource"

	found := false
	for _, v := range s.resources {
		if v.Name == resource {
			found = true
		}
	}

	if resource == "redirects" && s.hasRedirects() {
		found = true
	}

	if !found {
		return &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("No resource available with the name: %s", resource), Operation: op, Err: fmt.Errorf("no resource found")}
	}

	return nil
}

// getHomeCreatedAt - Get the homepage created at time or now if it
// is not set.
func (s *Sitemap) getHomeCreatedAt() string {
	home, err := s.store.Posts.GetBySlug("/")
	createdAt := time.Now().Format(time.RFC3339)
	if err == nil {
		createdAt = home.CreatedAt.Format(time.RFC3339)
	}
	return createdAt
}

// formatXML - Formats the XML []byte passed and adds headers to the
// XML file, if the sitemap is index, a different xsl file header
// will be appended.
//
// Returns back a []byte once formatted.
func (s *Sitemap) formatXML(data interface{}, index bool) ([]byte, error) {
	const op = "SiteMapper.formatXML"

	xmlString, err := xml.MarshalIndent(data, "", "    ")
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to execute the sitemap XML", Operation: op, Err: err}
	}

	var b bytes.Buffer
	b.WriteString(xml.Header)

	if index {
		b.WriteString(fmt.Sprintf(`<?xml-stylesheet type="text/xsl" href="%s/main-sitemap.xsl"?>`+"\n", s.options.SiteUrl))
	} else {
		b.WriteString(fmt.Sprintf(`<?xml-stylesheet type="text/xsl" href="%s/resources-sitemap.xsl"?>`+"\n", s.options.SiteUrl))
	}

	b.Write(xmlString)
	b.WriteString("\n")
	b.WriteString("<!-- XML Sitemap generated by Verbis -->")

	return b.Bytes(), nil
}

// getCachedFile -Obtains the cached sitemap xml file by key
//
// Returns [[byte if found or nil.
func (s *Sitemap) getCachedFile(key string) []byte {
	cachedIndex, found := cache.Store.Get(key)
	if found {
		cachedBytes := cachedIndex.(*[]byte)
		return *cachedBytes
	}
	return nil
}"
}
{
file:./api/render/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import "github.com/ainsleyclark/verbis/api/cache"

// GetCachedAsset checks to see if there is a cached version of the file
// and mimetypes, returns nil for both if nothing was found.
func (r *Render) getCachedAsset(url string) (*[]byte, *string) {

	if r.Options.CacheServerAssets {
		return nil, nil
	}

	file, foundFile := cache.Store.Get(url)
	mimeType, foundMime := cache.Store.Get(url + "mimetype")

	if foundFile && foundMime {
		file := file.(*[]byte)
		mimeType := mimeType.(*string)
		return file, mimeType
	}

	return nil, nil
}"
}
{
file:./api/render/renderer.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/minify"
	"github.com/gin-gonic/gin"
)

// Renderer
type Renderer interface {
	Asset(g *gin.Context) (*string, *[]byte, error)
	Upload(g *gin.Context) (*string, *[]byte, error)
	Page(g *gin.Context) ([]byte, error)
	NotFound(g *gin.Context)
}

// Render
type Render struct {
	*deps.Deps
	minify minify.Minifier
	cacher headerWriter
}

// NewRender - Construct
func NewRender(d *deps.Deps) *Render {
	options := d.Store.Options.GetStruct()
	return &Render{
		d,
		minify.New(minify.Config{
			MinifyHTML: options.MinifyHTML,
			MinifyCSS:  options.MinifyCSS,
			MinifyJS:   options.MinifyJS,
			MinifySVG:  options.MinifySVG,
			MinifyJSON: options.MinifyJSON,
			MinifyXML:  options.MinifyXML,
		}),
		newHeaders(options),
	}
}"
}
{
file:./api/render/assets.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"bytes"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/mime"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/helpers/webp"

	"github.com/gin-gonic/gin"
	"io/ioutil"
	"path/filepath"
	"strings"
)

// Asset
//
// It then obtains the assets path from the site model, and then checks
// if the file exists, by opening the file, if it doesnt it will
// return a 404.
// It then sets cache headers using the cacher interface & checks if a webp
// image is available with the path of .jpg.webp. The minify is the used
// to see if the file can be minfied.
func (r *Render) Asset(g *gin.Context) (*string, *[]byte, error) {
	const op = "Render.GetAsset"

	url := g.Request.URL.Path

	// Check if the file has been cached
	var cachedFile *[]byte
	var cachedMime *string
	if r.Options.CacheServerAssets {
		cachedFile, cachedMime = r.getCachedAsset(url)
		if cachedFile != nil && cachedMime != nil {
			return cachedMime, cachedFile, nil
		}
	}

	// Get the relevant paths
	assetsPath := paths.Theme() + r.Theme.AssetsPath
	fileName := strings.Replace(url, "/assets", "", 1)
	mimeType := mime.TypeByExtension(strings.Replace(filepath.Ext(fileName), ".", "", 1))

	file, err := ioutil.ReadFile(assetsPath + fileName)
	if err != nil {
		return nil, nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to read the file with the path: %s", assetsPath+fileName), Operation: op, Err: err}
	}

	// Set the cache if options allow
	defer func() {
		go func() {
			if r.Options.CacheServerAssets && cachedFile == nil {
				cache.Store.Set(url, &file, cache.RememberForever)
				cache.Store.Set(url+"mimetype", &mimeType, cache.RememberForever)
			}
		}()
	}()

	// Set cache headers
	r.cacher.Cache(g)

	// Check if the serving of webp's is allowed & get the
	// webp images and assign if not nil
	if r.Options.MediaServeWebP && webp.Accepts(g) {
		webpFile := webp.GetData(g, assetsPath+fileName, mimeType)
		if webpFile != nil {
			mimeType = "image/webp"
			file = webpFile
		}
	}

	// If the minified file is nil or the err is not empty, serve the original data
	minifiedFile, err := r.minify.MinifyBytes(bytes.NewBuffer(file), mimeType)
	if err != nil || minifiedFile != nil {
		file = minifiedFile
	}

	return &mimeType, &file, nil
}"
}
{
file:./api/render/assets_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestRender_GetAsset(t *testing.T) {

	cache.Init()

	tt := map[string]struct {
		url     string
		want    string
		options domain.Options
	}{
		"Minified": {
			want: "max-age=1000, public",
			url:  "/assets/images/test.jpg",
			options: domain.Options{
				CacheFrontend:          true,
				CacheFrontendRequest:   "max-age",
				CacheFrontendExtension: []string{"jpg"},
				CacheFrontendSeconds:   1000,
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {

			gin.SetMode(gin.TestMode)
			gin.DefaultWriter = ioutil.Discard
			r := gin.Default()

			h := newHeaders(test.options)

			server := httptest.NewServer(r)
			defer server.Close()
			url := "http://" + server.Listener.Addr().String() + test.url

			r.GET("/assets/*any", func(context *gin.Context) {
				h.Cache(context)
			})

			client := &http.Client{}
			req, err := http.NewRequest("GET", url, nil)
			assert.NoError(t, err)

			get, err := client.Do(req)
			assert.NoError(t, err)

			o := get.Header.Get("Cache-Control")
			assert.Equal(t, test.want, o)
		})
	}
}"
}
{
file:./api/render/headers.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/gin-gonic/gin"
	"path/filepath"
	"strconv"
	"strings"
)

// Cacher represents the cache function to set cache headers.
type headerWriter interface {
	Cache(g *gin.Context)
}

// Headers represents the the header struct for setting gin headers
// for frontend caching.
type headers struct {
	options domain.Options
}

// NewCache - Construct
func newHeaders(o domain.Options) *headers {
	return &headers{
		options: o,
	}
}

// Cache
//
// Returns if the asset is with path of admin or the caching
// is disabled in the options.
// Sets the gin headers if extensions are allowed.
func (c *headers) Cache(g *gin.Context) {
	const op = "Cacher.Cache"

	// Bail if the cache frontend is disabled
	if !c.options.CacheFrontend {
		return
	}

	path := g.Request.URL.Path

	// Don't cache any admin assets
	if strings.Contains(path, "admin") {
		return
	}

	// Get the expiration
	expiration := c.options.CacheFrontendSeconds

	// Get the request type
	request := c.options.CacheFrontendRequest
	allowedRequest := []string{"max-age", "max-stale", "min-fresh", "no-cache", "no-store", "no-transform", "only-if-cached"}
	if request == "" || !helpers.StringInSlice(request, allowedRequest) {
		request = "max-age"
	}

	// Get the extensions to be cached
	extensionsAllowed := c.options.CacheFrontendExtension
	extension := filepath.Ext(path)

	// Check if the extensions
	if len(extensionsAllowed) > 0 {
		for _, v := range extensionsAllowed {
			if extension == "."+v {
				cache := ""
				if request == "max-age" || request == "min-fresh" || request == "max-stale" {
					cache = fmt.Sprintf("%s=%s, %s", request, strconv.FormatInt(expiration, 10), "public")
				} else {
					cache = request
				}
				g.Header("Cache-Control", cache)
			}
		}
	}
}"
}
{
file:./api/render/uploads.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"bytes"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/helpers/webp"
	"github.com/gin-gonic/gin"
)

func (r *Render) Upload(g *gin.Context) (*string, *[]byte, error) {
	const op = "Render.Upload"

	url := g.Request.URL.Path

	api.UploadChan <- 1
	defer func() {
		<-api.UploadChan
	}()

	// Check if the file has been cached
	var cachedFile *[]byte
	var cachedMime *string
	if r.Options.CacheServerUploads {
		cachedFile, cachedMime = r.getCachedAsset(url)
		if cachedFile != nil && cachedMime != nil {
			return cachedMime, cachedFile, nil
		}
	}

	// Set cache headers
	r.cacher.Cache(g)

	// Get the data & mime type from the media store
	file, mimeType, err := r.Store.Media.Serve(url, webp.Accepts(g))
	if err != nil {
		return nil, nil, err
	}

	// Set the cache if the app is in production
	defer func() {
		go func() {
			if r.Options.CacheServerUploads && cachedFile == nil {
				cache.Store.Set(url, &file, cache.RememberForever)
				cache.Store.Set(url+"mimetype", &mimeType, cache.RememberForever)
			}
		}()
	}()

	// If the minified file is nil or the err is not empty, serve the original data
	minifiedFile, err := r.minify.MinifyBytes(bytes.NewBuffer(file), mimeType)
	if err != nil || minifiedFile != nil {
		file = minifiedFile
	}

	return &mimeType, &file, nil
}"
}
{
file:./api/render/errors.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package render

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/tpl"
	"github.com/gin-gonic/gin"
	"github.com/gookit/color"
)

type ErrorHandler interface {
	NotFound(g *gin.Context)
}

type Errors struct {
	*deps.Deps
}

func (r *Render) NotFound(g *gin.Context) {

	exec := r.Tmpl().Prepare(tpl.Config{
		Root:      paths.Theme(),
		Extension: r.Theme.FileExtension,
		Master:    "",
	})

	_, err := exec.ExecutePost(g.Writer, "404", g, &domain.PostData{})

	if err != nil {
		color.Green.Println(err)
	}

	return
}"
}
{
file:./api/server/server.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package server

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	//"github.com/ainsleyclark/verbis/api/http/csrf"
	//"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-contrib/gzip"
	"github.com/gin-contrib/location"
	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/cookie"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"os"
	"strconv"
	"syscall"
)

type Server struct {
	*gin.Engine
}

func New(m models.OptionsRepository) *Server {

	// Force log's color
	gin.ForceConsoleColor()

	// Set mode depending on
	gin.SetMode(gin.ReleaseMode)

	// Remove default gin write
	gin.DefaultWriter = ioutil.Discard

	// New router
	r := gin.Default()

	server := &Server{r}

	r.Use(location.Default())

	// Recovery middleware recovers from any panics and writes a 500 if there was one.
	// TODO: Is this required?
	server.Use(gin.Recovery())

	// Set up Gzip compression
	server.setupGzip(m)

	store := cookie.NewStore([]byte("verbis"))
	r.Use(sessions.Sessions("csrf", store))

	// Instantiate the server.
	return server
}

func SendRestart() {
	if proc, err := os.FindProcess(os.Getpid()); err != nil {
		log.Printf("FindProcess: %s", err)
		return
	} else {
		_ = proc.Signal(syscall.Signal(0x1))
	}
}

// ListenAndServe runs Verbis on a given port
// Returns errors.INVALID if the server could not start
func (s *Server) ListenAndServe(port int) error {
	const op = "router.ListenAndServe"

	passedPort := strconv.Itoa(port)

	err := s.Run(":" + passedPort)
	if err != nil {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("Could not start Verbis on the port %d", port), Operation: op, Err: err}
	}

	return nil
}

// setupGzip - inits the default gzip compression for the server bt
// looking for the options & setting.
func (s *Server) setupGzip(o models.OptionsRepository) {
	const op = "router.ListenAndServe"

	options := o.GetStruct()

	// Bail if there is no
	if !options.Gzip {
		return
	}

	/// Set the default compression & check options
	compression := gzip.DefaultCompression
	switch options.GzipCompression {
	case "best-compression":
		{
			compression = gzip.BestCompression
			break
		}
	case "best-speed":
		{
			compression = gzip.BestSpeed
			break
		}
	}

	// If the use paths is not set, use the excluded extensions
	// or use the excluded paths.
	if !options.GzipUsePaths {
		if len(options.GzipExcludedExtensions) > 0 {
			s.Use(gzip.Gzip(compression, gzip.WithExcludedExtensions(options.GzipExcludedExtensions)))
			return
		}
	} else {
		if len(options.GzipExcludedPaths) > 0 {
			s.Use(gzip.Gzip(compression, gzip.WithExcludedPaths(options.GzipExcludedPaths)))
			return
		}
	}

	s.Use(gzip.Gzip(compression))
}"
}
{
file:./api/server/hammer_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package server

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"
	"testing"
)

var wg sync.WaitGroup
var errCountPhoto int
var errCountPage int
var photoErr error

func Test_Hammer(t *testing.T) {

	conn := 1000

	for i := 0; i < conn; i++ {
		wg.Add(1)

		//time.Sleep(time.Millisecond * 1)
		go runHammer(i)
	}

	wg.Wait()

	fmt.Println("-------- PHOTO --------")
	fmt.Println(errCountPhoto)
	fmt.Println("-------- PAGE --------")
	fmt.Println(errCountPage)
	fmt.Println("-------- ERROR --------")
	fmt.Println(photoErr)
}

func runHammer(i int) {
	defer func() {
		wg.Done()
	}()

	fmt.Println(i)

	req, err := http.Get("https://www.kentonline.co.uk/_media/img/360x0/FJ9UT3RA4IOEJ3EOJ38X.jpg")
	//req, err := http.Get("http://127.0.0.1:8080/uploads/2020/11/ainsphoto.jpg")
	if err != nil {
		fmt.Println("NUMBER: ")
		fmt.Println(i)
		photoErr = err
		errCountPhoto++
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	reqHtml, err := http.Get("https://staging.reddico.co.uk")
	//reqHtml, err := http.Get("http://127.0.0.1:8080/casestudies/case-study")
	if err != nil {
		fmt.Println(err)
		errCountPage++
		return
	}

	bodyHtml, err := ioutil.ReadAll(reqHtml.Body)
	if err != nil {
		fmt.Println(err)
	}

	var b = body
	var bHtml = bodyHtml
	_ = fmt.Errorf("%s%s", b, bHtml)
}"
}
{
file:./api/server/routes/spa.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package routes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/http/handler"
	"github.com/ainsleyclark/verbis/api/server"
)

// Vue (SPA) routes
func spa(d *deps.Deps, s *server.Server, c *handler.Handler) {
	spa := s.Group(d.Config.Admin.Path)
	{
		spa.GET("/*any", c.SPA.Serve)
		spa.GET("", c.SPA.Serve)
	}
}"
}
{
file:./api/server/routes/frontend.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package routes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/http/handler"
	"github.com/ainsleyclark/verbis/api/http/middleware"
	"github.com/ainsleyclark/verbis/api/recovery"
	"github.com/ainsleyclark/verbis/api/server"
	"github.com/gin-gonic/gin"
)

func frontend(d *deps.Deps, s *server.Server, c *handler.Handler) {

	s.Use(recovery.New(d).HttpRecovery())
	s.Use(middleware.Redirects(d.Options))

	// TODO: This check should be in config
	uploadPath := d.Config.Media.UploadPath
	if uploadPath == "" {
		uploadPath = "uploads"
	}

	_ = s.Group("")
	{
		// Serve assets
		s.GET("/assets/*any", c.Frontend.GetAssets)

		// Serve Verbis Assets
		s.Static("/verbis", paths.Api()+"/web/public")

		// Serve uploads
		s.GET("/"+uploadPath+"/*any", c.Frontend.GetUploads)

		// Robots
		s.GET("/robots.txt", c.SEO.Robots)

		// Sitemap
		s.GET("/sitemap.xml", c.SEO.SiteMapIndex)
		s.GET("/sitemaps/:resource/:map", c.SEO.SiteMapResource)
		s.GET("/resource-sitemap.xsl", func(g *gin.Context) {
			c.SEO.SiteMapXSL(g, true)
		})
		s.GET("/main-sitemap.xsl", func(g *gin.Context) {
			c.SEO.SiteMapXSL(g, false)
		})

		// Favicon
		s.StaticFile("/favicon.ico", paths.Theme()+"/favicon.ico")

		// Serve the front end
		s.NoRoute(c.Frontend.Serve)
	}
}"
}
{
file:./api/server/routes/loader.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package routes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/http/handler"
	"github.com/ainsleyclark/verbis/api/http/middleware"
	"github.com/ainsleyclark/verbis/api/server"
)

// Load all of the routes groups specified in the package
// And any global middleware to be used on the server.
func Load(d *deps.Deps, s *server.Server, c *handler.Handler) {

	// Global middleware
	s.Use(middleware.Log())
	s.Use(middleware.CORS())

	// Load routes
	api(d, s, c)
	frontend(d, s, c)
	spa(d, s, c)
}"
}
{
file:./api/server/routes/api.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package routes

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/http/handler"
	"github.com/ainsleyclark/verbis/api/http/middleware"
	"github.com/ainsleyclark/verbis/api/server"
)

func api(d *deps.Deps, s *server.Server, c *handler.Handler) {

	// API Routes
	api := s.Group("/api/v1")
	{
		// Set API Middleware
		api.Use(middleware.EmptyBody())

		// Site
		api.GET("/site", c.Site.GetSite)

		// Auth
		api.POST("/login", c.Auth.Login)
		api.POST("/logout", c.Auth.Logout)
		api.POST("/password/reset", c.Auth.ResetPassword)
		api.POST("/password/email", c.Auth.SendResetPassword)
		api.GET("/password/verify/:token", c.Auth.VerifyPasswordToken)
		api.GET("/email/verify/:token", c.Auth.VerifyEmail)

		// Forms
		forms := api.Group("/forms")
		//forms.Use(csrf.Middleware(csrf.Options{
		//	Secret: "verbis",
		//	ErrorFunc: func(g *gin.Context) {
		//		respond.AbortJSON(g, 400, "CSRF token mismatch", nil)
		//		return
		//	},
		//}))

		forms.POST("/:uuid", c.Forms.Send)

		// Operator
		operator := api.Group("")
		{
			operator.Use(middleware.OperatorTokenCheck(d))
			operator.Use(middleware.SessionCheck(d))

			// Theme
			operator.GET("/theme", c.Site.GetTheme)

			// Templates
			operator.GET("/templates", c.Site.GetTemplates)

			// Layouts
			operator.GET("/layouts", c.Site.GetLayouts)

			// Posts
			operator.GET("/posts", c.Posts.Get)
			operator.GET("/posts/:id", c.Posts.GetById)
			operator.POST("/posts", c.Posts.Create)
			operator.PUT("/posts/:id", c.Posts.Update)
			operator.DELETE("/posts/:id", c.Posts.Delete)

			// Categories
			operator.GET("/categories", c.Categories.Get)
			operator.GET("/categories/:id", c.Categories.GetById)
			operator.POST("/categories", c.Categories.Create)
			operator.PUT("/categories/:id", c.Categories.Update)
			operator.DELETE("/categories/:id", c.Categories.Delete)

			// Media
			operator.GET("/media", c.Media.Get)
			operator.GET("/media/:id", c.Media.GetById)
			operator.POST("/media", c.Media.Upload)
			operator.PUT("/media/:id", c.Media.Update)
			operator.DELETE("/media/:id", c.Media.Delete)

			// Users
			operator.GET("/users", c.User.Get)
			operator.GET("/users/:id", c.User.GetById)
			operator.PUT("/users/:id", c.User.Update)
			operator.POST("/users/:id/reset-password", c.User.ResetPassword)

			// Fields
			operator.GET("/fields", c.Fields.Get)

			// Options
			operator.GET("/options", c.Options.Get)
			operator.GET("/options/:name", c.Options.GetByName)
			operator.POST("/options", c.Options.UpdateCreate)

			// Roles
			operator.GET("/roles", c.User.GetRoles)

			// Cache
			operator.POST("/cache", c.Cache.Clear)
		}

		// Administrator
		admin := api.Group("")
		{
			admin.Use(middleware.AdminTokenCheck(d))
			operator.Use(middleware.SessionCheck(d))

			// Users
			admin.POST("/users", c.User.Create)
			admin.DELETE("/users/:id", c.User.Delete)
		}
	}
}"
}
{
file:./api/models/roles.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/jmoiron/sqlx"
	log "github.com/sirupsen/logrus"
)

// RoleRepository defines methods for Posts to interact with the database
type RoleRepository interface {
	Get() ([]domain.UserRole, error)
	GetById(id int) (domain.UserRole, error)
	Create(r *domain.UserRole) (domain.UserRole, error)
	Update(r *domain.UserRole) (domain.UserRole, error)
	Delete(id int) error
	Exists(name string) bool
}

// PostStore defines the data layer for Posts
type RoleStore struct {
	db     *sqlx.DB
	config config.Configuration
}

// newRoles - Construct
func newRoles(db *sqlx.DB, config config.Configuration) *RoleStore {
	return &RoleStore{
		db:     db,
		config: config,
	}
}

// Get all roles
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no roles available.
func (s *RoleStore) Get() ([]domain.UserRole, error) {
	const op = "RoleRepository.Get"

	var r []domain.UserRole
	if err := s.db.Select(&r, "SELECT * FROM roles"); err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not get roles", Operation: op, Err: err}
	}

	if len(r) == 0 {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: "No roles available", Operation: op}
	}

	return r, nil
}

// Get the role by ID
// Returns errors.NOTFOUND if the post was not found by the given Id.
func (s *RoleStore) GetById(id int) (domain.UserRole, error) {
	const op = "RoleRepository.GetById"
	var r domain.UserRole
	if err := s.db.Get(&r, "SELECT * FROM roles WHERE id = ? LIMIT 1", id); err != nil {
		log.Info(err)
		return domain.UserRole{}, fmt.Errorf("Could not get role with the ID: %v", id)
	}
	return r, nil
}

// Create a new role
// Returns errors.CONFLICT if the the post slug already exists.
// Returns errors.INTERNAL if the SQL query was invalid or the function
// could not get the newly created ID.
func (s *RoleStore) Create(r *domain.UserRole) (domain.UserRole, error) {
	const op = "RoleRepository.Create"

	if s.Exists(r.Name) {
		return domain.UserRole{}, &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("Could not create the role, the name %v, already exists", r.Name), Operation: op}
	}

	q := "INSERT INTO roles (id, name, description) VALUES (?, ?, ?)"
	c, err := s.db.Exec(q, r.Id, r.Name, r.Description)
	if err != nil {
		return domain.UserRole{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the role with the name: %v", r.Name), Operation: op, Err: err}
	}

	id, err := c.LastInsertId()
	if err != nil {
		return domain.UserRole{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created post Role ID with the name: %v", r.Name), Operation: op, Err: err}
	}
	r.Id = int(id)

	return *r, nil
}

// Update role
// Returns errors.NOTFOUND if the role was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *RoleStore) Update(r *domain.UserRole) (domain.UserRole, error) {
	const op = "RoleRepository.Update"

	_, err := s.GetById(r.Id)
	if err != nil {
		return domain.UserRole{}, err
	}

	q := "UPDATE roles SET name = ?, description = ? WHERE id = ?"
	_, err = s.db.Exec(q, r.Name, r.Description)
	if err != nil {
		return domain.UserRole{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the role with the name: %v", r.Name), Operation: op, Err: err}
	}

	return *r, nil
}

// Delete role
// Returns errors.NOTFOUND if the role was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *RoleStore) Delete(id int) error {
	const op = "RoleRepository.Delete"

	_, err := s.GetById(id)
	if err != nil {
		return err
	}

	if _, err := s.db.Exec("DELETE FROM roles WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete the role with the ID: %v", id), Operation: op, Err: err}
	}

	return nil
}

// Exists Checks if a role exists by the given name
func (s *RoleStore) Exists(name string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM roles WHERE name = ?)", name).Scan(&exists)
	return exists
}"
}
{
file:./api/models/fields.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	location "github.com/ainsleyclark/verbis/api/fields/converter"
	"github.com/google/uuid"
	//"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/jmoiron/sqlx"
)

// FieldsRepository defines methods for Posts to interact with the database
type FieldsRepository interface {
	GetByPost(postId int) ([]domain.PostField, error)
	GetLayout(post domain.PostData) []domain.FieldGroup
	UpdateCreate(postId int, f []domain.PostField) error
	Create(f domain.PostField) (domain.PostField, error)
	Update(f domain.PostField) (domain.PostField, error)
	Exists(postId int, uuid uuid.UUID, key string) bool
}

// FieldsStore defines the data layer for Posts
type FieldsStore struct {
	db      *sqlx.DB
	config  config.Configuration
	options domain.Options
	finder  location.Finder
}

// newFields - Construct
func newFields(db *sqlx.DB, config config.Configuration) *FieldsStore {
	return &FieldsStore{
		db:      db,
		config:  config,
		options: newOptions(db, config).GetStruct(),
		finder:  location.NewLocation(),
	}
}

// UpdateCreate checks to see if the record exists before updating
// or creating the new record.
func (s *FieldsStore) UpdateCreate(postId int, f []domain.PostField) error {
	fields, err := s.GetByPost(postId)
	if err != nil {
		return err
	}

	// Find fields that should be deleted (not in the array)
	for _, v := range fields {
		if !s.shouldDelete(v, f) {
			err := s.Delete(postId, v)
			if err != nil {
				return err
			}
		}
	}

	// Update or create the existing fields passed.
	for _, v := range f {
		v.PostId = postId
		if s.Exists(postId, v.UUID, v.Key) {
			_, err := s.Update(v)
			if err != nil {
				return err
			}
		} else {
			_, err := s.Create(v)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// GetByPost fields by a post ID.
// Returns errors.NOTFOUND if there were no records found.
func (s *FieldsStore) GetByPost(postId int) ([]domain.PostField, error) {
	const op = "FieldsStore.GetByPost"
	var f []domain.PostField
	if err := s.db.Select(&f, "SELECT * FROM post_fields WHERE post_id = ?", postId); err != nil {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get post field with the ID: %d", postId), Operation: op, Err: err}
	}
	return f, nil
}

// GetByPost fields by a post ID and key.
// Returns errors.NOTFOUND if there were no records found.
func (s *FieldsStore) GetByPostAndKey(key string, postId int) (domain.PostField, error) {
	const op = "FieldsRepository.GetByPostAndKey"
	var f domain.PostField
	if err := s.db.Select(&f, "SELECT * FROM post_fields WHERE post_id = ? AND field_key = ? LIMIT = 1", postId, key); err != nil {
		return domain.PostField{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get post field with the page ID: %d and key: %s", postId, key), Operation: op, Err: err}
	}
	return f, nil
}

// Update a post field by Id
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *FieldsStore) Create(f domain.PostField) (domain.PostField, error) {
	const op = "FieldsRepository.Create"
	q := "INSERT INTO post_fields (uuid, post_id, type, name, value, field_key) VALUES (?, ?, ?, ?, ?, ?)"
	_, err := s.db.Exec(q, f.UUID.String(), f.PostId, f.Type, f.Name, f.OriginalValue, f.Key)
	if err != nil {
		return domain.PostField{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the post field wuth the name: %s", f.Name), Operation: op, Err: err}
	}
	return f, nil
}

// Update a post field by Id
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *FieldsStore) Update(f domain.PostField) (domain.PostField, error) {
	const op = "FieldsRepository.Update"
	_, err := s.db.Exec("UPDATE post_fields SET type = ?, name = ?, value = ?, field_key = ? WHERE uuid = ? AND post_id = ?", f.Type, f.Name, f.OriginalValue, f.Key, f.UUID.String(), f.PostId)
	if err != nil {
		return domain.PostField{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the post field wuth the uuid: %s", f.UUID.String()), Operation: op, Err: err}
	}
	return f, nil
}

// Update a post field by Id
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *FieldsStore) Delete(postId int, f domain.PostField) error {
	const op = "FieldsRepository.Delete"
	if _, err := s.db.Exec("DELETE FROM post_fields WHERE uuid = ? AND field_key = ? AND post_id = ?", f.UUID, f.Key, postId); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete post field with the uuid: %v", f.UUID), Operation: op, Err: err}
	}
	return nil
}

// Exists Checks if a post field exists by the given UUID and key
func (s *FieldsStore) Exists(postId int, uuid uuid.UUID, key string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM post_fields WHERE uuid = ? AND post_id = ? AND field_key = ?)", uuid.String(), postId, key).Scan(&exists)
	return exists
}

// GetLayout loops over all of the locations within the config json
// file that is defined. Produces an array of field groups that
// can be returned for the post
func (s *FieldsStore) GetLayout(post domain.PostData) []domain.FieldGroup {
	return s.finder.GetLayout(post, s.options.CacheServerFields)
}

// shouldDelete
// Finds fields in the domain.PostField array that should be deleted.
func (s *FieldsStore) shouldDelete(f domain.PostField, fields []domain.PostField) bool {
	for _, v := range fields {
		if (f.Key == v.Key) && (f.UUID == v.UUID) && (f.Name == v.Name) {
			return true
		}
	}
	return false
}"
}
{
file:./api/models/seo.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/jmoiron/sqlx"
)

// SeoMetaRepository defines methods for Posts to interact with the database
type SeoMetaRepository interface {
	UpdateCreate(id int, p domain.PostOptions) error
}

// SeoMetaStore defines the data layer for Seo & Meta Options
type SeoMetaStore struct {
	db *sqlx.DB
}

// newSeoMeta - Construct
func newSeoMeta(db *sqlx.DB) *SeoMetaStore {
	return &SeoMetaStore{
		db: db,
	}
}

// UpdateCreate checks to see if the record exists before updating
// or creating the new record.
func (s *SeoMetaStore) UpdateCreate(id int, p domain.PostOptions) error {
	if s.exists(id) {
		if err := s.update(id, p); err != nil {
			return err
		}
	} else {
		if err := s.create(id, p); err != nil {
			return err
		}
	}
	return nil
}

// Exists Checks if a seo meta record exists by Id
func (s *SeoMetaStore) exists(id int) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT post_id FROM post_options WHERE post_id = ?)", id).Scan(&exists)
	return exists
}

// create a new seo meta record
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *SeoMetaStore) create(id int, p domain.PostOptions) error {
	const op = "SeoMetaRepository.create"
	_, err := s.db.Exec("INSERT INTO post_options (post_id, seo, meta) VALUES (?, ?, ?)", id, p.Seo, p.Meta)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the seo meta options record with the post id: %d", id), Operation: op, Err: err}
	}
	return nil
}

// update a seo meta record by page Id
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *SeoMetaStore) update(id int, p domain.PostOptions) error {
	const op = "SeoMetaRepository.update"
	_, err := s.db.Exec("UPDATE post_options SET seo = ?, meta = ? WHERE post_id = ?", p.Seo, p.Meta, id)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the seo meta options with the post id: %d", id), Operation: op, Err: err}
	}
	return nil
}"
}
{
file:./api/models/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/mime"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/helpers/webp"
	"github.com/disintegration/imaging"
	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"
	"regexp"
	"strings"

	"github.com/jmoiron/sqlx"
	"image"
	"image/jpeg"
	"image/png"
	"io/ioutil"
	"mime/multipart"
	"os"
	"strconv"
	"time"
)

// MediaRepository defines methods for Media to interact with the database
type MediaRepository interface {
	Get(meta params.Params) ([]domain.Media, int, error)
	GetById(id int) (domain.Media, error)
	GetByName(name string) (domain.Media, error)
	GetByUrl(url string) (string, string, error)
	Serve(uploadPath string, acceptWeb bool) ([]byte, string, error)
	Upload(file *multipart.FileHeader, token string) (domain.Media, error)
	Validate(file *multipart.FileHeader) error
	Update(m *domain.Media) error
	Delete(id int) error
	Exists(name string) bool
	Total() (int, error)
}

// MediaStore defines the data layer for Media
type MediaStore struct {
	db           *sqlx.DB
	config       config.Configuration
	optionsModel OptionsRepository
	userModel    UserRepository
	options      domain.Options
}

// newMedia - Construct
func newMedia(db *sqlx.DB, config config.Configuration) *MediaStore {
	ms := &MediaStore{
		db:           db,
		config:       config,
		optionsModel: newOptions(db, config),
		userModel:    newUser(db, config),
	}
	ms.getOptionsStruct()
	return ms
}

// getOptionsStruct - Init the model with options
func (s *MediaStore) getOptionsStruct() {
	const op = "MediaRepository.getOptionsStruct"
	s.options = s.optionsModel.GetStruct()
}

// Get all media
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no media available.
func (s *MediaStore) Get(meta params.Params) ([]domain.Media, int, error) {
	const op = "MediaRepository.Get"

	var m []domain.Media
	q := `SELECT id, uuid, url, file_path, file_size, file_name, sizes, type, user_id, updated_at, created_at,
    CASE WHEN title IS NULL THEN '' ELSE title END AS 'title',
    CASE WHEN alt IS NULL THEN '' ELSE alt END AS 'alt',
    CASE WHEN description IS NULL THEN '' ELSE description END AS 'description'
	FROM media`

	countQ := fmt.Sprintf("SELECT COUNT(*) FROM media")

	// Apply filters to total and original query
	filter, err := filterRows(s.db, meta.Filters, "media")
	if err != nil {
		return nil, -1, err
	}
	q += filter
	countQ += filter

	// Apply order
	q += fmt.Sprintf(" ORDER BY media.%s %s", meta.OrderBy, meta.OrderDirection)

	// Apply pagination
	if !meta.LimitAll {
		q += fmt.Sprintf(" LIMIT %v OFFSET %v", meta.Limit, (meta.Page-1)*meta.Limit)
	}

	// Select media
	if err := s.db.Select(&m, q); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get media", Operation: op, Err: err}
	}

	// Return not found error if no forms are available
	if len(m) == 0 {
		return []domain.Media{}, -1, &errors.Error{Code: errors.NOTFOUND, Message: "No media available", Operation: op}
	}

	// Count the total number of media
	var total int
	if err := s.db.QueryRow(countQ).Scan(&total); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of media items", Operation: op, Err: err}
	}

	return m, total, nil
}

// GetById returns a media item by Id
// Returns errors.NOTFOUND if the media item was not found by the given Id.
func (s *MediaStore) GetById(id int) (domain.Media, error) {
	const op = "MediaRepository.GetById"
	var m domain.Media
	q := `SELECT id, uuid, url, file_path, file_size, file_name, sizes, type, user_id, updated_at, created_at,
    CASE WHEN title IS NULL THEN '' ELSE title END AS 'title',
    CASE WHEN alt IS NULL THEN '' ELSE alt END AS 'alt',
    CASE WHEN description IS NULL THEN '' ELSE description END AS 'description'
	FROM media 
	WHERE id = ? LIMIT 1`
	if err := s.db.Get(&m, q, id); err != nil {
		return domain.Media{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the media item with the ID: %d", id), Operation: op, Err: err}
	}
	return m, nil
}

// Gets a media file by the file name
// Returns errors.NOTFOUND if the media item was not found by the given name.
func (s *MediaStore) GetByName(name string) (domain.Media, error) {
	const op = "MediaRepository.GetByName"
	var m domain.Media
	q := `SELECT id, uuid, url, file_path, file_size, file_name, sizes, type, user_id, updated_at, created_at,
    CASE WHEN title IS NULL THEN '' ELSE title END AS 'title',
    CASE WHEN alt IS NULL THEN '' ELSE alt END AS 'alt',
    CASE WHEN description IS NULL THEN '' ELSE description END AS 'description'
	FROM media 
	WHERE name = ? LIMIT 1`
	if err := s.db.Get(&m, q, name); err != nil {

		return domain.Media{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the media item with the name: %s", name), Operation: op, Err: err}
	}
	return m, nil
}

// GetByUrl Obtains a media file by the URL from the database
// Returns errors.NOTFOUND if the media item was not found by the given url.
func (s *MediaStore) GetByUrl(url string) (string, string, error) {
	const op = "MediaRepository.GetByUrl"
	var m domain.Media

	q := `SELECT id, uuid, url, file_path, file_size, file_name, sizes, type, user_id, updated_at, created_at,
    CASE WHEN title IS NULL THEN '' ELSE title END AS 'title',
    CASE WHEN alt IS NULL THEN '' ELSE alt END AS 'alt',
    CASE WHEN description IS NULL THEN '' ELSE description END AS 'description'
	FROM media `

	// Test normal size
	if err := s.db.Get(&m, q+"WHERE url = ? LIMIT 1", url); err == nil {
		return m.FilePath + "/" + m.UUID.String(), m.Type, nil
	}

	// Test Sizes
	err := s.db.Get(&m, q+"WHERE sizes LIKE '%"+url+"%' LIMIT 1")
	if err != nil {
		return "", "", &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the media item with the url: %s", url), Operation: op, Err: fmt.Errorf("no media item exists with the url: %s", url)}
	}

	for _, v := range m.Sizes {
		if v.Url == url {
			return m.FilePath + "/" + v.UUID.String(), m.Type, nil
		}
	}

	return "", "", &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the media item with the url: %s", url), Operation: op, Err: fmt.Errorf("no media item exists with the url: %s", url)}
}

// Serve is responsible for serving the correct data to the front end
// Returns errors.NOTFOUND if the media item was not found.
func (s *MediaStore) Serve(uploadPath string, acceptWebP bool) ([]byte, string, error) {
	const op = "MediaRepository.Serve"

	// NOTE: Not concurrent safe
	//s.getOptionsStruct()

	path, mimeType, err := s.GetByUrl(uploadPath)
	if err != nil {
		fmt.Println(err)
		return nil, "", err
	}

	extension := files.GetFileExtension(uploadPath)

	var data []byte
	var found error
	if acceptWebP && s.options.MediaServeWebP {
		data, found = ioutil.ReadFile(path + extension + ".webp")
		if found != nil {
			data, found = ioutil.ReadFile(path + extension)
		} else {
			mimeType = "image/webp"
		}
	} else {
		data, found = ioutil.ReadFile(path + extension)
	}

	if found != nil {
		return nil, "", &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("File does not exist with the path: %v", uploadPath), Operation: op, Err: err}
	}

	return data, mimeType, nil
}

// Upload the media files, return bool is for server or user error
// Returns errors.INTERNAL if the uploaded file failed to save.
func (s *MediaStore) Upload(file *multipart.FileHeader, token string) (domain.Media, error) {
	const op = "MediaRepository.Upload"

	s.getOptionsStruct()

	// Get the current logged in user
	user, err := s.userModel.CheckToken(token)
	if err != nil {
		return domain.Media{}, nil
	}

	// E.G  /Users/admin/cms/storage/uploads
	path := s.createDirectory()

	// E.G: Image20@.png
	name := file.Filename

	// E.G: .png
	extension := files.GetFileExtension(name)

	// E.G: image.png
	cleanName := s.processFileName(name, extension)

	// E.G: 53252e77-308a-4587-a078-637bf1b0e186
	key := uuid.New()

	// E.G image/png
	mimeType, _ := mime.TypeByFile(file)

	// Save the uploaded file
	if err := files.Save(file, path+"/"+key.String()+extension); err != nil {
		return domain.Media{}, &errors.Error{Code: errors.NOTFOUND, Message: "Could not save the media file, please try again", Operation: op, Err: err}
	}

	// Convert to WebP
	if s.options.MediaConvertWebP && mimeType == "image/jpeg" || mimeType == "image/png" {
		go webp.Convert(path+"/"+key.String()+extension, s.options.MediaCompression)
	}

	// Resize
	sizes := s.saveResizedImages(file, cleanName, path, mimeType, extension)

	// Insert into the database
	dm, err := s.insert(key, cleanName+extension, path, int(file.Size), mimeType, sizes, user.Id)
	if err != nil {
		return domain.Media{}, err
	}

	return dm, nil
}

// Validate the file before uploading
// Returns errors.INVALID if the file was not in the whitelist or
// the file was too big.
func (s *MediaStore) Validate(file *multipart.FileHeader) error {
	const op = "MediaRepository.Validate"

	s.getOptionsStruct()

	mimeType, err := mime.TypeByFile(file)
	if err != nil {
		return err
	}

	valid := mime.IsValidMime(s.config.Media.AllowedFileTypes, mimeType)
	if !valid {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("The %s mime type, is not in the whitelist for uploading.", mimeType), Operation: op, Err: err}
	}

	fileSize := int(file.Size / 1024)
	if fileSize > s.options.MediaUploadMaxSize && s.options.MediaUploadMaxSize != 0 {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("The file exceeds the maximum size restriction of %vkb.", s.options.MediaUploadMaxSize), Operation: op, Err: err}
	}

	io, err := file.Open()
	img, _, err := image.Decode(io)
	if err != nil {
		return nil // Is not an image
	}

	defer io.Close()

	if img.Bounds().Max.X > s.options.MediaUploadMaxWidth && s.options.MediaUploadMaxWidth != 0 {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("The image exceeds the upload max width of %vpx.", s.options.MediaUploadMaxWidth), Operation: op, Err: err}
	}

	if img.Bounds().Max.Y > s.options.MediaUploadMaxHeight && s.options.MediaUploadMaxHeight != 0 {
		return &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("The image exceeds the upload max height of %vpx.", s.options.MediaUploadMaxHeight), Operation: op, Err: err}
	}

	return nil
}

// Inserts a media item into the database
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *MediaStore) insert(uuid uuid.UUID, name string, filePath string, fileSize int, mime string, sizes domain.MediaSizes, userId int) (domain.Media, error) {
	const op = "MediaRepository.insert"

	m := domain.Media{
		UUID:        uuid,
		Url:         s.getUrl() + "/" + name,
		Title:       "",
		Description: "",
		Alt:         "",
		FilePath:    filePath,
		FileSize:    fileSize,
		FileName:    name,
		Sizes:       sizes,
		Type:        mime,
		UserID:      userId,
	}

	q := "INSERT INTO media (uuid, url, title, alt, description, file_path, file_size, file_name, sizes, type, user_id, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
	c, err := s.db.Exec(q, m.UUID, m.Url, m.Title, m.Alt, m.Description, m.FilePath, m.FileSize, m.FileName, m.Sizes, m.Type, m.UserID)

	if err != nil {
		return domain.Media{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the new media item with the name: %v", name), Operation: op, Err: err}
	}

	id, err := c.LastInsertId()
	if err != nil {
		return domain.Media{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created media with the name: %v", m.FileName), Operation: op, Err: err}
	}
	m.Id = int(id)

	return m, nil
}

// Update the media item (title, alt & description)
// Returns errors.NOTFOUND if the media item was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *MediaStore) Update(m *domain.Media) error {
	const op = "MediaRepository.Update"

	_, err := s.GetById(m.Id)
	if err != nil {
		return err
	}

	q := "UPDATE media SET title = ?, alt = ?, description = ?, updated_at = NOW() WHERE id = ?"
	_, err = s.db.Exec(q, m.Title, m.Alt, m.Description, m.Id)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the media item with the ID: %v", m.Id), Operation: op, Err: err}
	}

	// Clear the cache
	cache.Store.Delete(m.Url)

	return nil
}

// Delete the record from the database and all files
// Returns errors.NOTFOUND if the media item was not found.
// Returns errors.INTERNAL if any file (original, webp or any sizes) were not deleted.
// Or if the SQL query was invalid
func (s *MediaStore) Delete(id int) error {
	const op = "MediaRepository.Delete"

	s.getOptionsStruct()

	m, err := s.GetById(id)
	if err != nil {
		return err
	}

	extension := files.GetFileExtension(m.Url)

	// Delete entry from database
	if _, err := s.db.Exec("DELETE FROM media WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete media item with the ID: %v", id), Operation: op, Err: err}
	}

	// Delete the main file
	go files.CheckAndDelete(m.FilePath + "/" + m.UUID.String() + extension)
	go files.CheckAndDelete(m.FilePath + "/" + m.UUID.String() + extension + ".webp")

	// Delete the sizes and webp versions if stored
	for _, v := range m.Sizes {
		filePath := m.FilePath + "/" + v.UUID.String() + extension
		go files.CheckAndDelete(filePath)
		go files.CheckAndDelete(filePath + ".webp")
	}

	// Check if the file deleted was the one stored in the site logo
	if m.Url == s.options.SiteLogo {
		logo, _ := json.Marshal(api.App.Logo)
		if err := s.optionsModel.Update("site_logo", logo); err != nil {
			log.WithFields(log.Fields{
				"error": errors.Error{Code: errors.INTERNAL, Message: "Could not update the site logo", Operation: op, Err: err},
			}).Error()
		}
	}

	return nil
}

// Exists Checks if a media items exists by the given name
func (s *MediaStore) Exists(name string) bool {
	const op = "MediaRepository.Exists"
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM media WHERE file_name = ?)", name).Scan(&exists)
	return exists
}

// Total gets the total number of media items
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *MediaStore) Total() (int, error) {
	const op = "MediaRepository.Total"
	var total int
	if err := s.db.QueryRow("SELECT COUNT(*) FROM media").Scan(&total); err != nil {
		return -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of media items", Operation: op, Err: err}
	}
	return total, nil
}

// saveResizedImages saves all of the resized images and returns
// an array of media DB sizes if successful.
func (s *MediaStore) saveResizedImages(file *multipart.FileHeader, name string, path string, mime string, extension string) domain.MediaSizes {
	const op = "MediaRepository.saveResizedImages"

	s.getOptionsStruct()

	savedSizes := make(domain.MediaSizes)
	if mime == "image/png" || mime == "image/jpeg" {
		for key, size := range s.options.MediaSizes {
			mediaUUID := uuid.New()
			fileName := name + "-" + strconv.Itoa(size.Width) + "x" + strconv.Itoa(size.Height) + extension

			if err := s.processImageSize(file, path+"/"+mediaUUID.String(), mime, size); err == nil {
				savedSizes[key] = domain.MediaSize{
					UUID:     mediaUUID,
					Url:      s.getUrl() + "/" + fileName,
					Name:     fileName,
					SizeName: size.Name,
					FileSize: files.GetFileSize(path + "/" + mediaUUID.String() + extension),
					Width:    size.Width,
					Height:   size.Height,
					Crop:     size.Crop,
				}
			}
		}
	}

	return savedSizes
}

// processImageSize processes image sizes, convert WebPs and saves various image sizes based on configuration
// Returns errors.INTERNAL if the image was unable to be saved or decoded.
func (s *MediaStore) processImageSize(file *multipart.FileHeader, filePath string, mime string, size domain.MediaSize) error {
	const op = "MediaRepository.processImageSize"

	s.getOptionsStruct()

	// PNG Type
	if mime == "image/png" {
		filePath = filePath + ".png"

		decodedImage, err := s.decodeImage(file, mime)
		if err != nil {
			return err
		}
		resized := resizeImage(*decodedImage, size.Width, size.Height, size.Crop)

		if err := imaging.Save(resized, filePath, imaging.PNGCompressionLevel(png.CompressionLevel(s.options.MediaCompression))); err != nil {
			return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not save the resized image"), Operation: op, Err: err}
		}

		if s.options.MediaConvertWebP {
			// 100 - compression level
			//go webp.Convert(filePath, 100 - s.options.MediaCompression)
			go webp.Convert(filePath, s.options.MediaCompression)
		}
	}

	// Jpg Type
	if mime == "image/jpeg" || mime == "image/jp2" {
		filePath = filePath + ".jpg"

		decodedImage, err := s.decodeImage(file, mime)
		if err != nil {
			return err
		}
		resized := resizeImage(*decodedImage, size.Width, size.Height, size.Crop)

		if err := imaging.Save(resized, filePath, imaging.JPEGQuality(s.options.MediaCompression)); err != nil {
			return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not save the resized image"), Operation: op, Err: err}
		}

		if s.options.MediaConvertWebP {
			go webp.Convert(filePath, s.options.MediaCompression)
		}
	}

	return nil
}

// resizeImage Resize the image based width, height & crop
func resizeImage(srcImage image.Image, width int, height int, crop bool) image.Image {
	if crop {
		return imaging.Fill(srcImage, width, height, imaging.Center, imaging.Lanczos)
	} else {
		return imaging.Resize(srcImage, width, height, imaging.Lanczos)
	}
}

// createDirectory creates the media directory year path if the organise year variable in the media
// store is set to true. Date and year folders are created recursively.
func (s *MediaStore) createDirectory() string {
	const op = "MediaRepository.createDirectory"

	s.getOptionsStruct()
	uploadsPath := paths.Uploads()

	if !s.options.MediaOrganiseDate {
		return uploadsPath
	} else {
		t := time.Now()
		path := uploadsPath + "/" + t.Format("2006") + "/" + t.Format("01")

		if _, err := os.Stat(path); os.IsNotExist(err) {
			_ = os.MkdirAll(path, os.ModePerm)
		}
		return path
	}
}

// Get the public url of the file according to date and month if the organise
// year variable in the media store is set to true. If not the function will
// return the public uploads folder by default.
func (s *MediaStore) getUrl() string {
	if !s.options.MediaOrganiseDate {
		return s.config.Media.UploadPath
	} else {
		t := time.Now()
		return s.config.Media.UploadPath + "/" + t.Format("2006") + "/" + t.Format("01")
	}
}

// decodeImage decodes the image from a file dependant on the mime type
// Returns errors.INTERNAL if the file was unable to be decoded or the file
// was unable to be opened.
func (s *MediaStore) decodeImage(file *multipart.FileHeader, mime string) (*image.Image, error) {
	const op = "MediaRepository.decodeImage"

	reader, err := file.Open()
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to open the file with the filename: %s", file.Filename), Operation: op, Err: err}
	}

	if mime == "image/png" {
		pngFile, err := png.Decode(reader)
		if err != nil {
			return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not decode the image with the filename: %s", file.Filename), Operation: op, Err: err}
		}
		return &pngFile, nil

	} else if mime == "image/jpeg" || mime == "image/jp2" {
		jpgFile, err := jpeg.Decode(reader)
		if err != nil {
			return nil, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not decode the image with the filename: %s", file.Filename), Operation: op, Err: err}
		}
		return &jpgFile, nil
	}

	return nil, &errors.Error{Code: errors.INTERNAL, Message: "Something went wrong decoding the image", Operation: op, Err: err}
}

// Process file name
func (s *MediaStore) processFileName(file string, extension string) string {

	// Remove the file extension
	name := files.RemoveFileExtension(file)

	// Clean the file
	var cleanedFile string
	cleanedFile = strings.ReplaceAll(name, " ", "-")
	reg := regexp.MustCompile("[^A-Za-z0-9 -]+")
	cleanedFile = reg.ReplaceAllString(cleanedFile, "")
	cleanedFile = strings.ToLower(cleanedFile)

	// Check if the file exists and add a version number, continue if not
	version := 0
	for {
		if version == 0 {
			if exists := s.Exists(cleanedFile + extension); !exists {
				break
			}
		} else {
			if exists := s.Exists(cleanedFile + "-" + strconv.Itoa(version) + extension); !exists {
				cleanedFile = cleanedFile + "-" + strconv.Itoa(version)
				break
			}
		}
		version++
	}

	return cleanedFile
}"
}
{
file:./api/models/user.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"strings"
	"time"
)

// UserRepository defines methods for Users to interact with the database
type UserRepository interface {
	Get(meta params.Params) (domain.Users, int, error)
	GetById(id int) (domain.User, error)
	GetOwner() (domain.User, error)
	GetByToken(token string) (domain.User, error)
	GetByEmail(email string) (domain.User, error)
	GetRoles() ([]domain.UserRole, error)
	Create(u *domain.UserCreate) (domain.User, error)
	Update(u *domain.User) (domain.User, error)
	Delete(id int) error
	CheckSession(token string) error
	ResetPassword(id int, reset domain.UserPasswordReset) error
	CheckToken(token string) (domain.User, error)
	Exists(id int) bool
	ExistsByEmail(email string) bool
	Total() (int, error)
}

// UserStore defines the data layer for Users
type UserStore struct {
	db          *sqlx.DB
	config      config.Configuration
	optionsRepo domain.Options
}

// newUser - Construct
func newUser(db *sqlx.DB, config config.Configuration) *UserStore {
	return &UserStore{
		db:          db,
		config:      config,
		optionsRepo: newOptions(db, config).GetStruct(),
	}
}

// Get all users
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no users available.
func (s *UserStore) Get(meta params.Params) (domain.Users, int, error) {
	const op = "UserRepository.Get"

	var u domain.Users
	q := fmt.Sprintf("SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id")
	countQ := fmt.Sprintf("SELECT COUNT(*) FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id")

	// Check if there is a role filter, for example
	// roles.name and reorder meta.Filters
	table := "users"
	for k, v := range meta.Filters {
		if strings.Contains(k, "roles") {
			arr := strings.Split(k, ".")
			if len(arr) > 1 {
				meta.Filters[arr[1]] = v
				delete(meta.Filters, k)
				table = "roles"
			}
		}
	}

	// Apply filters to total and original query
	filter, err := filterRows(s.db, meta.Filters, table)
	if err != nil {
		return nil, -1, err
	}
	q += filter
	countQ += filter

	// Apply order
	q += fmt.Sprintf(" ORDER BY users.%s %s", meta.OrderBy, meta.OrderDirection)

	// Apply pagination
	if !meta.LimitAll {
		q += fmt.Sprintf(" LIMIT %v OFFSET %v", meta.Limit, (meta.Page-1)*meta.Limit)
	}

	// Select users
	if err := s.db.Select(&u, q); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get users", Operation: op, Err: err}
	}

	// Return not found error if no users are available
	if len(u) == 0 {
		return nil, -1, &errors.Error{Code: errors.NOTFOUND, Message: "No users available", Operation: op}
	}

	// Count the total number of users
	var total int
	if err := s.db.QueryRow(countQ).Scan(&total); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of posts", Operation: op, Err: err}
	}

	return u, total, nil
}

// GetById returns a user by Id
// Returns errors.NOTFOUND if the user was not found by the given Id.
func (s *UserStore) GetById(id int) (domain.User, error) {
	const op = "UserRepository.GetById"
	var u domain.User
	if err := s.db.Get(&u, "SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id WHERE users.id = ?", id); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the user with the ID: %d", id), Operation: op, Err: err}
	}
	return u, nil
}

// GetOwner gets the owner of the site with the Id of 6
// Returns errors.NOTFOUND if the owner was not found.
func (s *UserStore) GetOwner() (domain.User, error) {
	const op = "UserRepository.GetOwner"
	var u domain.User
	if err := s.db.Get(&u, "SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id WHERE roles.id = 6 LIMIT 1"); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "Could not get the owner of the site", Operation: op, Err: err}
	}
	return u, nil
}

// GetByToken gets a user with the given token.
// Returns errors.NOTFOUND if the owner was not found.
func (s *UserStore) GetByToken(token string) (domain.User, error) {
	const op = "UserRepository.GetOwner"
	var u domain.User
	if err := s.db.Get(&u, "SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id WHERE token = ? LIMIT 1", token); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the user with the token: %s", token), Operation: op, Err: err}
	}
	return u, nil
}

// GetByToken gets a user with the given token.
// Returns errors.NOTFOUND if the owner was not found.
func (s *UserStore) GetByEmail(email string) (domain.User, error) {
	const op = "UserRepository.GetByEmail"
	var u domain.User
	if err := s.db.Get(&u, "SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id INNER JOIN roles ON user_roles.role_id = roles.id WHERE email = ? LIMIT 1", email); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the user with the email: %s", email), Operation: op, Err: err}
	}
	return u, nil
}

// GetRoles gets all of the roles in the roles table
// Returns errors.INTERNAL if the roles table was inaccessible.
func (s *UserStore) GetRoles() ([]domain.UserRole, error) {
	const op = "UserRepository.GetRoles"
	var r []domain.UserRole
	if err := s.db.Select(&r, "SELECT * FROM roles"); err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the user roles", Operation: op, Err: err}
	}
	return r, nil
}

// Create user
// Returns errors.CONFLICT if the the post slug already exists.
// Returns errors.INTERNAL if the SQL query was invalid, the function
// could not get the newly created ID or the user role failed to be inserted.
func (s *UserStore) Create(u *domain.UserCreate) (domain.User, error) {
	const op = "UserRepository.Create"

	if exists := s.ExistsByEmail(u.Email); exists {
		return domain.User{}, &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("Could not create the user, the email %v, already exists", u.Email), Operation: op, Err: fmt.Errorf("user already exists")}
	}

	hashedPassword, err := encryption.HashPassword(u.Password)
	if err != nil {
		return domain.User{}, err
	}

	token := encryption.GenerateUserToken(u.FirstName+u.LastName, u.Email)

	userQ := "INSERT INTO users (uuid, first_name, last_name, email, password, website, facebook, twitter, linked_in, instagram, biography, profile_picture_id, token, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
	c, err := s.db.Exec(userQ, uuid.New().String(), u.FirstName, u.LastName, u.Email, hashedPassword, u.Website, u.Facebook, u.Twitter, u.Linkedin, u.Instagram, u.Biography, u.ProfilePictureID, token)
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the user with the email: %s", u.Email), Operation: op, Err: err}
	}

	id, err := c.LastInsertId()
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created user ID with the email: %v", u.Email), Operation: op, Err: err}
	}

	roleQ := "INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)"
	_, err = s.db.Exec(roleQ, id, u.Role.Id)
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the user role for user with the email: %s", u.Email), Operation: op, Err: err}
	}

	newUser, err := s.GetById(int(id))
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created user with the id: %v", u.Id), Operation: op, Err: err}
	}

	// TODO: Determine of email verified is turned on.
	//If the user is not the owner, send the verification email
	//if u.Role.Id != 6 {
	//	ve, err := events.NewVerifyEmail()
	//	if err != nil {
	//		return domain.User{}, err
	//	}
	//
	//	err = ve.Send(&newUser, s.optionsRepo.SiteTitle)
	//	if err != nil {
	//		return domain.User{}, err
	//	}
	//}

	return newUser, nil
}

// Update user
// Returns errors.NOTFOUND if the user was not found.
// Returns errors.INTERNAL if the SQL query was invalid for updating the user
// or user roles table.
func (s *UserStore) Update(u *domain.User) (domain.User, error) {
	const op = "UserRepository.Update"

	_, err := s.GetById(u.Id)
	if err != nil {
		return domain.User{}, err
	}

	userQ := "UPDATE users SET first_name = ?, last_name = ?, email = ?, website = ?, facebook = ?, twitter = ?, linked_in = ?, instagram = ?, biography = ?, profile_picture_id = ?, updated_at = NOW() WHERE id = ?"
	_, err = s.db.Exec(userQ, u.FirstName, u.LastName, u.Email, u.Website, u.Facebook, u.Twitter, u.Linkedin, u.Instagram, u.Biography, u.ProfilePictureID, u.Id)
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user with the email: %s", u.Email), Operation: op, Err: err}
	}

	roleQ := "UPDATE user_roles SET role_id = ? WHERE user_id = ?"
	_, err = s.db.Exec(roleQ, u.Role.Id, u.Id)
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user roles with the user ID: %d", u.Id), Operation: op, Err: err}
	}

	return *u, nil
}

// Delete user
// Returns errors.NOTFOUND if user wanst found.
// Returns errors.CONFLICT if role ID is thE owner
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *UserStore) Delete(id int) error {
	const op = "UserRepository.Delete"

	u, err := s.GetById(id)
	if err != nil {
		return err
	}

	if u.Role.Name == "Owner" {
		return &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("The owner of the site cannot be deleted."), Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM users WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete user with the ID: %d", id), Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM user_roles WHERE user_id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not from the user roles with the ID: %d", id), Operation: op, Err: err}
	}

	return nil
}

// CheckSession
// Returns errors.NOTFOUND if the user was not found
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.CONFLICT if the user session expired.
func (s *UserStore) CheckSession(token string) error {
	const op = "UserRepository.UpdateSession"

	u, err := s.GetByToken(token)
	if err != nil {
		return err
	}

	// If not login
	if u.TokenLastUsed != nil {

		// Destroy the token and create a new one if session expired.
		inactiveFor := time.Now().Sub(*u.TokenLastUsed).Minutes()

		if int(inactiveFor) > s.config.Admin.InactiveSessionTime {
			newToken := encryption.GenerateUserToken(u.FirstName+u.LastName, u.Email)

			_, err := s.db.Exec("UPDATE users SET token = ?, updated_at = NOW() WHERE token = token", newToken)
			if err != nil {
				fmt.Println(err)
				return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user's token with the name: %v", u.FirstName+" "+u.LastName), Operation: op, Err: err}
			}

			return &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("User seesion expiered, please login again."), Operation: op, Err: fmt.Errorf("user session expiered")}
		}
	}

	_, err = s.db.Exec("UPDATE users SET token_last_used = NOW() WHERE token = ?", token)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user token last used."), Operation: op, Err: err}
	}

	return nil
}

// ResetPassword
// Returns errors.INVALID if the current password didn't match.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *UserStore) ResetPassword(id int, reset domain.UserPasswordReset) error {
	const op = "UserRepository.ResetPassword"

	hashedPassword, err := encryption.HashPassword(reset.NewPassword)
	if err != nil {
		return err
	}

	_, err = s.db.Exec("UPDATE users SET password = ? WHERE id = ?", hashedPassword, id)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not update the users table with the new password", Operation: op, Err: err}
	}

	return nil
}

// Get the user by Token
// Returns errors.NOTFOUND if there are the user is not found.
func (s *UserStore) CheckToken(token string) (domain.User, error) {
	const op = "UserRepository.CheckToken"
	var u domain.User
	if err := s.db.Get(&u, "SELECT users.*, roles.id 'roles.id', roles.name 'roles.name', roles.description 'roles.description' FROM users LEFT JOIN user_roles ON users.id = user_roles.user_id LEFT JOIN roles ON user_roles.role_id = roles.id WHERE users.token = ?", token); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get user with token: %v", token), Operation: op, Err: err}
	}
	return u, nil
}

// Exists checks if the user record exists by ID
func (s *UserStore) Exists(id int) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM users WHERE id = ?)", id).Scan(&exists)
	return exists
}

// ExistsByEmail checks if the user record exists by email
func (s *UserStore) ExistsByEmail(email string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM users WHERE email = ?)", email).Scan(&exists)
	return exists
}

// Get the total number of posts
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *UserStore) Total() (int, error) {
	const op = "UserRepository.Total"
	var total int
	if err := s.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&total); err != nil {
		return -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of users", Operation: op, Err: err}
	}
	return total, nil
}"
}
{
file:./api/models/auth.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/encryption"
	"github.com/ainsleyclark/verbis/api/mail/events"
	"github.com/jmoiron/sqlx"
	"golang.org/x/crypto/bcrypt"
)

// AuthRepository defines methods for for Users to gain
// Auth for interacting with the database.
type AuthRepository interface {
	Authenticate(email string, password string) (domain.User, error)
	Logout(token string) (int, error)
	ResetPassword(token string, password string) error
	SendResetPassword(email string) error
	VerifyEmail(md5String string) error
	VerifyPasswordToken(token string) error
	CleanPasswordResets() error
}

// AuthStore defines the data layer for Authentication
type AuthStore struct {
	db          *sqlx.DB
	config      config.Configuration
	optionsRepo domain.Options
}

// newAuth - Construct
func newAuth(db *sqlx.DB, config config.Configuration) *AuthStore {
	const op = "AuthRepository.newAuth"

	a := &AuthStore{
		db: db,
	}

	om := newOptions(db, config)
	a.optionsRepo = om.GetStruct()

	return a
}

// Authenticate compares the email & password for a match in the DB.
// Returns errors.NOTFOUND if the user is not found.
func (s *AuthStore) Authenticate(email string, password string) (domain.User, error) {
	const op = "AuthRepository.Authenticate"

	var u domain.User
	if err := s.db.Get(&u, "SELECT * FROM users WHERE email = ? LIMIT 1", email); err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "These credentials don't match our records.", Operation: op, Err: err}
	}

	err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "These credentials don't match our records.", Operation: op, Err: err}
	}

	_, err = s.db.Exec("UPDATE users SET token_last_used = NOW() WHERE token = ?", u.Token)
	if err != nil {
		return domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user token last used."), Operation: op, Err: err}
	}

	return u, nil
}

// Logout checks to see if see if the the token is valid & then
// proceeds to create a new token and returns the user Id.
// Returns errors.NOTFOUND if the user was not found by the given token.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *AuthStore) Logout(token string) (int, error) {
	const op = "AuthRepository.Logout"

	var u domain.User
	if err := s.db.Get(&u, "SELECT * FROM users WHERE token = ? LIMIT 1", token); err != nil {
		return -1, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get user with token: %v", token), Operation: op, Err: err}
	}

	newToken := encryption.GenerateUserToken(u.FirstName+u.LastName, u.Email)
	_, err := s.db.Exec("UPDATE users SET token = ?, updated_at = NOW() WHERE token = ?", newToken, token)
	if err != nil {
		return -1, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the user's token with the name: %v", u.FirstName+" "+u.LastName), Operation: op, Err: err}
	}

	return u.Id, nil
}

// ResetPassword obtains the password reset information from the
// table and creates a new hash, it then updates the user table
// with the new details and removes the temporary entry in
// the reset_passwords table.
// Returns errors.NOTFOUND if the user was not found by the given token.
// Returns errors.INTERNAL if the SQL query was invalid, unable to
// create a new password or delete from the password resets table.
func (s *AuthStore) ResetPassword(token string, password string) error {
	const op = "AuthRepository.ResetPassword"

	var rp domain.PasswordReset
	if err := s.db.Get(&rp, "SELECT * FROM password_resets WHERE token = ? LIMIT 1", token); err != nil {
		return &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get user with token: %v", token), Operation: op}
	}

	hashedPassword, err := encryption.HashPassword(password)
	if err != nil {
		return err
	}

	_, err = s.db.Exec("UPDATE users SET password = ? WHERE email = ?", hashedPassword, rp.Email)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not update the users table with the new password", Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM password_resets WHERE token = ?", token); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not delete from the password resets table", Operation: op, Err: err}
	}

	return nil
}

// SendResetPassword obtains the user by email and generates a new email token.
// A temporary record is inserted to the password resets table and an email
// is sent to the user by the reset passwords event.
// Returns errors.NOTFOUND if the user was not found by the given email.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *AuthStore) SendResetPassword(email string) error {
	const op = "AuthRepository.SendResetPassword"

	var u domain.User
	if err := s.db.Get(&u, "SELECT * FROM users WHERE email = ? LIMIT 1", email); err != nil {
		return &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not find the user with the email: %s", email), Operation: op, Err: err}
	}

	token, err := encryption.GenerateEmailToken(email)
	if err != nil {
		return err
	}

	q := "INSERT INTO password_resets (email, token, created_at) VALUES (?, ?, NOW())"
	_, err = s.db.Exec(q, email, token)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: "Could not insert into password resets", Operation: op, Err: err}
	}

	rp, err := events.NewResetPassword()
	if err != nil {
		return err
	}

	// TODO: Clean up here
	siteUrl := s.optionsRepo.SiteUrl + "/admin"
	if api.SuperAdmin {
		siteUrl = "http://127.0.0.1:8090/admin"
	}

	err = rp.Send(&u, siteUrl, token, s.optionsRepo.SiteTitle)
	if err != nil {
		return err
	}

	return nil
}

// VerifyEmail the users email address based on the encryption hash string passed
// Returns errors.NOTFOUND if the user was not found by the md5string email.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *AuthStore) VerifyEmail(md5String string) error {
	const op = "AuthRepository.VerifyEmail"

	var userVerified = struct {
		Id   int    `db:"id"`
		Hash string `db:"hash"`
	}{}

	if err := s.db.Get(&userVerified, "SELECT id AS id, MD5(CONCAT(id, email)) AS hash FROM users WHERE MD5(CONCAT(id, email)) = ?", md5String); err != nil {
		return &errors.Error{Code: errors.NOTFOUND, Message: "Could not find the user for email verification", Operation: op, Err: err}
	}

	q := "UPDATE users SET email_verified_at = NOW() WHERE ID = ?"
	_, err := s.db.Exec(q, userVerified.Id)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could update the user with the Id: %d", userVerified.Id), Operation: op, Err: err}
	}

	return nil
}

// VerifyPasswordToken the token is valid from the password resets table
// Returns errors.NOTFOUND if the user was not found by the given token.
func (s *AuthStore) VerifyPasswordToken(token string) error {
	const op = "AuthRepository.VerifyPasswordToken"
	var pr domain.PasswordReset
	if err := s.db.Get(&pr, "SELECT * FROM password_resets WHERE token = ? LIMIT 1", token); err != nil {
		return &errors.Error{Code: errors.NOTFOUND, Message: "We couldn't find a email matching that token", Operation: op, Err: err}
	}
	return nil
}

// Verify the token is valid from the password resets table
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *AuthStore) CleanPasswordResets() error {
	const op = "AuthRepository.CleanPasswordResets"
	if _, err := s.db.Exec("DELETE FROM password_resets WHERE created_at < (NOW() - INTERVAL 2 HOUR)"); err != nil {
		return &errors.Error{Code: errors.INVALID, Message: "Could not delete from the reset passwords table", Operation: op, Err: err}
	}
	return nil
}"
}
{
file:./api/models/options.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/jmoiron/sqlx"
	log "github.com/sirupsen/logrus"
)

// OptionsRepository defines methods for Options to interact with the database
type OptionsRepository interface {
	Get() (domain.OptionsDB, error)
	GetByName(name string) (interface{}, error)
	GetStruct() domain.Options
	UpdateCreate(options *domain.OptionsDB) error
	Create(name string, value interface{}) error
	Update(name string, value interface{}) error
	Exists(name string) bool
}

// OptionsStore defines the data layer for Posts
type OptionsStore struct {
	db     *sqlx.DB
	config config.Configuration
}

// newOptions - Construct
func newOptions(db *sqlx.DB, config config.Configuration) *OptionsStore {
	return &OptionsStore{
		db:     db,
		config: config,
	}
}

// Get all options
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no options available.
func (s *OptionsStore) Get() (domain.OptionsDB, error) {
	const op = "OptionsRepository.Get"

	var o []domain.OptionDB
	if err := s.db.Select(&o, "SELECT * FROM options"); err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not get options", Operation: op, Err: err}
	}

	opts := make(domain.OptionsDB)
	for _, v := range o {
		unValue, err := s.unmarshalValue(v.Value)
		if err != nil {
			return domain.OptionsDB{}, err
		}
		opts[v.Name] = unValue
	}

	return opts, nil
}

// Get by name
// Returns errors.NOTFOUND if the post was not found by the given name.
func (s *OptionsStore) GetByName(name string) (interface{}, error) {
	const op = "OptionsRepository.GetByName"

	opts, err := s.Get()
	if err != nil {
		return nil, err
	}

	if val, ok := opts[name]; ok {
		return val, nil
	}

	return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get option with the name %s", name), Operation: op, Err: err}
}

// GetStruct gets the options struct for use in the API
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *OptionsStore) GetStruct() domain.Options {
	const op = "OptionsRepository.GetStruct"

	cachedOpts, found := cache.Store.Get("options-struct")
	if found {
		return cachedOpts.(domain.Options)
	}

	var opts []domain.OptionDB
	if err := s.db.Select(&opts, "SELECT * FROM options"); err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INTERNAL, Message: "Unable to get options", Operation: op, Err: err},
		}).Fatal()
		return domain.Options{}
	}

	unOpts := make(domain.OptionsDB)
	for _, v := range opts {
		unValue, err := s.unmarshalValue(v.Value)
		if err != nil {
			log.WithFields(log.Fields{
				"error": &errors.Error{Code: errors.INTERNAL, Message: "Unable to get options", Operation: op, Err: err},
			}).Fatal()
			return domain.Options{}
		}
		unOpts[v.Name] = unValue
	}

	mOpts, err := json.Marshal(unOpts)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INTERNAL, Message: "Unable to get options", Operation: op, Err: err},
		}).Fatal()
		return domain.Options{}
	}

	var options domain.Options
	if err := json.Unmarshal(mOpts, &options); err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INTERNAL, Message: "Unable to get options", Operation: op, Err: err},
		}).Fatal()
		return domain.Options{}
	}

	if !found {
		go cache.Store.Set("options-struct", options, cache.RememberForever)
	}

	return options
}

// UpdateCreate update's or create options depending on Exists check
func (s *OptionsStore) UpdateCreate(options *domain.OptionsDB) error {
	const op = "OptionsRepository.UpdateCreate"
	for name, value := range *options {
		jsonValue, err := s.marshalValue(value)
		if err != nil {
			return err
		}
		if s.Exists(name) {
			if err := s.Update(name, jsonValue); err != nil {
				return err
			}
		} else {
			if err := s.Create(name, jsonValue); err != nil {
				return err
			}
		}
	}
	return nil
}

// Exists checks if the option exists
func (s *OptionsStore) Exists(name string) bool {
	const op = "OptionsRepository.Exists"
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT option_name FROM options WHERE option_name = ?)", name).Scan(&exists)
	return exists
}

// Create the option
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *OptionsStore) Create(name string, value interface{}) error {
	const op = "OptionsRepository.create"
	q := "INSERT INTO options (option_name, option_value) VALUES (?, ?)"
	_, err := s.db.Exec(q, name, value)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the option with the name: %s", name), Operation: op, Err: err}
	}
	return nil
}

// Update the option
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *OptionsStore) Update(name string, value interface{}) error {
	const op = "OptionsRepository.update"
	q := "UPDATE options SET option_name = ?, option_value = ? WHERE option_name = ?"
	_, err := s.db.Exec(q, name, value, name)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the option with the name: %s", name), Operation: op, Err: err}
	}
	return nil
}

// Unmarshal the value
// Returns errors.INTERNAL if the unmarshalling failed
func (s *OptionsStore) unmarshalValue(optValue json.RawMessage) (interface{}, error) {
	const op = "OptionsRepository.unmarshalValue"
	var value interface{}
	if err := json.Unmarshal(optValue, &value); err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not unmarshal the option", Operation: op, Err: err}
	}
	return value, nil
}

// Marshal the value
// Returns errors.INTERNAL if the mmarshalling failed
func (s *OptionsStore) marshalValue(optValue interface{}) (json.RawMessage, error) {
	const op = "OptionsRepository.marshalValue"
	m, err := json.Marshal(optValue)
	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Could not marshal the option", Operation: op}
	}
	return m, nil
}"
}
{
file:./api/models/posts.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	log "github.com/sirupsen/logrus"
	"strings"
)

// PostsRepository defines methods for Posts to interact with the database
type PostsRepository interface {
	Get(meta params.Params, layout bool, resource string, status string) ([]domain.PostData, int, error)
	GetById(id int, layout bool) (domain.PostData, error)
	GetBySlug(slug string) (domain.PostData, error)
	Create(p *domain.PostCreate) (domain.PostData, error)
	Update(p *domain.PostCreate) (domain.PostData, error)
	Delete(id int) error
	Exists(id int) bool
	ExistsBySlug(slug string) bool
	Total() (int, error)
}

// PostStore defines the data layer for Posts
type PostStore struct {
	db              *sqlx.DB
	seoMetaModel    SeoMetaRepository
	userModel       UserRepository
	categoriesModel CategoryRepository
	fieldsModel     FieldsRepository
}

// newPosts - Construct
func newPosts(db *sqlx.DB, config config.Configuration) *PostStore {
	return &PostStore{
		db:              db,
		seoMetaModel:    newSeoMeta(db),
		userModel:       newUser(db, config),
		categoriesModel: newCategories(db, config),
		fieldsModel:     newFields(db, config),
	}
}

type PostRaw struct {
	domain.Post
	Author   domain.User     `db:"author"`
	Category domain.Category `db:"category"`
	Field    struct {
		Id            int        `db:"field_id"`
		PostId        int        `db:"post_id"`
		UUID          *uuid.UUID `db:"uuid"`
		Type          string     `db:"type"`
		Name          string     `db:"name"`
		Key           string     `db:"field_key"`
		OriginalValue string     `db:"value" json:"value"`
	} `db:"field"`
}

func (s PostStore) getQuery(query string) string {
	return fmt.Sprintf(`SELECT posts.*, post_options.seo 'options.seo', post_options.meta 'options.meta',
       users.id as 'author.id', users.uuid as 'author.uuid', users.first_name 'author.first_name', users.last_name 'author.last_name', users.email 'author.email', users.website 'author.website', users.facebook 'author.facebook', users.twitter 'author.twitter', users.linked_in 'author.linked_in',
       users.instagram 'author.instagram', users.biography 'author.biography', users.profile_picture_id 'author.profile_picture_id', users.updated_at 'author.updated_at', users.created_at 'author.created_at',
       roles.id 'author.roles.id', roles.name 'author.roles.name', roles.description 'author.roles.description',
       pf.uuid 'field.uuid',
       CASE WHEN categories.id IS NULL THEN 0 ELSE categories.id END AS 'category.id',
       CASE WHEN categories.name IS NULL THEN '' ELSE categories.name END AS 'category.name',
       CASE WHEN categories.resource IS NULL THEN '' ELSE categories.resource END AS 'category.resource',
       CASE WHEN pf.id IS NULL THEN 0 ELSE pf.id END AS 'field.field_id',
       CASE WHEN pf.type IS NULL THEN "" ELSE pf.type END AS 'field.type',
       CASE WHEN pf.field_key IS NULL THEN "" ELSE pf.field_key END AS 'field.field_key',
       CASE WHEN pf.name IS NULL THEN "" ELSE pf.name END AS 'field.name',
       CASE WHEN pf.value IS NULL THEN "" ELSE pf.value END AS 'field.value'
FROM (%s) posts
      LEFT JOIN post_options ON posts.id = post_options.post_id
      LEFT JOIN users ON posts.user_id = users.id
      INNER JOIN user_roles ON users.id = user_roles.user_id
      LEFT JOIN roles ON user_roles.role_id = roles.id
      LEFT JOIN post_categories pc on posts.id = pc.post_id
      LEFT JOIN categories on pc.category_id = categories.id
      LEFT JOIN post_fields pf on posts.id = pf.post_id`, query)
}

func (s *PostStore) Get(meta params.Params, layout bool, resource string, status string) ([]domain.PostData, int, error) {
	const op = "PostsRepository.Get"

	q := "SELECT * FROM posts"
	countQ := "SELECT COUNT(*) FROM posts"

	// Apply filters to total and original query
	filter, err := filterRows(s.db, meta.Filters, "posts")
	if err != nil {
		return nil, -1, err
	}
	q += filter
	countQ += filter

	// Get by resource
	if resource != "all" && resource != "" {
		if len(meta.Filters) > 0 {
			q += fmt.Sprintf(" AND")
			countQ += fmt.Sprintf(" AND")
		} else {
			q += fmt.Sprintf(" WHERE")
			countQ += fmt.Sprintf(" WHERE")
		}

		// If the resource is pages or a resource
		resourceQ := ""
		if resource == "pages" {
			resourceQ = fmt.Sprintf(" posts.resource IS NULL")
		} else {
			resourceQ = fmt.Sprintf(" posts.resource = '%s'", resource)
		}

		q += resourceQ
		countQ += resourceQ
	}

	// Get Status
	if status != "" {
		if resource != "" {
			q += fmt.Sprintf(" AND")
			countQ += fmt.Sprintf(" AND")
		} else {
			q += fmt.Sprintf(" WHERE")
			countQ += fmt.Sprintf(" WHERE")
		}
		q += fmt.Sprintf(" posts.status = '%s'", status)
		countQ += fmt.Sprintf(" posts.status = '%s'", status)
	}

	// Apply order
	if meta.OrderBy != "" {
		q += fmt.Sprintf(" ORDER BY posts.%s %s", meta.OrderBy, meta.OrderDirection)
	}

	// Apply pagination
	if !meta.LimitAll {
		q += fmt.Sprintf(" LIMIT %v OFFSET %v", meta.Limit, (meta.Page-1)*meta.Limit)
	}

	q = s.getQuery(q)

	// Apply order
	if meta.OrderBy != "" {
		q += fmt.Sprintf(" ORDER BY posts.%s %s", meta.OrderBy, meta.OrderDirection)
	}

	var rawPosts []PostRaw
	if err := s.db.Select(&rawPosts, q); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get posts", Operation: op, Err: err}
	}

	// Count the total number of posts
	var total int
	if err := s.db.QueryRow(countQ).Scan(&total); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of posts", Operation: op, Err: err}
	}

	// Return not found error if no posts are available
	formattedPosts := s.format(rawPosts, layout)
	if len(formattedPosts) == 0 {
		return nil, -1, &errors.Error{Code: errors.NOTFOUND, Message: "No posts available", Operation: op}
	}

	return formattedPosts, total, nil
}

// GetById returns a post by Id
//
// Returns errors.NOTFOUND if the post was not found by the given Id.
func (s *PostStore) GetById(id int, layout bool) (domain.PostData, error) {
	const op = "PostsRepository.GetById"

	var p []PostRaw
	err := s.db.Select(&p, s.getQuery("SELECT * FROM posts WHERE posts.id = ? LIMIT 1"), id)

	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the post with the ID: %d", id), Operation: op, Err: err}
	}

	formatted := s.format(p, layout)
	if len(formatted) == 0 {
		return domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not format the post with the ID: %d", id), Operation: op, Err: fmt.Errorf("could not format the post with the ID: %d", id)}
	}

	return formatted[0], nil
}

// GetBySlug returns a a post by slug
//
// Returns errors.NOTFOUND if the post was not found by the given slug.
func (s *PostStore) GetBySlug(slug string) (domain.PostData, error) {
	const op = "PostsRepository.GetBySlug"

	var p []PostRaw
	err := s.db.Select(&p, s.getQuery("SELECT * FROM posts WHERE posts.slug = ? LIMIT 1"), slug)

	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get post with the slug %s", slug), Operation: op, Err: err}
	}

	formatted := s.format(p, false)
	if len(formatted) == 0 {
		return domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not format the post with the slug: %s", slug), Operation: op, Err: fmt.Errorf("could not format the post with the slug: %s", slug)}
	}

	return formatted[0], nil
}

// Create a new post
// Returns errors.CONFLICT if the the post slug already exists.
// Returns errors.INTERNAL if the SQL query was invalid or the function
// could not get the newly created ID.
func (s *PostStore) Create(p *domain.PostCreate) (domain.PostData, error) {
	const op = "PostsRepository.Create"

	if err := s.validateUrl(p.Slug); err != nil {
		return domain.PostData{}, err
	}

	// Check if the author is set assign to owner if not.
	p.UserId = s.checkOwner(*p)

	// TODO: Work out why sql defaults arent working!
	if p.PageLayout == "" {
		p.PageLayout = "default"
	}
	if p.PageTemplate == "" {
		p.PageTemplate = "default"
	}
	if p.Status == "" {
		p.Status = "draft"
	}

	// Remove any trailing slashes from slug.
	if p.Slug != "/" {
		p.Slug = strings.TrimRight(p.Slug, "/")
	}

	q := "INSERT INTO posts (uuid, slug, title, status, resource, page_template, layout, codeinjection_head, codeinjection_foot, user_id, published_at, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
	c, err := s.db.Exec(q, uuid.New().String(), p.Slug, p.Title, p.Status, p.Resource, p.PageTemplate, p.PageLayout, p.CodeInjectionHead, p.CodeInjectionFoot, p.UserId, p.PublishedAt)
	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the post with the title: %v", p.Title), Operation: op, Err: err}
	}

	id, err := c.LastInsertId()
	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created post ID with the title: %v", p.Title), Operation: op, Err: err}
	}

	post, err := s.GetById(int(id), true)
	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created post with the title: %v", p.Title), Operation: op, Err: err}
	}

	// Update the categories based on the array of integers that
	// are passed.
	if err := s.categoriesModel.InsertPostCategory(int(id), p.Category); err != nil {
		return domain.PostData{}, err
	}

	// Update or create the fields
	if err := s.fieldsModel.UpdateCreate(int(id), p.Fields); err != nil {
		return domain.PostData{}, err
	}

	// Update the post meta
	if err := s.seoMetaModel.UpdateCreate(int(id), p.SeoMeta); err != nil {
		return domain.PostData{}, err
	}

	return post, nil
}

// Update a post by Id
// Returns errors.NOTFOUND if the post was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *PostStore) Update(p *domain.PostCreate) (domain.PostData, error) {
	const op = "PostsRepository.Update"

	oldPost, err := s.GetById(p.Id, false)
	if err != nil {
		return domain.PostData{}, err
	}

	if oldPost.Slug != p.Slug {
		if err := s.validateUrl(p.Slug); err != nil {
			return domain.PostData{}, err
		}
	}

	// Check if the author is set assign to owner if not.
	p.Author = s.checkOwner(*p)
	p.UserId = p.Author

	// Remove any trailing slashes from slug.
	if p.Slug != "/" {
		p.Slug = strings.TrimRight(p.Slug, "/")
	}

	// Update the posts table with data
	q := "UPDATE posts SET slug = ?, title = ?, status = ?, resource = ?, page_template = ?, layout = ?, codeinjection_head = ?, codeinjection_foot = ?, user_id = ?, published_at = ?, updated_at = NOW() WHERE id = ?"
	_, err = s.db.Exec(q, p.Slug, p.Title, p.Status, p.Resource, p.PageTemplate, p.PageLayout, p.CodeInjectionHead, p.CodeInjectionFoot, p.UserId, p.PublishedAt, p.Id)
	if err != nil {
		return domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the post wuth the title: %v", p.Title), Operation: op, Err: err}
	}

	// Update the categories based on the array of integers that
	// are passed. If the categories
	if err := s.categoriesModel.InsertPostCategory(p.Id, p.Category); err != nil {
		return domain.PostData{}, err
	}

	// Update or create the fields
	if err := s.fieldsModel.UpdateCreate(p.Id, p.Fields); err != nil {
		return domain.PostData{}, err
	}

	post, err := s.GetById(p.Id, true)
	if err != nil {
		return domain.PostData{}, err
	}

	// Update the post meta
	if err := s.seoMetaModel.UpdateCreate(p.Id, p.SeoMeta); err != nil {
		return domain.PostData{}, err
	}

	// Clear the cache
	cache.Store.Delete(post.Slug)

	return post, nil
}

// Delete post
// Returns errors.NOTFOUND if the post was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *PostStore) Delete(id int) error {
	const op = "PostsRepository.Delete"

	if !s.Exists(id) {
		return &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("No post exists with the ID: %v", id), Operation: op, Err: fmt.Errorf("no post exists")}
	}

	if _, err := s.db.Exec("DELETE FROM posts WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete post with the ID: %v", id), Operation: op, Err: err}
	}

	return nil
}

// Total gets the total number of posts
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *PostStore) Total() (int, error) {
	const op = "PostsRepository.Total"
	var total int
	if err := s.db.QueryRow("SELECT COUNT(*) FROM posts").Scan(&total); err != nil {
		return -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of posts", Operation: op, Err: err}
	}
	return total, nil
}

// Exists Checks if a post exists by the given slug
func (s *PostStore) Exists(id int) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM posts WHERE id = ?)", id).Scan(&exists)
	return exists
}

// Exists Checks if a post exists by the given slug
func (s *PostStore) ExistsBySlug(slug string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM posts WHERE slug = ?)", slug).Scan(&exists)
	return exists
}

// checkOwner Checks if the author is set or if the author does not exist.
// Returns the owner ID under circumstances.
func (s *PostStore) checkOwner(p domain.PostCreate) int {
	if p.Author == 0 || !s.userModel.Exists(p.Author) {
		owner, err := s.userModel.GetOwner()
		if err != nil {
			log.Panic(err)
		}
		return owner.Id
	}
	return p.Author
}

// validateUrl checks if the url is valid for creating or updating a new
// post.
//
// Returns errors.CONFLICT if the post slug already exists
// Or the slug contains the admin path, .i.e /admin
func (s *PostStore) validateUrl(slug string) error {
	const op = "PostsRepository.validateUrl"

	if s.ExistsBySlug(slug) {
		return &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("Could not create the post, the slug %v, already exists", slug), Operation: op}
	}

	slugArr := strings.Split(slug, "/")
	if len(slugArr) > 1 {
		if strings.Contains(slugArr[1], "admin") {
			return &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("Could not create the post, the path /admin is reserved"), Operation: op}
		}
	}

	return nil
}

func (s *PostStore) find(posts []domain.PostData, id int) bool {
	for _, v := range posts {
		if v.Id == id {
			return true
		}
	}
	return false
}

func (s *PostStore) format(rawPosts []PostRaw, layout bool) []domain.PostData {
	var posts = make([]domain.PostData, 0)

	for _, v := range rawPosts {

		if !s.find(posts, v.Id) {

			var category domain.Category
			if v.Category.Id != 0 {
				category = v.Category
			}

			p := domain.PostData{
				Post:     v.Post,
				Author:   v.Author.HideCredentials(),
				Category: &category,
				Fields:   make([]domain.PostField, 0),
			}

			if layout {
				p.Layout = s.fieldsModel.GetLayout(p)
			}

			posts = append(posts, p)
		}

		if v.Field.UUID != nil {
			field := domain.PostField{
				Id:            v.Field.Id,
				PostId:        v.Field.PostId,
				UUID:          *v.Field.UUID,
				Type:          v.Field.Type,
				Name:          v.Field.Name,
				Key:           v.Field.Key,
				Value:         nil,
				OriginalValue: domain.FieldValue(v.Field.OriginalValue),
			}

			for fi, fv := range posts {
				if fv.Id == v.Id {
					posts[fi].Fields = append(posts[fi].Fields, field)
				}
			}
		}
	}

	return posts
}"
}
{
file:./api/models/categories.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"strconv"
)

// CategoryRepository defines methods for Categories to interact with the database
type CategoryRepository interface {
	Get(meta params.Params) ([]domain.Category, int, error)
	GetById(id int) (domain.Category, error)
	GetByPost(pageId int) (*domain.Category, error)
	GetBySlug(slug string) (domain.Category, error)
	GetByName(name string) (domain.Category, error)
	GetParent(id int) (domain.Category, error)
	Create(c *domain.Category) (domain.Category, error)
	Update(c *domain.Category) (domain.Category, error)
	Delete(id int) error
	Exists(id int) bool
	ExistsByName(name string) bool
	ExistsBySlug(slug string) bool
	InsertPostCategory(postId int, categoryId *int) error
	DeletePostCategories(id int) error
	Total() (int, error)
}

// CategoryStore defines the data layer for Categories
type CategoryStore struct {
	db     *sqlx.DB
	config config.Configuration
}

// newCategories - Construct
func newCategories(db *sqlx.DB, config config.Configuration) *CategoryStore {
	return &CategoryStore{
		db:     db,
		config: config,
	}
}

// Get all categories
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no categories available.
func (s *CategoryStore) Get(meta params.Params) ([]domain.Category, int, error) {
	const op = "CategoryRepository.Get"

	var c []domain.Category
	q := fmt.Sprintf("SELECT * FROM categories")
	countQ := fmt.Sprintf("SELECT COUNT(*) FROM categories")

	// Apply filters to total and original query
	filter, err := filterRows(s.db, meta.Filters, "categories")
	if err != nil {
		return nil, -1, err
	}
	q += filter
	countQ += filter

	// Apply order
	q += fmt.Sprintf(" ORDER BY categories.%s %s", meta.OrderBy, meta.OrderDirection)

	// Apply pagination
	if !meta.LimitAll {
		q += fmt.Sprintf(" LIMIT %v OFFSET %v", meta.Limit, (meta.Page-1)*meta.Limit)
	}

	// Select categories
	if err := s.db.Select(&c, q); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get categories", Operation: op, Err: err}
	}

	// Return not found error if no posts are available
	if len(c) == 0 {
		return nil, -1, &errors.Error{Code: errors.NOTFOUND, Message: "No categories available", Operation: op}
	}

	// Count the total number of media
	var total int
	if err := s.db.QueryRow(countQ).Scan(&total); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of category items", Operation: op, Err: err}
	}

	return c, total, nil
}

// Get the category by Id
// Returns errors.NOTFOUND if the category was not found by the given Id.
func (s *CategoryStore) GetById(id int) (domain.Category, error) {
	const op = "CategoryRepository.GetById"
	var c domain.Category
	if err := s.db.Get(&c, "SELECT * FROM categories WHERE id = ?", id); err != nil {
		return domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get category with the ID: %d", id), Operation: op, Err: err}
	}
	return c, nil
}

// Get the category by post
// Returns errors.NOTFOUND if the category was not found by the given Post Id.
func (s *CategoryStore) GetByPost(postId int) (*domain.Category, error) {
	const op = "CategoryRepository.GetByPost"
	var c domain.Category
	if err := s.db.Get(&c, "SELECT * FROM categories c WHERE EXISTS (SELECT post_id FROM post_categories p WHERE p.post_id = ? AND c.id = p.category_id) LIMIT 1", postId); err != nil {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get category with the post ID: %d", postId), Operation: op, Err: err}
	}
	return &c, nil
}

// Get the category by slug
// Returns errors.NOTFOUND if the category was not found by the given slug.
func (s *CategoryStore) GetBySlug(slug string) (domain.Category, error) {
	const op = "CategoryRepository.GetBySlug"
	var c domain.Category
	if err := s.db.Get(&c, "SELECT * FROM categories WHERE slug = ?", slug); err != nil {
		return domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get category with the slug: %v", slug), Operation: op, Err: err}
	}
	return c, nil
}

// Get the category by slug
// Returns errors.NOTFOUND if the category was not found by the given slug.
func (s *CategoryStore) GetByName(name string) (domain.Category, error) {
	const op = "CategoryRepository.GetByName"
	var c domain.Category
	if err := s.db.Get(&c, "SELECT * FROM categories WHERE name = ?", name); err != nil {
		return domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get category with the name: %v", name), Operation: op, Err: err}
	}
	return c, nil
}

// Get the parent category by ID
// Returns errors.NOTFOUND if the category was not found by the given slug.
func (s *CategoryStore) GetParent(id int) (domain.Category, error) {
	const op = "CategoryRepository.GetByParent"
	var c domain.Category
	if err := s.db.Get(&c, "SELECT * FROM categories WHERE parent_id = ?", id); err != nil {
		return domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get category with the parent ID: %d", id), Operation: op, Err: err}
	}
	return c, nil
}

// Create a new category
// Returns errors.CONFLICT if the the category (name) already exists.
// Returns errors.INTERNAL if the SQL query was invalid or the function could not get the newly created ID.
func (s *CategoryStore) Create(c *domain.Category) (domain.Category, error) {
	const op = "CategoryRepository.Create"

	if s.ExistsByName(c.Name) {
		return domain.Category{}, &errors.Error{Code: errors.CONFLICT, Message: fmt.Sprintf("Could not create the post, the name %v, already exists", c.Name), Operation: op, Err: fmt.Errorf("name already exists")}
	}

	q := "INSERT INTO categories (uuid, slug, name, description, parent_id, resource, archive_id, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
	e, err := s.db.Exec(q, uuid.New().String(), c.Slug, c.Name, c.Description, c.ParentId, c.Resource, c.ArchiveId)
	if err != nil {
		return domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the category with the name: %v", c.Name), Operation: op, Err: err}
	}

	id, err := e.LastInsertId()
	if err != nil {
		return domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created category ID with the name: %v", c.Name), Operation: op, Err: err}
	}

	if c.ArchiveId != nil {
		err := s.changeArchivePostSlug(*c.ArchiveId, c.Slug, c.Resource)
		if err != nil {
			return domain.Category{}, err
		}
	}

	nc, err := s.GetById(int(id))
	if err != nil {
		return domain.Category{}, err
	}

	return nc, nil
}

// Update category
// Returns errors.NOTFOUND if the category was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *CategoryStore) Update(c *domain.Category) (domain.Category, error) {
	const op = "CategoryRepository.Update"

	oldCategory, err := s.GetById(c.Id)
	if err != nil {
		return domain.Category{}, err
	}

	q := "UPDATE categories SET slug = ?, name = ?, description = ?, resource = ?, parent_id = ?, archive_id = ?, updated_at = NOW() WHERE id = ?"
	_, err = s.db.Exec(q, c.Slug, c.Name, c.Description, c.Resource, c.ParentId, c.ArchiveId, c.Id)
	if err != nil {
		return domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the category with the name: %s", c.Name), Operation: op, Err: err}
	}

	if oldCategory.ArchiveId != c.ArchiveId {
		s.resolveNewPostSlug(*oldCategory.ArchiveId, c.Resource)
	}

	if oldCategory.Slug != c.Slug {
		var posts []domain.Post
		if err := s.db.Select(&posts, "SELECT * FROM posts WHERE slug LIKE '%"+oldCategory.Slug+"%'"); err != nil {
			return domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: "Could not get categories", Operation: op, Err: err}
		}
	}

	if c.ArchiveId != nil {
		err := s.changeArchivePostSlug(*c.ArchiveId, c.Slug, c.Resource)
		if err != nil {
			return domain.Category{}, err
		}
	}

	return *c, nil
}

// Delete category from categories and post categories table
// Returns errors.NOTFOUND if the category was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *CategoryStore) Delete(id int) error {
	const op = "CategoryRepository.Delete"

	c, err := s.GetById(id)
	if err != nil {
		return err
	}

	if _, err := s.db.Exec("DELETE FROM categories WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete the category with the ID: %v", id), Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM post_categories WHERE category_id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete post category with the ID: %v", id), Operation: op, Err: err}
	}

	if c.ArchiveId != nil {
		s.resolveNewPostSlug(*c.ArchiveId, c.Resource)
	}

	return nil
}

// Exists Checks if a category exists by the given Id
func (s *CategoryStore) Exists(id int) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT id FROM categories WHERE id = ?)", id).Scan(&exists)
	return exists
}

// Exists Checks if a category exists by the given name
func (s *CategoryStore) ExistsByName(name string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT name FROM categories WHERE name = ?)", name).Scan(&exists)
	return exists
}

// Exists Checks if a category exists by the given slug
func (s *CategoryStore) ExistsBySlug(slug string) bool {
	var exists bool
	_ = s.db.QueryRow("SELECT EXISTS (SELECT name FROM categories WHERE slug = ?)", slug).Scan(&exists)
	return exists
}

// InsertPostCategories - Insert into post categories with array of ID's.
// This function deletes all categories from the pivot before
// inserting again.
func (s *CategoryStore) InsertPostCategory(postId int, categoryId *int) error {
	const op = "CategoryRepository.InsertPostCategories"

	if _, err := s.db.Exec("DELETE FROM post_categories WHERE post_id = ?", postId); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete from the post categories table with the ID: %v", postId), Operation: op, Err: err}
	}

	if categoryId != nil {
		q := "INSERT INTO post_categories (post_id, category_id) VALUES (?, ?)"
		_, err := s.db.Exec(q, postId, categoryId)
		if err != nil {
			return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not insert into the post categories table with the ID: %v", postId), Operation: op, Err: err}
		}
	}

	return nil
}

// Delete from the post categories table
func (s *CategoryStore) DeletePostCategories(id int) error {
	const op = "CategoryRepository.DeletePostCategories"
	if _, err := s.db.Exec("DELETE FROM post_categories WHERE category_id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete the post categories with the post ID of: %d", id), Operation: op, Err: err}
	}
	return nil
}

// Get the total number of categories
func (s *CategoryStore) Total() (int, error) {
	const op = "CategoryRepository.Total"
	var total int
	if err := s.db.QueryRow("SELECT COUNT(*) FROM categories").Scan(&total); err != nil {
		return -1, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the total number of categories"), Operation: op, Err: err}
	}
	return total, nil
}

// changeArchivePostSlug changes the archive post slug when updating.
// Returns errors.INTERNAL if the SQL query was invalid or the new slug exists
func (s *CategoryStore) changeArchivePostSlug(id int, slug string, resource string) error {
	const op = "CategoryRepository.ChangeArchivePostSlug"
	newSlug := ""
	if resource != "pages" {
		newSlug += "/" + resource
	}
	newSlug += "/" + slug
	if _, err := s.db.Exec("UPDATE posts SET slug = ? WHERE id = ?", newSlug, id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the posts table with the new slug: %s", slug), Operation: op, Err: err}
	}
	return nil
}

// resolveNewPostSlug adds untitled to the new slug if it already exists.
func (s *CategoryStore) resolveNewPostSlug(id int, resource string) {
	slug := "untitled"
	counter := 1
	for {
		err := s.changeArchivePostSlug(id, slug, resource)
		if err != nil {
			slug = "untitled-" + strconv.Itoa(counter)
			counter++
			continue
		}
		break
	}
}"
}
{
file:./api/models/site.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ghodss/yaml"
	"github.com/jmoiron/sqlx"
	log "github.com/sirupsen/logrus"
	"os"
	"path/filepath"
	"strings"
)

// SiteRepository defines methods for Posts to interact with the database
type SiteRepository interface {
	GetGlobalConfig() domain.Site
	GetThemeConfig() domain.ThemeConfig
	GetTemplates() (domain.Templates, error)
	GetLayouts() (domain.Layouts, error)
}

// SiteStore defines the data layer for Posts
type SiteStore struct {
	db           *sqlx.DB
	config       config.Configuration
	optionsModel OptionsRepository
	cache        siteCache
}

// siteCache defines the options for caching
type siteCache struct {
	Site      bool
	Templates bool
	Resources bool
	Layout    bool
}

// newSite - Construct
func newSite(db *sqlx.DB, config config.Configuration) *SiteStore {
	const op = "SiteRepository.newSite"

	s := &SiteStore{
		db:     db,
		config: config,
	}

	om := newOptions(db, config)
	s.optionsModel = om

	return s
}

// GetGlobalConfig gets the site global config
func (s *SiteStore) GetGlobalConfig() domain.Site {
	const op = "SiteRepository.GetGlobalConfig"

	opts := s.optionsModel.GetStruct()

	return domain.Site{
		Title:       opts.SiteTitle,
		Description: opts.SiteDescription,
		Logo:        opts.SiteLogo,
		Url:         opts.SiteUrl,
		Version:     api.App.Version,
	}
}

// Get"s the themes configuration from the themes path
// Returns errors.INTERNAL if the unmarshalling was unsuccessful.
func (s *SiteStore) GetThemeConfig() domain.ThemeConfig {
	const op = "SiteRepository.GetThemeConfig"

	var dc = getDefaultThemeConfig()
	y, err := files.LoadFile(paths.Theme() + "/config.yml")
	if err != nil {
		log.WithFields(log.Fields{
			"error": errors.Error{Code: errors.INTERNAL, Message: "Unable to get retrieve theme config file", Operation: op, Err: err},
		}).Error()
	}
	if err := yaml.Unmarshal(y, &dc); err != nil {
		log.WithFields(log.Fields{
			"error": errors.Error{Code: errors.INTERNAL, Message: "Could not unmarshal the config.yml file", Operation: op, Err: err},
		}).Error()
	}

	return dc
}

// getDefaultThemeConfig
//
// Global Configuration, sets defaults to ensure that there are no
// empty values within the themes config to prevent any errors.
func getDefaultThemeConfig() domain.ThemeConfig {
	return domain.ThemeConfig{
		Theme:         domain.Theme{},
		Resources:     nil,
		AssetsPath:    "assets",
		FileExtension: ".cms",
		TemplateDir:   "templates",
		LayoutDir:     "layouts",
		Editor: domain.Editor{
			Modules: []string{
				"blockquote",
				"code_block",
				"code_block_highlight",
				"hardbreak",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"paragraph",
				"hr",
				"ul",
				"ol",
				"bold",
				"code",
				"italic",
				"link",
				"strike",
				"underline",
				"history",
				"search",
				"trailing_node",
				"color",
			},
			Options: map[string]interface{}{
				"palette": []string{
					"#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00",
					"#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF",
					"#333333", "#808080", "#CCCCCC", "#D33115", "#E27300", "#FCC400",
					"#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF",
					"#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00",
					"#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E",
				},
			},
		},
	}
}

// GetTemplates
//
// Get all templates stored within the templates directory
// Returns errors.INTERNAL if the template path is invalid.
func (s *SiteStore) GetTemplates() (domain.Templates, error) {
	const op = "SiteRepository.GetTemplates"

	themeConfig := s.GetThemeConfig()
	templateDir := paths.Theme() + "/" + themeConfig.TemplateDir

	files, err := s.walkMatch(templateDir, "*"+themeConfig.FileExtension)
	if err != nil {
		return domain.Templates{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get templates from the path: %s, with the file extension: %s", templateDir, "*"+themeConfig.FileExtension), Operation: op}
	}

	var templates []map[string]interface{}
	templates = append(templates, map[string]interface{}{
		"key":  "default",
		"name": "Default",
	})

	for _, file := range files {
		name := strings.Title(strings.ToLower(strings.Replace(file, "-", " ", -1)))
		t := map[string]interface{}{
			"key":  file,
			"name": name,
		}
		templates = append(templates, t)
	}

	t := domain.Templates{
		Template: templates,
	}

	if len(t.Template) == 0 {
		return domain.Templates{}, &errors.Error{Code: errors.NOTFOUND, Message: "No page templates available", Err: fmt.Errorf("no page templates available"), Operation: op}
	}

	return t, nil
}

// GetLayouts
//
// Get all layouts stored within the layouts directory
// Returns errors.INTERNAL if the layout path is invalid.
func (s *SiteStore) GetLayouts() (domain.Layouts, error) {
	const op = "SiteRepository.GetLayouts"

	themeConfig := s.GetThemeConfig()
	layoutDir := paths.Theme() + "/" + themeConfig.LayoutDir

	files, err := s.walkMatch(layoutDir, "*"+themeConfig.FileExtension)
	if err != nil {
		return domain.Layouts{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get templates from the path: %s, with the file extension: %s", layoutDir, "*"+themeConfig.FileExtension), Operation: op}
	}

	var layouts []map[string]interface{}
	layouts = append(layouts, map[string]interface{}{
		"key":  "default",
		"name": "Default",
	})

	for _, file := range files {
		name := strings.Title(strings.ToLower(strings.Replace(file, "-", " ", -1)))
		t := map[string]interface{}{
			"key":  file,
			"name": name,
		}
		layouts = append(layouts, t)
	}

	t := domain.Layouts{
		Layout: layouts,
	}

	if len(t.Layout) == 0 {
		return domain.Layouts{}, &errors.Error{Code: errors.NOTFOUND, Message: "No layouts available", Err: fmt.Errorf("no layouts available"), Operation: op}
	}

	return t, nil
}

// walkMatch
//
// Walk through root and return array of strings
// to the file path.
func (s *SiteStore) walkMatch(root, pattern string) ([]string, error) {
	const op = "SiteRepository.walkMatch"

	theme := s.GetThemeConfig()

	var matches []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if matched, err := filepath.Match(pattern, filepath.Base(path)); err != nil {
			return err
		} else if matched {
			template := strings.Replace(path, root+"/", "", 1)
			template = strings.Replace(template, theme.FileExtension, "", -1)
			matches = append(matches, template)
		}
		return nil
	})

	if err != nil {
		return nil, &errors.Error{Code: errors.INTERNAL, Message: "Unable to find page templates", Err: err, Operation: op}
	}

	return matches, nil
}"
}
{
file:./api/models/forms.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/forms"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/mail/events"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
)

// FormRepository defines methods for Posts to interact with the database
type FormRepository interface {
	Get(meta params.Params) ([]domain.Form, int, error)
	GetById(id int) (domain.Form, error)
	GetByUUID(uuid string) (domain.Form, error)
	//GetValidation(form *domain.Form) dynamicstruct.Builder
	Create(f *domain.Form) (domain.Form, error)
	Update(f *domain.Form) (domain.Form, error)
	Delete(id int) error
	Send(form *domain.Form, ip string, agent string) error
}

// FormsStore defines the data layer for Forms
type FormsStore struct {
	db        *sqlx.DB
	config    config.Configuration
	siteModel SiteRepository
}

// newSeoMeta - Construct
func newForms(db *sqlx.DB, config config.Configuration) *FormsStore {
	return &FormsStore{
		db:        db,
		config:    config,
		siteModel: newSite(db, config),
	}
}

// Get all forms
//
// Returns errors.INTERNAL if the SQL query was invalid.
// Returns errors.NOTFOUND if there are no forms available.
func (s *FormsStore) Get(meta params.Params) ([]domain.Form, int, error) {
	const op = "FormsRepository.Get"

	var f []domain.Form
	q := fmt.Sprintf("SELECT * FROM forms")
	countQ := fmt.Sprintf("SELECT COUNT(*) FROM forms")

	// Apply filters to total and original query
	filter, err := filterRows(s.db, meta.Filters, "forms")
	if err != nil {
		return nil, -1, err
	}
	q += filter
	countQ += filter

	// Apply order
	q += fmt.Sprintf(" ORDER BY forms.%s %s", meta.OrderBy, meta.OrderDirection)

	// Apply pagination
	if !meta.LimitAll {
		q += fmt.Sprintf(" LIMIT %v OFFSET %v", meta.Limit, (meta.Page-1)*meta.Limit)
	}

	// Select forms
	if err := s.db.Select(&f, q); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get forms", Operation: op, Err: err}
	}

	// Return not found error if no forms are available
	if len(f) == 0 {
		return []domain.Form{}, -1, &errors.Error{Code: errors.NOTFOUND, Message: "No forms available", Operation: op}
	}

	// Count the total number of forms
	var total int
	if err := s.db.QueryRow(countQ).Scan(&total); err != nil {
		return nil, -1, &errors.Error{Code: errors.INTERNAL, Message: "Could not get the total number of forms", Operation: op, Err: err}
	}

	//for _, v := range f {
	//forms.ToStruct(&v)
	//}

	return f, total, nil
}

// GetById - Get the form by Id
//
// Returns errors.NOTFOUND if the form was not found by the given ID.
func (s *FormsStore) GetById(id int) (domain.Form, error) {
	const op = "FormsRepository.GetByUUID"

	var f domain.Form
	if err := s.db.Get(&f, "SELECT * FROM forms WHERE id = ? LIMIT 1", id); err != nil {
		return domain.Form{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the form with the ID: %v", id), Operation: op, Err: err}
	}

	fields, err := s.GetFields(f.Id)
	if err == nil {
		f.Fields = fields
	}

	//f.Body = forms.ToStruct(&f)

	return f, nil
}

// GetByUUID returns a form by UUID.
//
// Returns errors.NOTFOUND if the form was not found by the given UUID.
func (s *FormsStore) GetByUUID(uuid string) (domain.Form, error) {
	const op = "FormsRepository.GetByUUID"

	var f domain.Form
	if err := s.db.Get(&f, "SELECT * FROM forms WHERE uuid = ? LIMIT 1", uuid); err != nil {
		return domain.Form{}, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the form with the UUID: %s", uuid), Operation: op, Err: err}
	}

	fields, err := s.GetFields(f.Id)
	if err == nil {
		f.Fields = fields
	}

	f.Body = forms.ToStruct(f)

	return f, nil
}

// GetFields returns form fields by form ID.
//
// Returns errors.NOTFOUND if there were no fields found by the given form ID.
func (s *FormsStore) GetFields(id int) ([]domain.FormField, error) {
	const op = "FormsRepository.GetFields"
	var f []domain.FormField
	if err := s.db.Select(&f, "SELECT * FROM form_fields WHERE form_id = ?", id); err != nil {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the form fields with the form ID: %v", id), Operation: op, Err: err}
	}
	if len(f) == 0 {
		return nil, &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("No form fields attached to the form with the ID: %v", id), Operation: op, Err: fmt.Errorf("no fields are attached to the form")}
	}
	return f, nil
}

// Create a new form
//
// Returns errors.CONFLICT if the the form (name) already exists.
// Returns errors.INTERNAL if the SQL query was invalid or the function could not get the newly created ID.
func (s *FormsStore) Create(f *domain.Form) (domain.Form, error) {
	const op = "FormsRepository.Create"

	e, err := s.db.Exec("INSERT INTO forms (uuid, name, email_send, email_message, email_subject, store_db, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())", uuid.New().String(), f.Name, f.EmailSend, f.EmailMessage, f.EmailSubject, f.StoreDB)
	if err != nil {
		return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the form with the name: %v", f.Name), Operation: op, Err: err}
	}

	id, err := e.LastInsertId()
	if err != nil {
		return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not get the newly created form ID with the name: %v", f.Name), Operation: op, Err: err}
	}
	f.Id = int(id)

	for _, v := range f.Fields {
		_, err := s.db.Exec("INSERT INTO form_fields (uuid, form_id, key, label, type, validation, required, options, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())", uuid.New().String(), f.Id, v.Key, v.Type, v.Validation, v.Required, v.Options)
		if err != nil {
			return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the form fields with the key: %v", v.Key), Operation: op, Err: err}
		}
	}

	nf, err := s.GetById(int(id))
	if err != nil {
		return domain.Form{}, err
	}

	return nf, nil
}

// Update category
//
// Returns errors.NOTFOUND if the form was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *FormsStore) Update(f *domain.Form) (domain.Form, error) {
	const op = "FormsRepository.Update"

	_, err := s.GetById(f.Id)
	if err != nil {
		return domain.Form{}, err
	}

	_, err = s.db.Exec("UPDATE forms SET name = ?, email_send = ?, email_message = ?, email_subject = ?, store_db = ?, updated_at = NOW() WHERE id = ?", f.Name, f.EmailSend, f.EmailMessage, f.EmailSubject, f.StoreDB, f.Id)
	if err != nil {
		return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not update the form with the name: %s", f.Name), Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM form_fields WHERE form_id = ?", f.Id); err != nil {
		return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete form fields with the form ID: %v", f.Id), Operation: op, Err: err}
	}

	for _, v := range f.Fields {
		_, err := s.db.Exec("INSERT INTO form_fields (uuid, form_id, key, label, type, validation, required, options, updated_at, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())", uuid.New().String(), f.Id, v.Key, v.Type, v.Validation, v.Required, v.Options)
		if err != nil {
			return domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the form fields with the key: %v", v.Key), Operation: op, Err: err}
		}
	}

	return *f, nil
}

// Delete form from forms and form fields table
//
// Returns errors.NOTFOUND if the category was not found.
// Returns errors.INTERNAL if the SQL query was invalid.
func (s *FormsStore) Delete(id int) error {
	const op = "FormsRepository.Delete"

	_, err := s.GetById(id)
	if err != nil {
		return err
	}

	if _, err := s.db.Exec("DELETE FROM forms WHERE id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete the form with the ID: %v", id), Operation: op, Err: err}
	}

	if _, err := s.db.Exec("DELETE FROM form_fields WHERE form_id = ?", id); err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete form fields with the form ID: %v", id), Operation: op, Err: err}
	}

	return nil
}

func (s *FormsStore) Send(form *domain.Form, ip string, agent string) error {
	const op = "FormsRepository.GetFields"

	fv, att, err := forms.NewReader(form).Values()
	if err != nil {
		return err
	}

	if form.StoreDB {
		err := s.storeSubmission(form, fv, ip, agent)
		if err != nil {
			return err
		}
	}

	if form.EmailSend {
		err := s.mailSubmission(form, fv, att)
		if err != nil {
			return err
		}
	}

	return nil
}

func (s *FormsStore) mailSubmission(form *domain.Form, values forms.FormValues, attachments forms.Attachments) error {
	const op = "FormsRepository.mailSubmission"
	fs, err := events.NewFormSend(s.config)
	if err != nil {
		return err
	}
	if err := fs.Send(&events.FormSendData{
		Site:   s.siteModel.GetGlobalConfig(),
		Form:   form,
		Values: values,
	}, attachments); err != nil {
		return err
	}
	return nil
}

func (s *FormsStore) storeSubmission(form *domain.Form, values forms.FormValues, ip string, agent string) error {
	const op = "FormsRepository.storeSubmission"

	f, err := values.JSON()
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not process the form fields for storing"), Operation: op, Err: err}
	}

	_, err = s.db.Exec("INSERT INTO form_submissions (uuid, form_id, fields, ip_address, user_agent, sent_at) VALUES (?, ?, ?, ?, ?, NOW())", uuid.New().String(), form.Id, f, ip, agent)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not create the form submission with the ID: %v", form.Id), Operation: op, Err: err}
	}

	return nil
}"
}
{
file:./api/models/model.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package models

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/database"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"regexp"
	"strings"
)

// Store defines all of the repositories used to interact with the database
type Store struct {
	Auth       AuthRepository
	Categories CategoryRepository
	Fields     FieldsRepository
	Forms      FormRepository
	Media      MediaRepository
	Options    OptionsRepository
	Posts      PostsRepository
	Roles      RoleRepository
	Site       SiteRepository
	User       UserRepository
	Config     config.Configuration
}

// Create a new database instance, connect to database.
func New(db *database.MySql, config config.Configuration) *Store {
	return &Store{
		Auth:       newAuth(db.Sqlx, config),
		Categories: newCategories(db.Sqlx, config),
		Forms:      newForms(db.Sqlx, config),
		Fields:     newFields(db.Sqlx, config),
		Media:      newMedia(db.Sqlx, config),
		Options:    newOptions(db.Sqlx, config),
		Posts:      newPosts(db.Sqlx, config),
		Roles:      newRoles(db.Sqlx, config),
		Site:       newSite(db.Sqlx, config),
		User:       newUser(db.Sqlx, config),
		Config:     config,
	}
}

// filterRows takes in the filters from the params set in http.Params
// If there is no filters set, an empty string will be returned.
// Returns errors.INVALID if the operator or column name was not found.
func filterRows(db *sqlx.DB, filters map[string][]params.Filter, table string) (string, error) {
	const op = "Model.filterRows"

	q := ""
	operators := []string{"=", ">", ">=", "<", "<=", "<>", "LIKE", "IN", "NOT LIKE", "like", "in", "not like"}

	if len(filters) != 0 {

		counter := 0
		for column, v := range filters {

			// Strip tags
			column = stripAlphaNum(strings.ToLower(column))

			// Check if the column exists before continuing
			var exists bool
			err := db.QueryRow("SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ? AND COLUMN_NAME = ?", table, column).Scan(&exists)
			if !exists || err != nil {
				return "", &errors.Error{
					Code:      errors.INVALID,
					Message:   fmt.Sprintf("The %s search query does not exist", column),
					Operation: op,
					Err:       fmt.Errorf("the %s search query does not exists when searching for %s", column, table)}
			}

			var fTable string
			if table != "" {
				fTable = table + "."
			}

			for index, filter := range v {

				// Strip tags
				operator := stripAlphaNum(filter.Operator)
				value := stripAlphaNum(filter.Value)

				// Account for like or not like values
				if operator == "like" || operator == "LIKE" || operator == "not like" || operator == "NOT LIKE" {
					value = "%" + value + "%"
				}

				// Check if the operator exists before continuing
				if opExists := helpers.StringInSlice(operator, operators); !opExists {
					return "", &errors.Error{
						Code:      errors.INVALID,
						Message:   fmt.Sprintf("The %s operator does not exist", operator),
						Operation: op,
						Err:       fmt.Errorf("the %s operator does not exists when searching for the %s", operator, fTable)}
				}

				if counter > 0 {
					q += fmt.Sprintf(" OR ")
				} else if index > 0 {
					q += fmt.Sprintf(" AND ")
				} else {
					q += fmt.Sprintf(" WHERE ")
				}

				q += fmt.Sprintf("(%s%s %s '%s')", fTable, column, operator, value)
			}

			counter++
		}
	}

	return q, nil
}

// stripAlphaNum - Strip characters and return alpha numeric string for
// database processing.
func stripAlphaNum(text string) string {
	reg := regexp.MustCompile("[^a-zA-Z0-9 =<>%.@/!+_']+")
	return reg.ReplaceAllString(text, "")
}"
}
{
file:./api/app.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// |||||||||||||||||||||||||||||||||||||||||||||||||||||||

package api

// SuperAdmin defines if the app (Verbis) is being developed
// or is being packaged out for distribution.
var SuperAdminString = "true"
var SuperAdmin = true

// App defines default values before the the user has defined
// any custom properties by updating the database.
var App = struct {
	Title       string
	Description string
	Url         string
	Logo        string
	Version     string
}{
	Title:       "Verbis",
	Description: "A Verbis website. Publish online, build a business, work from home",
	Url:         "http://127.0.0.1:8080",
	Logo:        "/verbis/images/verbis-logo.svg",
	Version:     "0.0.1",
}

// 50
var UploadChan = make(chan int, 10)
var ServeChan = make(chan int, 50)"
}
{
file:./api/http/handler/handler.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package handler

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/ainsleyclark/verbis/api/http/handler/frontend"
	"github.com/ainsleyclark/verbis/api/http/handler/spa"
)

// Handler defines all of handler funcs for the app.
type Handler struct {
	Auth       api.AuthHandler
	Cache      api.CacheHandler
	Categories api.CategoryHandler
	Media      api.MediaHandler
	Options    api.OptionsHandler
	Posts      api.PostHandler
	Site       api.SiteHandler
	User       api.UserHandler
	Forms      api.FormHandler
	Fields     api.FieldHandler
	Frontend   frontend.PublicHandler
	SEO        frontend.SEOHandler
	SPA        spa.SPAHandler
}

// Construct
func New(d *deps.Deps) *Handler {
	return &Handler{
		Auth:       api.NewAuth(d),
		Cache:      api.NewCache(d),
		Categories: api.NewCategories(d),
		Fields:     api.NewFields(d),
		Forms:      api.NewForms(d),
		Media:      api.NewMedia(d),
		Options:    api.NewOptions(d),
		Posts:      api.NewPosts(d),
		Site:       api.NewSite(d),
		User:       api.NewUser(d),
		SPA:        spa.NewSpa(d),
		Frontend:   frontend.NewPublic(d),
		SEO:        frontend.NewSEO(d),
	}
}"
}
{
file:./api/http/handler/frontend/seo_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frontend

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	storeMocks "github.com/ainsleyclark/verbis/api/mocks/models"
	mocks "github.com/ainsleyclark/verbis/api/mocks/render"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"net/http/httptest"
	"testing"
)

// Test_NewSEO - Test construct
func Test_NewSEO(t *testing.T) {

	optsMock := storeMocks.OptionsRepository{}
	optsMock.On("GetStruct").Return(domain.Options{})

	siteMock := storeMocks.SiteRepository{}
	siteMock.On("GetThemeConfig").Return(domain.ThemeConfig{}, nil)

	store := models.Store{
		Options: &optsMock,
		Site:    &siteMock,
	}
	config := config.Configuration{}
	want := &SEO{
		store:        &store,
		config:       config,
		sitemap:      render.NewSitemap(&store),
		ErrorHandler: &render.Errors{},
	}

	got := NewSEO(&store, config)
	assert.ObjectsAreEqual(got, want)
}

// TestSEOController_Robots - Test robots.txt route
func TestSEOController_Robots(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)

		seoSuccess := SEO{
			options: domain.Options{
				SeoRobotsServe: true,
				SeoRobots:      "test",
			},
		}

		seoSuccess.Robots(g)

		assert.Equal(t, 200, r.Code)
		assert.Equal(t, r.Body.String(), "test")
		assert.Equal(t, r.Header().Get("Content-Type"), "text/plain")
	})

	t.Run("Error", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)
		errorMock := &mocks.ErrorHandler{}
		errorMock.On("NotFound", g).Return("error")

		seoError := SEO{
			options: domain.Options{
				SeoRobotsServe: false,
			},
			ErrorHandler: errorMock,
		}

		seoError.Robots(g)

		assert.Equal(t, r.Body.String(), "")
	})
}

// TestSEOController_SiteMapIndex - Test /sitemap.xml route
func TestSEOController_SiteMapIndex(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)
		sitemapMock := &mocks.SiteMapper{}
		sitemapMock.On("GetIndex").Return([]byte("test"), nil)

		seoSuccess := SEO{
			sitemap: sitemapMock,
		}

		seoSuccess.SiteMapIndex(g)

		assert.Equal(t, 200, r.Code)
		assert.Equal(t, r.Body.String(), "test")
		assert.Equal(t, r.Header().Get("Content-Type"), "application/xml; charset=utf-8")
	})

	t.Run("Error", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)

		errorMock := &mocks.ErrorHandler{}
		errorMock.On("NotFound", g).Return("error")

		sitemapMock := &mocks.SiteMapper{}
		sitemapMock.On("GetIndex").Return(nil, fmt.Errorf("error"))

		seoError := SEO{
			sitemap:      sitemapMock,
			ErrorHandler: errorMock,
		}

		seoError.SiteMapIndex(g)

		assert.Equal(t, r.Body.String(), "")
		errorMock.AssertExpectations(t)
	})
}

// TestSEOController_SiteMapResource - Test /sitemaps/:resource route
func TestSEOController_SiteMapResource(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)
		sitemapMock := &mocks.SiteMapper{}
		sitemapMock.On("GetPages", mock.Anything).Return([]byte("test"), nil)

		seoSuccess := SEO{
			sitemap: sitemapMock,
		}

		seoSuccess.SiteMapResource(g)

		assert.Equal(t, 200, r.Code)
		assert.Equal(t, r.Body.String(), "test")
		assert.Equal(t, r.Header().Get("Content-Type"), "application/xml; charset=utf-8")
	})

	t.Run("Error", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)

		errorMock := &mocks.ErrorHandler{}
		errorMock.On("NotFound", g).Return("error")

		sitemapMock := &mocks.SiteMapper{}
		sitemapMock.On("GetPages", mock.Anything).Return(nil, fmt.Errorf("error"))

		seoError := SEO{
			sitemap:      sitemapMock,
			ErrorHandler: errorMock,
		}

		seoError.SiteMapResource(g)

		assert.Equal(t, r.Body.String(), "")
		errorMock.AssertExpectations(t)
	})
}

// TestSEOController_SiteMapXSL - Test .xsl files for styling XML.
func TestSEOController_SiteMapXSL(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)
		sitemapMock := &mocks.SiteMapper{}

		sitemapMock.On("GetXSL", mock.Anything).Return([]byte("test"), nil)

		seoSuccess := SEO{
			sitemap: sitemapMock,
		}

		seoSuccess.SiteMapXSL(g, true)

		assert.Equal(t, 200, r.Code)
		assert.Equal(t, r.Body.String(), "test")
		assert.Equal(t, r.Header().Get("Content-Type"), "application/xml; charset=utf-8")
	})

	t.Run("Error", func(t *testing.T) {

		r := httptest.NewRecorder()
		g, _ := gin.CreateTestContext(r)

		errorMock := &mocks.ErrorHandler{}
		errorMock.On("NotFound", g).Return("error")

		sitemapMock := &mocks.SiteMapper{}
		sitemapMock.On("GetXSL", mock.Anything).Return(nil, fmt.Errorf("error"))

		seoError := SEO{
			sitemap:      sitemapMock,
			ErrorHandler: errorMock,
		}

		seoError.SiteMapXSL(g, true)

		assert.Equal(t, r.Body.String(), "")
	})
}"
}
{
file:./api/http/handler/frontend/seo.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frontend

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
)

// SEOHandler defines methods for SEO routes to interact with the server
type SEOHandler interface {
	Robots(g *gin.Context)
	SiteMapIndex(g *gin.Context)
	SiteMapResource(g *gin.Context)
	SiteMapXSL(g *gin.Context, index bool)
}

// SEO defines the handler for all SEO Routes (sitemaps & robots)
type SEO struct {
	*deps.Deps
	sitemap render.SiteMapper
	options domain.Options
	render.ErrorHandler
}

// newSEO - Construct
func NewSEO(d *deps.Deps) *SEO {
	return &SEO{
		Deps:    d,
		sitemap: render.NewSitemap(d.Store),
		options: d.Store.Options.GetStruct(),
	}
}

// Robots - Obtains the Seo Robots field from the Options struct
// which is set in the settings, and returns the robots.txt
// file.
//
// Returns a 404 if the options don't allow serving of robots.txt
func (c *SEO) Robots(g *gin.Context) {
	const op = "FrontendHandler.Robots"

	if !c.options.SeoRobotsServe {
		c.NotFound(g)
		return
	}

	g.Data(200, "text/plain", []byte(c.options.SeoRobots))
}

// SiteMapIndex obtains the sitemap index file from the sitemap
// model Obtains the []bytes to send back as data when
// /sitemap.xml is visited.
//
// Returns a 404 if there was an error obtaining the XML file.
// or there was no resource items found.
func (c *SEO) SiteMapIndex(g *gin.Context) {
	const op = "FrontendHandler.SiteMapIndex"

	sitemap, err := c.sitemap.GetIndex()
	if err != nil {
		c.NotFound(g)
		return
	}

	g.Data(200, "application/xml; charset=utf-8", sitemap)
}

// SiteMapResource obtains the sitemap pages from the sitemap model
// by using the resource in the URL. Obtains the []bytes to send
// back as data when /:resource/sitemap.xml is visited.
//
// Returns a 404 if there was an error obtaining the XML file.
// or there was no resource items found.
func (c *SEO) SiteMapResource(g *gin.Context) {
	const op = "FrontendHandler.SiteMap"

	sitemap, err := c.sitemap.GetPages(g.Param("resource"))
	if err != nil {
		c.NotFound(g)
		return
	}

	g.Data(200, "application/xml; charset=utf-8", sitemap)
}

// SiteMapXSL - Serves the XSL files for use with any .xml file that
// is used to serve the sitemap.
//
// Returns a 404 if there was an error obtaining the XSL.
func (c *SEO) SiteMapXSL(g *gin.Context, index bool) {
	const op = "FrontendHandler.SiteMapIndexXSL"

	sitemap, err := c.sitemap.GetXSL(index)
	if err != nil {
		c.NotFound(g)
		return
	}

	g.Data(200, "application/xml; charset=utf-8", sitemap)
}"
}
{
file:./api/http/handler/frontend/public.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frontend

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
)

// PublicHandler defines methods for the frontend to interact with the server
type PublicHandler interface {
	GetUploads(g *gin.Context)
	GetAssets(g *gin.Context)
	Serve(g *gin.Context)
}

// Public defines the handler for all frontend routes
type Public struct {
	*deps.Deps
	render render.Renderer
}

// NewPublic - Construct
func NewPublic(d *deps.Deps) *Public {
	return &Public{
		Deps:   d,
		render: render.NewRender(d),
	}
}

// GetUploads retrieves images & media in the uploads folder, returns webp if accepts.
func (c *Public) GetUploads(g *gin.Context) {
	const op = "FrontendHandler.GetUploads"

	mimeType, file, err := c.render.Upload(g)
	if err != nil {
		c.render.NotFound(g)
		return
	}

	g.Data(200, *mimeType, *file)
}

// GetAssets retrieves assets from the theme path, returns webp if accepts.
func (c *Public) GetAssets(g *gin.Context) {
	const op = "FrontendHandler.GetAssets"

	mimeType, file, err := c.render.Asset(g)
	if err != nil {
		c.render.NotFound(g)
		return
	}

	g.Data(200, *mimeType, *file)
}

// Serve the front end website
func (c *Public) Serve(g *gin.Context) {
	const op = "FrontendHandler.Serve"

	page, err := c.render.Page(g)
	if errors.Code(err) == errors.NOTFOUND {
		c.render.NotFound(g)
		return
	} else if err != nil {
		g.Data(500, "text/html", page)
		return
	}

	g.Data(200, "text/html", page)
}"
}
{
file:./api/http/handler/frontend/public_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frontend

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/mime"
	storeMocks "github.com/ainsleyclark/verbis/api/mocks/models"
	mocks "github.com/ainsleyclark/verbis/api/mocks/render"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// getPublicMock is a helper to obtain a mock Public
// handler for testing.
func getPublicMock(r render.Renderer, gin *gin.Context) *Public {
	mockError := mocks.ErrorHandler{}
	mockError.On("NotFound", gin).Run(func(args mock.Arguments) {
		gin.AbortWithStatus(404)
		return
	})
	return &Public{
		config:       config.Configuration{},
		ErrorHandler: &mockError,
		render:       r,
	}
}

// spaTest represents the suite of testing methods for SPA routes.
type frontendTest struct {
	testing  *testing.T
	recorder *httptest.ResponseRecorder
	gin      *gin.Context
	engine   *gin.Engine
	apiPath  string
}

// setup helper for frontend routes.
func setup(t *testing.T) *frontendTest {
	gin.SetMode(gin.TestMode)
	rr := httptest.NewRecorder()
	g, engine := gin.CreateTestContext(rr)

	// Set api path
	wd, err := os.Getwd()
	assert.NoError(t, err)
	apiPath := filepath.Join(filepath.Dir(wd), "../..")

	return &frontendTest{
		testing:  t,
		recorder: rr,
		gin:      g,
		engine:   engine,
		apiPath:  apiPath,
	}
}

// Test_NewFrontend - Test construct
func Test_NewFrontend(t *testing.T) {

	optsMock := storeMocks.OptionsRepository{}
	optsMock.On("GetStruct").Return(domain.Options{})

	siteMock := storeMocks.SiteRepository{}
	siteMock.On("GetThemeConfig").Return(domain.ThemeConfig{}, nil)

	store := models.Store{
		Options: &optsMock,
		Site:    &siteMock,
	}
	config := config.Configuration{}
	want := &Public{
		store:        &store,
		config:       config,
		render:       render.NewRender(&store, config),
		ErrorHandler: &render.Errors{},
	}

	got := NewPublic(&store, config)
	assert.ObjectsAreEqual(got, want)
}

// TestPublic_GetUploads - Test serving of uploads
func TestPublic_GetUploads(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {
		rr := setup(t)

		image := "/test/testdata/images/gopher.svg"

		req, err := http.NewRequest("GET", "/uploads/gopher.svg", nil)
		assert.NoError(t, err)

		file, err := ioutil.ReadFile(rr.apiPath + image)
		assert.NoError(t, err)
		mimeType := mime.TypeByExtension(strings.ReplaceAll(filepath.Ext(image), ".", ""))

		renderMock := mocks.Renderer{}
		renderMock.On("Upload", rr.gin).Return(&mimeType, &file, nil)

		rr.engine.GET("/uploads/*any", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).GetUploads(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, file, rr.recorder.Body.Bytes())
		assert.Equal(t, "image/svg+xml", rr.recorder.Header().Get("Content-Type"))
		assert.Equal(t, 200, rr.recorder.Code)
	})

	t.Run("Not Found", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/uploads/gopher.svg", nil)
		assert.NoError(t, err)

		renderMock := mocks.Renderer{}
		renderMock.On("Upload", rr.gin).Return(nil, nil, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})

		rr.engine.GET("/uploads/*any", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).GetUploads(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, 404, rr.recorder.Code)
	})
}

// TestPublic_GetAssets - Test serving of assets (under theme path)
func TestPublic_GetAssets(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {
		rr := setup(t)

		image := "/test/testdata/images/gopher.svg"

		req, err := http.NewRequest("GET", "/uploads/gopher.svg", nil)
		assert.NoError(t, err)

		file, err := ioutil.ReadFile(rr.apiPath + image)
		assert.NoError(t, err)
		mimeType := mime.TypeByExtension(strings.ReplaceAll(filepath.Ext(image), ".", ""))

		renderMock := mocks.Renderer{}
		renderMock.On("Asset", rr.gin).Return(&mimeType, &file, nil)

		rr.engine.GET("/uploads/*any", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).GetAssets(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, file, rr.recorder.Body.Bytes())
		assert.Equal(t, "image/svg+xml", rr.recorder.Header().Get("Content-Type"))
		assert.Equal(t, 200, rr.recorder.Code)
	})

	t.Run("Not Found", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/uploads/gopher.svg", nil)
		assert.NoError(t, err)

		renderMock := mocks.Renderer{}
		renderMock.On("Asset", rr.gin).Return(nil, nil, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})

		rr.engine.GET("/uploads/*any", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).GetAssets(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, 404, rr.recorder.Code)
	})
}

// TestPublic_Serve - Test serving of pages
func TestPublic_Serve(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Success", func(t *testing.T) {
		rr := setup(t)

		html := "/test/testdata/html/index.html"

		req, err := http.NewRequest("GET", "/page", nil)
		assert.NoError(t, err)

		file, err := ioutil.ReadFile(rr.apiPath + html)
		assert.NoError(t, err)
		mimeType := mime.TypeByExtension(strings.ReplaceAll(filepath.Ext(html), ".", ""))

		renderMock := mocks.Renderer{}
		renderMock.On("Page", rr.gin).Return(file, nil)

		rr.engine.GET("/page", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).Serve(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, file, rr.recorder.Body.Bytes())
		assert.Equal(t, mimeType, rr.recorder.Header().Get("Content-Type"))
		assert.Equal(t, 200, rr.recorder.Code)
	})

	t.Run("Not Found", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/page", nil)
		assert.NoError(t, err)

		renderMock := mocks.Renderer{}
		renderMock.On("Page", rr.gin).Return(nil, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})

		rr.engine.GET("/page", func(g *gin.Context) {
			getPublicMock(&renderMock, rr.gin).Serve(rr.gin)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, 404, rr.recorder.Code)
	})
}"
}
{
file:./api/http/handler/spa/spa.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spa

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/helpers/mime"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
	"io/ioutil"
	"strings"
)

// SPAHandler defines methods for the SPA (Vue) to interact with the server
type SPAHandler interface {
	Serve(g *gin.Context)
}

// SPA defines the handler for the SPA
type SPA struct {
	*deps.Deps
	render render.Renderer
}

// newSpa - Construct
func NewSpa(d *deps.Deps) *SPA {
	return &SPA{
		render: render.NewRender(d),
	}
}

var (
	// Base path of the app
	basePath = paths.Base()
	// SPA path (Vue)
	adminPath = paths.Admin()
)

// Serve all of the administrator & operator assets and serve the
// file extension based on the content type.
func (c *SPA) Serve(g *gin.Context) {

	path := g.Request.URL.Path

	// If the path is a file
	if strings.Contains(path, ".") {

		path = strings.Replace(path, "/admin", "", -1)
		extensionArr := strings.Split(path, ".")
		extension := extensionArr[len(extensionArr)-1]
		data, err := ioutil.ReadFile(adminPath + path)

		if err != nil {
			// TODO, log here! Error getting admin file
			c.render.NotFound(g)
			return
		}

		contentType := mime.TypeByExtension(extension)
		g.Data(200, contentType, data)

		// Page catching
	} else {
		data, err := ioutil.ReadFile(adminPath + "/index.html")

		if err != nil {
			// TODO, log here! Error getting admin file
			c.render.NotFound(g)
			return
		}

		g.Data(200, "text/html; charset=utf-8", data)
	}
}"
}
{
file:./api/http/handler/spa/spa_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spa

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	siteMock "github.com/ainsleyclark/verbis/api/mocks/models"
	mocks "github.com/ainsleyclark/verbis/api/mocks/render"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
)

// getSPAMock is a helper to obtain a mock SPA handler
// for testing.
func getSPAMock() *SPA {
	mockError := mocks.ErrorHandler{}
	mockError.On("NotFound", mock.Anything, mock.Anything)
	return &SPA{
		config:       config.Configuration{},
		ErrorHandler: &mockError,
	}
}

// spaTest represents the suite of testing methods for SPA routes.
type spaTest struct {
	testing  *testing.T
	recorder *httptest.ResponseRecorder
	gin      *gin.Context
	engine   *gin.Engine
}

// setup helper for SPA routes.
func setup(t *testing.T) *spaTest {
	gin.SetMode(gin.TestMode)
	rr := httptest.NewRecorder()
	g, engine := gin.CreateTestContext(rr)

	return &spaTest{
		testing:  t,
		recorder: rr,
		gin:      g,
		engine:   engine,
	}
}

// Test_NewSPA - Test construct
func Test_NewSPA(t *testing.T) {
	config := config.Configuration{}
	want := &SPA{
		config:       config,
		ErrorHandler: &render.Errors{},
	}
	mockSite := siteMock.SiteRepository{}
	mockSite.On("GetThemeConfig").Return(domain.ThemeConfig{})
	models := models.Store{
		Site: &mockSite,
	}

	got := NewSpa(&models, config)
	assert.ObjectsAreEqual(got, want)
}

// TestSPA_Serve - Test serving of files for SPA handler.
func TestSPA_Serve(t *testing.T) {

	// Save current function and restore at the end:
	oldBasePath := basePath
	oldAdminPath := adminPath
	defer func() {
		basePath = oldBasePath
		adminPath = oldAdminPath
	}()

	// Set api path
	wd, err := os.Getwd()
	assert.NoError(t, err)
	apiPath := filepath.Join(filepath.Dir(wd), "../..")

	// Reassign paths
	adminPath = apiPath + "/test/testdata/spa"
	basePath = apiPath + "/test/testdata/spa"
	imagePath := "/images/gopher.svg"
	htmlPath := "/index.html"

	// Test success getting svg file
	t.Run("Success File", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/admin"+imagePath, nil)
		assert.NoError(t, err)

		rr.engine.GET("/admin"+imagePath, func(g *gin.Context) {
			getSPAMock().Serve(g)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		data, err := ioutil.ReadFile(basePath + imagePath)
		if err != nil {
			t.Errorf("could not open file with the path %s", basePath+imagePath)
		}

		assert.Equal(t, data, rr.recorder.Body.Bytes())
		assert.Equal(t, 200, rr.recorder.Code)
		assert.Equal(t, "image/svg+xml", rr.recorder.Header().Get("Content-Type"))
	})

	// Test 404 of file
	t.Run("404 File", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/admin/wrongimage.svg", nil)
		assert.NoError(t, err)

		rr.engine.GET("/admin/wrongimage.svg", func(g *gin.Context) {
			mockError := mocks.ErrorHandler{}
			mockError.On("NotFound", g, mock.Anything).Run(func(args mock.Arguments) {
				g.AbortWithStatus(404)
			})
			spa := &SPA{
				config:       config.Configuration{},
				ErrorHandler: &mockError,
			}
			spa.Serve(g)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, 404, rr.recorder.Code)
	})

	//Test success getting html file
	t.Run("Success HTML", func(t *testing.T) {
		rr := setup(t)

		req, err := http.NewRequest("GET", "/admin", nil)
		assert.NoError(t, err)

		rr.engine.GET("/admin", func(g *gin.Context) {
			getSPAMock().Serve(g)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		data, err := ioutil.ReadFile(basePath + htmlPath)
		if err != nil {
			t.Errorf("could not open file with the path %s", basePath+htmlPath)
		}

		assert.Equal(t, string(data), rr.recorder.Body.String())
		assert.Equal(t, 200, rr.recorder.Code)
		assert.Equal(t, "text/html; charset=utf-8", rr.recorder.Header().Get("Content-Type"))
	})

	// Test 404 of file
	t.Run("404 HTML", func(t *testing.T) {
		rr := setup(t)

		adminPath = apiPath + "/test/testdata"

		req, err := http.NewRequest("GET", "/admin", nil)
		assert.NoError(t, err)

		rr.engine.GET("/admin", func(g *gin.Context) {
			mockError := mocks.ErrorHandler{}
			mockError.On("NotFound", g, mock.Anything).Run(func(args mock.Arguments) {
				g.AbortWithStatus(404)
			})
			spa := &SPA{
				config:       config.Configuration{},
				ErrorHandler: &mockError,
			}
			spa.Serve(g)
		})
		rr.engine.ServeHTTP(rr.recorder, req)

		assert.Equal(t, 404, rr.recorder.Code)
	})
}"
}
{
file:./api/http/handler/api/fields.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
	"strconv"
)

// FieldHandler defines methods for fields to interact with the server
type FieldHandler interface {
	Get(g *gin.Context)
}

// Fields defines the handler for Fields
type Fields struct {
	*deps.Deps
}

// newFields - Construct
func NewFields(d *deps.Deps) *Fields {
	return &Fields{d}
}

// Get - Filter fields and get layouts based on query params.
//
// Returns 200 if login was successful.
// Returns 500 if the layouts failed to be obtained.
func (c *Fields) Get(g *gin.Context) {
	const op = "FieldHandler.Get"

	resource := g.Query("resource")

	userId, err := strconv.Atoi(g.Query("user_id"))
	if err != nil || userId == 0 {
		owner, err := c.Store.User.GetOwner()
		if err != nil {
			Respond(g, 500, errors.Message(err), err)
		}
		userId = owner.Id
	}

	categoryId, err := strconv.Atoi(g.Query("category_id"))
	if err != nil {
		categoryId = 0
		//Respond(g, 400, "Field search failed, wrong type passed to category id", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})x
	}

	post := domain.PostData{
		Post: domain.Post{
			Id:                0,
			Slug:              "",
			Title:             "",
			Status:            "",
			Resource:          &resource,
			PageTemplate:      g.Query("page_template"),
			PageLayout:        g.Query("layout"),
			CodeInjectionHead: nil,
			CodeInjectionFoot: nil,
			UserId:            userId,
		},
	}

	// Get the author associated with the post
	author, err := c.Store.User.GetById(post.UserId)
	if err != nil {
		post.Author = author.HideCredentials()
	}

	// Get the categories associated with the post
	category, err := c.Store.Categories.GetById(categoryId)
	if err != nil {
		post.Category = &category
	}

	fields := c.Store.Fields.GetLayout(post)

	Respond(g, 200, "Successfully obtained fields", fields)
}"
}
{
file:./api/http/handler/api/respond.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	validation "github.com/ainsleyclark/verbis/api/helpers/vaidation"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"reflect"
	"time"
)

type RespondJson struct {
	Status  int         `json:"status"`
	Error   bool        `json:"error"`
	Message string      `json:"message"`
	Meta    Meta        `json:"meta"`
	Data    interface{} `json:"data"`
}

type Meta struct {
	RequestTime  string      `json:"request_time"`
	ResponseTime string      `json:"response_time"`
	LatencyTime  string      `json:"latency_time"`
	Pagination   interface{} `json:"pagination,omitempty"`
}

type ValidationErrJson struct {
	Errors interface{} `json:"errors"`
}

// Main JSON responder.
func Respond(g *gin.Context, status int, message string, data interface{}, pagination ...*http.Pagination) {

	// Check the response data
	if d, changed := checkResponseData(g, data); changed {
		data = d
	}

	g.Set("verbis_message", message)

	// If there is no error set the status to 200
	hasError := false
	if status != 200 {
		hasError = true
	}

	// Check if the pagination is empty
	var returnPagination interface{}
	if len(pagination) == 0 {
		pagination = nil
	} else if pagination[0] == nil {
		returnPagination = nil
	} else {
		returnPagination = pagination[0]
	}

	// Construct meta
	m := calculateRequestTime(g)
	m.Pagination = returnPagination

	// Set up the response JSON
	respond := RespondJson{
		Status:  status,
		Message: message,
		Error:   hasError,
		Meta:    m,
		Data:    data,
	}

	// Respond
	g.JSON(status, respond)

	return
}

// Abort with JSON
func AbortJSON(g *gin.Context, status int, message string, data interface{}) {

	// Check the response data
	if d, changed := checkResponseData(g, data); changed {
		data = d
	}

	// If there is no error set the status to 200
	hasError := false
	if status != 200 {
		hasError = true
	}

	// Set up the response JSON
	respond := RespondJson{
		Status:  status,
		Error:   hasError,
		Message: message,
		Meta:    calculateRequestTime(g),
		Data:    data,
	}

	// Respond
	g.AbortWithStatusJSON(status, respond)
}

// Handle 404s.
func notFound(g *gin.Context) {
	g.AbortWithError(404, fmt.Errorf("Page not found"))
}

// checkResponseData checks what type of data is passed and processes it
// accordingly. errors, empty slices & interfaces as well as validation.
// Returns true if the data has changed.
func checkResponseData(g *gin.Context, data interface{}) (interface{}, bool) {

	if data == nil {
		return gin.H{}, true
	}

	// Get the type of data
	dataType := reflect.TypeOf(data).String()

	// Report to the log if data is an error
	if dataType == "*errors.Error" {
		errData := data.(*errors.Error)
		g.Set("verbis_error", errData)

		if errData.Err != nil {
			errType := reflect.TypeOf(errData.Err).String()

			if errType == "validator.ValidationErrors" && errData.Code == errors.INVALID {
				validationErrors, _ := errData.Err.(validator.ValidationErrors)
				v := validation.New()
				data = &ValidationErrJson{
					Errors: v.Process(validationErrors),
				}
				return data, true
			} else {
				return gin.H{}, true
			}
		}

		return gin.H{}, true
	}

	// Check if data is nil or an empty slice, if it is return empty object
	if reflect.TypeOf(data).Kind().String() == "slice" {
		s := reflect.ValueOf(data)
		ret := make([]interface{}, s.Len())
		if len(ret) == 0 {
			return gin.H{}, true
		}
	}

	// If data is of type validation errors, pass to validator

	// If the data is type unmarshal error
	if dataType == "*json.UnmarshalTypeError" {
		e, _ := data.(*json.UnmarshalTypeError)
		data = &ValidationErrJson{
			Errors: validation.ValidationError{
				Key:     e.Field,
				Type:    "Unmarshal error",
				Message: "Invalid type passed to " + e.Struct + " struct.",
			},
		}
		return data, true
	}

	return gin.H{}, false
}

// calculateRequestTime processes the request and response time and works out latency time.
// Returns Meta
func calculateRequestTime(g *gin.Context) Meta {
	var startTime = time.Now()

	if t, exists := g.Get("request_time"); exists {
		startTime = t.(time.Time)
	}
	latencyTime := time.Since(startTime)

	return Meta{
		RequestTime:  startTime.UTC().String(),
		ResponseTime: time.Now().UTC().String(),
		LatencyTime:  latencyTime.Round(time.Microsecond).String(),
	}
}"
}
{
file:./api/http/handler/api/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	"strconv"
)

// MediaHandler defines methods for Media Items to interact with the server
type MediaHandler interface {
	Get(g *gin.Context)
	GetById(g *gin.Context)
	Upload(g *gin.Context)
	Update(g *gin.Context)
	Delete(g *gin.Context)
}

// Media defines the handler for Posts
type Media struct {
	*deps.Deps
}

// newMedia - Construct
func NewMedia(d *deps.Deps) *Media {
	return &Media{d}
}

// Get all media items
//
// Returns 200 if there are no media items or success.
// Returns 500 if there was an error getting the media items.
// Returns 400 if there was conflict or the request was invalid.
func (c *Media) Get(g *gin.Context) {
	const op = "MediaHandler.Get"

	p := params.ApiParams(g, DefaultParams).Get()

	media, total, err := c.Store.Media.Get(p)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	pagination := http.NewPagination().Get(p, total)

	Respond(g, 200, "Successfully obtained media", media, pagination)
}

// Get By ID
//
// Returns 200 if the media items were obtained.
// Returns 400 if the ID wasn't passed or failed to convert.
// Returns 500 if there as an error obtaining the media items.
func (c *Media) GetById(g *gin.Context) {
	const op = "MediaHandler.GetById"

	paramId := g.Param("id")
	id, err := strconv.Atoi(paramId)
	if err != nil {
		Respond(g, 400, "Pass a valid number to obtain the media item by ID", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	media, err := c.Store.Media.GetById(id)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained media item with ID: "+paramId, media)
}

// Upload - if there were no files attached to the body,
// more than 1 attached to the body or the validation failed.
//
// Returns 401 if the user wasn't authenticated.
// Returns 415 if the media item failed to validate.
// Returns 200 if the media item was successfully uploaded.
// Returns 500 if there as an error uploading the media item.
// Returns 400 if the file length was incorrect or there were no files.
func (c *Media) Upload(g *gin.Context) {
	const op = "MediaHandler.Upload"

	form, err := g.MultipartForm()
	if err != nil {
		Respond(g, 400, "No files attached to the upload", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	files := form.File["file"]

	if len(files) > 1 {
		Respond(g, 400, "Files are only permitted to be uploaded one at a time", &errors.Error{Code: errors.INVALID, Err: fmt.Errorf("too many files uploaded at once"), Operation: op})
		return
	}

	if len(files) == 0 {
		Respond(g, 400, "Attach a file to the request to be uploaded", &errors.Error{Code: errors.INVALID, Err: fmt.Errorf("no files attached to upload"), Operation: op})
		return
	}

	if err := c.Store.Media.Validate(files[0]); err != nil {
		Respond(g, 415, errors.Message(err), err)
		return
	}

	media, err := c.Store.Media.Upload(files[0], g.Request.Header.Get("token"))
	if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully uploaded media item", media)
}

// Update
//
// Returns 200 if the media item was updated successfully.
// Returns 400 if the ID wasn't passed or failed to convert.
// Returns 500 if there was an error updating the media item.
func (c *Media) Update(g *gin.Context) {
	const op = "MediaHandler.Update"

	var m domain.Media
	if err := g.ShouldBindJSON(&m); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update the media item", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	m.Id = id

	err = c.Store.Media.Update(&m)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully updated media item with ID: "+strconv.Itoa(id), m)
}

// Delete
//
// Returns 200 if the media item was deleted.
// Returns 500 if there was an error updating the media item.
// Returns 400 if the the media item wasn't found or no ID was passed.
func (c *Media) Delete(g *gin.Context) {
	const op = "MediaHandler.Delete"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to delete a media item", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.Media.Delete(id)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully deleted media item with ID: "+strconv.Itoa(id), nil)
}"
}
{
file:./api/http/handler/api/auth_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"testing"
	"time"
)

// getAuthMock is a helper to obtain a mock auth controller
// for testing.
func getAuthMock(m models.AuthRepository) *Auth {
	return &Auth{
		store: &models.Store{
			Auth: m,
		},
	}
}

// Test_NewAuth - Test construct
func Test_NewAuth(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Auth{
		store:  &store,
		config: config,
	}
	got := NewAuth(&store, config)
	assert.Equal(t, got, want)
}

// TestAuth_Get - Test Login route
func TestAuth_Login(t *testing.T) {

	login := domain.Login{Email: "info@verbiscms.com", Password: "password"}
	loginBadValidation := domain.Login{Password: "password"}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		cookie  bool
		mock    func(m *mocks.AuthRepository)
	}{
		"Success": {
			want:    `{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully logged in & session started",
			input:   login,
			cookie:  true,
			mock: func(m *mocks.AuthRepository) {
				m.On("Authenticate", login.Email, login.Password).Return(domain.User{}, nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"email","message":"Email is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   loginBadValidation,
			cookie:  false,
			mock: func(m *mocks.AuthRepository) {
				m.On("Authenticate", loginBadValidation.Email, loginBadValidation.Email).Return(domain.User{}, fmt.Errorf("error"))
			},
		},
		"Not Authorised": {
			want:    `{}`,
			status:  401,
			message: "unauthorised",
			input:   login,
			cookie:  false,
			mock: func(m *mocks.AuthRepository) {
				m.On("Authenticate", login.Email, login.Password).Return(domain.User{}, &errors.Error{Code: errors.INVALID, Message: "unauthorised"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.AuthRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/login", "/login", bytes.NewBuffer(body), func(g *gin.Context) {
				getAuthMock(mock).Login(g)
			})

			rr.Run(test.want, test.status, test.message)

			if test.cookie {
				cookie := http.Cookie{
					Name:     "verbis-session",
					Expires:  time.Time{},
					MaxAge:   172800,
					Path:     "/",
					Raw:      "verbis-session=; Path=/; Max-Age=172800; HttpOnly",
					HttpOnly: true,
				}
				assert.Equal(t, rr.recorder.Result().Cookies()[0], &cookie)
			}
		})
	}
}

// TestAuth_Logout - Test Logout route
func TestAuth_Logout(t *testing.T) {

	token := "test"

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   string
		cookie  bool
		mock    func(m *mocks.AuthRepository)
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully logged out",
			input:   "test",
			cookie:  true,
			mock: func(m *mocks.AuthRepository) {
				m.On("Logout", token).Return(-1, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   token,
			cookie:  false,
			mock: func(m *mocks.AuthRepository) {
				m.On("Logout", token).Return(-1, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   token,
			cookie:  false,
			mock: func(m *mocks.AuthRepository) {
				m.On("Logout", token).Return(-1, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.AuthRepository{}
			test.mock(mock)

			rr.NewRequest("POST", "/logout", nil)
			rr.gin.Request.Header.Set("token", test.input)

			getAuthMock(mock).Logout(rr.gin)

			rr.Run(test.want, test.status, test.message)

			if test.cookie {
				cookie := http.Cookie{
					Name:     "verbis-session",
					Expires:  time.Time{},
					MaxAge:   -1,
					Path:     "/",
					Raw:      "verbis-session=; Path=/; Max-Age=0; HttpOnly",
					HttpOnly: true,
				}
				assert.Equal(t, rr.recorder.Result().Cookies()[0], &cookie)
			}
		})
	}
}

// TestAuth_ResetPassword - Test ResetPassword route
func TestAuth_ResetPassword(t *testing.T) {

	rp := domain.ResetPassword{
		NewPassword:     "password",
		ConfirmPassword: "password",
		Token:           "token",
	}

	rpdBadValidation := domain.ResetPassword{
		NewPassword: "password",
		Token:       "token",
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.AuthRepository)
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully reset password",
			input:   rp,
			mock: func(m *mocks.AuthRepository) {
				m.On("ResetPassword", rp.Token, rp.NewPassword).Return(nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"confirm_password","message":"Confirm Password must equal the New Password.","type":"eqfield"}]}`,
			status:  400,
			message: "Validation failed",
			input:   rpdBadValidation,
			mock: func(m *mocks.AuthRepository) {
				m.On("ResetPassword", rpdBadValidation.Token, rpdBadValidation.NewPassword).Return(nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   rp,
			mock: func(m *mocks.AuthRepository) {
				m.On("ResetPassword", rp.Token, rp.NewPassword).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   rp,
			mock: func(m *mocks.AuthRepository) {
				m.On("ResetPassword", rp.Token, rp.NewPassword).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.AuthRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/reset", "/reset", bytes.NewBuffer(body), func(g *gin.Context) {
				getAuthMock(mock).ResetPassword(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestAuth_VerifyPasswordToken - Test VerifyPasswordToken route
func TestAuth_VerifyPasswordToken(t *testing.T) {

	token := "test"

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   string
		mock    func(m *mocks.AuthRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully verified token",
			input:   token,
			mock: func(m *mocks.AuthRepository) {
				m.On("VerifyPasswordToken", token).Return(nil)
			},
			url: "/verify/" + token,
		},
		"Not Found": {
			want:    `{}`,
			status:  404,
			message: "not found",
			input:   token,
			mock: func(m *mocks.AuthRepository) {
				m.On("VerifyPasswordToken", token).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/verify/" + token,
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.AuthRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/verify/:token", nil, func(g *gin.Context) {
				getAuthMock(mock).VerifyPasswordToken(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestAuth_SendResetPassword - Test endResetPassword route
func TestAuth_SendResetPassword(t *testing.T) {

	srp := domain.SendResetPassword{Email: "info@verbiscms.com"}
	srpBadvalidation := domain.SendResetPassword{}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.AuthRepository)
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "A fresh verification link has been sent to your email",
			input:   srp,
			mock: func(m *mocks.AuthRepository) {
				m.On("SendResetPassword", srp.Email).Return(nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"email","message":"Email is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   srpBadvalidation,
			mock: func(m *mocks.AuthRepository) {
				m.On("SendResetPassword", srpBadvalidation.Email).Return(nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   srp,
			mock: func(m *mocks.AuthRepository) {
				m.On("SendResetPassword", srp.Email).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   srp,
			mock: func(m *mocks.AuthRepository) {
				m.On("SendResetPassword", srp.Email).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.AuthRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/sendreset", "/sendreset", bytes.NewBuffer(body), func(g *gin.Context) {
				getAuthMock(mock).SendResetPassword(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/user.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"strconv"
)

// UserHandler defines methods for Users to interact with the server
type UserHandler interface {
	Get(g *gin.Context)
	GetById(g *gin.Context)
	GetRoles(g *gin.Context)
	Create(g *gin.Context)
	Update(g *gin.Context)
	Delete(g *gin.Context)
	ResetPassword(g *gin.Context)
}

// User defines the handler for Users
type User struct {
	*deps.Deps
}

// newUser - Construct
func NewUser(d *deps.Deps) *User {
	return &User{d}
}

// Get all users
//
// Returns 200 if the users were obtained successfully.
// Returns 500 if there was an error getting the users.
// Returns 400 if there was conflict or the request was invalid.
func (c *User) Get(g *gin.Context) {
	const op = "UserHandler.Get"

	params := params.ApiParams(g, DefaultParams).Get()

	users, total, err := c.Store.User.Get(params)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	pagination := http.NewPagination().Get(params, total)

	Respond(g, 200, "Successfully obtained users", users.HideCredentials(), pagination)
}

// Get By ID
//
// Returns 200 if the user was obtained.
// Returns 500 if there as an error obtaining the user.
// Returns 400 if the ID wasn't passed or failed to convert.
func (c *User) GetById(g *gin.Context) {
	const op = "UserHandler.GetById"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "Pass a valid number to obtain the user by ID", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	user, err := c.Store.User.GetById(id)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained user with ID: "+strconv.Itoa(id), user.HideCredentials())
}

// Get Roles
//
// Returns 200 if the user roles were obtained.
// Returns 500 if there as an error obtaining the user roles.
func (c *User) GetRoles(g *gin.Context) {
	const op = "UserHandler.GetRoles"

	roles, err := c.Store.User.GetRoles()
	if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained user roles", roles)
}

// Create
//
// Returns 200 if the user was created.
// Returns 500 if there was an error creating the user.
// Returns 400 if the the validation failed or a user already exists.
func (c *User) Create(g *gin.Context) {
	const op = "UserHandler.Create"

	var u domain.UserCreate
	if err := g.ShouldBindJSON(&u); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	user, err := c.Store.User.Create(&u)
	if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully created user with ID: "+strconv.Itoa(user.Id), user)
}

// Update
//
// Returns 200 if the user was updated.
// Returns 500 if there was an error updating the user.
// Returns 400 if the the validation failed or the user wasn't found.
func (c *User) Update(g *gin.Context) {
	const op = "UserHandler.Update"

	var u domain.User
	if err := g.ShouldBindJSON(&u); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update the user", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	u.Id = id

	updatedUser, err := c.Store.User.Update(&u)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	defer c.clearCache(updatedUser.Id)

	Respond(g, 200, "Successfully updated user with ID: "+strconv.Itoa(u.Id), updatedUser)
}

// Delete
//
// Returns 200 if the user was deleted.
// Returns 500 if there was an error deleting the user.
// Returns 400 if the the user wasn't found or no ID was passed.
func (c *User) Delete(g *gin.Context) {
	const op = "UserHandler.Delete"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to delete a user", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.User.Delete(id)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully deleted user with ID: "+strconv.Itoa(id), nil)
}

// ResetPassword
//
// Returns 200 if the reset password was successful.
// Returns 500 if there was an error resetting the user failed.
// Returns 400 if the the user wasn't found, no ID was passed or validation failed.
func (c *User) ResetPassword(g *gin.Context) {
	const op = "UserHandler.ResetPassword"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update a user's password", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	user, err := c.Store.User.GetById(id)
	if err != nil {
		Respond(g, 400, "No user has been found with the ID: "+strconv.Itoa(id), err)
		return
	}

	var reset domain.UserPasswordReset
	reset.DBPassword = user.Password
	if err := g.ShouldBindJSON(&reset); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.User.ResetPassword(id, reset)
	if errors.Code(err) == errors.INVALID {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully updated password for the user with ID: "+strconv.Itoa(id), nil)
}

// clearCache
// Clear the post cache that have the given user ID
// attached to it.
func (c *User) clearCache(id int) {
	go func() {
		posts, _, err := c.Store.Posts.Get(params.Params{LimitAll: true}, false, "", "")
		if err != nil {
			log.WithFields(log.Fields{"error": err}).Error()
		}
		cache.ClearUserCache(id, posts)
	}()
}"
}
{
file:./api/http/handler/api/user_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	pkgValidate "github.com/go-playground/validator/v10"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getUserMock is a helper to obtain a mock user controller
// for testing.
func getUserMock(m models.UserRepository) *User {
	return &User{
		store: &models.Store{
			User: m,
		},
	}
}

// mockComparePassword for the password field on the domain.UserPasswordReset
// (custom validation)
func mockComparePassword(fl pkgValidate.FieldLevel) bool {
	return true
}

// Test_NewUser - Test construct
func Test_NewUser(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &User{
		store:  &store,
		config: config,
	}
	got := NewUser(&store, config)
	assert.Equal(t, got, want)
}

// TestUser_Get - Test Get route
func TestUser_Get(t *testing.T) {

	users := domain.Users{
		{
			UserPart: domain.UserPart{
				Id: 123, FirstName: "Verbis", LastName: "CMS",
			},
		},
		{
			UserPart: domain.UserPart{
				Id: 123, FirstName: "Verbis", LastName: "CMS",
			},
		},
	}

	pagination := params.Params{Page: 1, Limit: 15, OrderBy: "id", OrderDirection: "ASC", Filters: nil}

	tt := map[string]struct {
		name    string
		want    string
		status  int
		message string
		mock    func(u *mocks.UserRepository)
	}{
		"Success": {
			want:    `[{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"Verbis","id":123,"instagram":null,"last_name":"CMS","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"Verbis","id":123,"instagram":null,"last_name":"CMS","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}]`,
			status:  200,
			message: "Successfully obtained users",
			mock: func(u *mocks.UserRepository) {
				u.On("Get", pagination).Return(users, 1, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no users found",
			mock: func(u *mocks.UserRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no users found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(u *mocks.UserRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(u *mocks.UserRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(u *mocks.UserRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/users", "/users", nil, func(g *gin.Context) {
				getUserMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestUser_GetById - Test GetByID route
func TestUser_GetById(t *testing.T) {

	user := domain.User{
		UserPart: domain.UserPart{
			Id: 123, FirstName: "Verbis", LastName: "CMS",
		},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.UserRepository)
		url     string
	}{
		"Success": {
			want:    `{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"Verbis","id":123,"instagram":null,"last_name":"CMS","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully obtained user with ID: 123",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(user, nil)
			},
			url: "/users/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "Pass a valid number to obtain the user by ID",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, fmt.Errorf("error"))
			},
			url: "/users/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no users found",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "no users found"})
			},
			url: "/users/123",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/users/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/users/:id", nil, func(g *gin.Context) {
				getUserMock(mock).GetById(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestUser_GetRoles - Test GetRoles route
func TestUser_GetRoles(t *testing.T) {

	roles := []domain.UserRole{
		{Id: 1, Name: "Banned", Description: "Banned Role"},
		{Id: 2, Name: "Administrator", Description: "Administrator Role"},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.UserRepository)
	}{
		"Success": {
			want:    `[{"description":"Banned Role","id":1,"name":"Banned"},{"description":"Administrator Role","id":2,"name":"Administrator"}]`,
			status:  200,
			message: "Successfully obtained user roles",
			mock: func(u *mocks.UserRepository) {
				u.On("GetRoles").Return(roles, nil)
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(u *mocks.UserRepository) {
				u.On("GetRoles").Return(nil, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/roles", "/roles", nil, func(g *gin.Context) {
				getUserMock(mock).GetRoles(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestUser_Create - Test Create route
func TestUser_Create(t *testing.T) {

	userCreate := &domain.UserCreate{
		User: domain.User{
			UserPart: domain.UserPart{
				FirstName: "Verbis",
				LastName:  "CMS",
				Email:     "verbis@verbiscms.com",
				Role: domain.UserRole{
					Id: 123,
				},
			},
		},
		Password:        "password",
		ConfirmPassword: "password",
	}

	user := domain.User{
		UserPart: domain.UserPart{
			Id:        123,
			FirstName: "Verbis",
			LastName:  "CMS",
			Email:     "verbis@verbiscms.com",
		},
	}

	userBadValidation := &domain.UserCreate{
		User: domain.User{
			UserPart: domain.UserPart{
				FirstName: "Verbis",
				LastName:  "CMS",
				Email:     "verbis@verbiscms.com",
			},
		},
		Password:        "password",
		ConfirmPassword: "password",
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(u *mocks.UserRepository)
	}{
		"Success": {
			want:    `{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"verbis@verbiscms.com","email_verified_at":null,"facebook":null,"first_name":"Verbis","id":123,"instagram":null,"last_name":"CMS","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully created user with ID: 123",
			input:   userCreate,
			mock: func(u *mocks.UserRepository) {
				u.On("Create", userCreate).Return(user, nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"role_id","message":"Role Id is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   userBadValidation,
			mock: func(u *mocks.UserRepository) {
				u.On("Create", userBadValidation).Return(domain.User{}, fmt.Errorf("error"))
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			input:   userCreate,
			mock: func(u *mocks.UserRepository) {
				u.On("Create", userCreate).Return(domain.User{}, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			input:   userCreate,
			mock: func(u *mocks.UserRepository) {
				u.On("Create", userCreate).Return(domain.User{}, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   userCreate,
			mock: func(u *mocks.UserRepository) {
				u.On("Create", userCreate).Return(domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/users", "/users", bytes.NewBuffer(body), func(g *gin.Context) {
				getUserMock(mock).Create(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

//TestUser_Update - Test Update route
func TestUser_Update(t *testing.T) {

	cache.Init()

	user := domain.User{
		UserPart: domain.UserPart{
			Id:        123,
			FirstName: "Verbis",
			LastName:  "CMS",
			Email:     "verbis@verbiscms.com",
			Role: domain.UserRole{
				Id: 1,
			},
		},
	}

	userBadValidation := &domain.User{
		UserPart: domain.UserPart{
			FirstName: "Verbis",
			LastName:  "CMS",
			Email:     "verbis@verbiscms.com",
		},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(u *mocks.UserRepository)
		url     string
	}{
		"Success": {
			want:    `{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"verbis@verbiscms.com","email_verified_at":null,"facebook":null,"first_name":"Verbis","id":123,"instagram":null,"last_name":"CMS","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":1,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully updated user with ID: 123",
			input:   user,
			mock: func(u *mocks.UserRepository) {
				u.On("Update", &user).Return(user, nil)
			},
			url: "/users/123",
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"role_id","message":"Role Id is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   userBadValidation,
			mock: func(u *mocks.UserRepository) {
				u.On("Update", userBadValidation).Return(domain.User{}, fmt.Errorf("error"))
			},
			url: "/users/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update the user",
			input:   user,
			mock: func(u *mocks.UserRepository) {
				u.On("Update", userBadValidation).Return(domain.User{}, fmt.Errorf("error"))
			},
			url: "/users/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   user,
			mock: func(u *mocks.UserRepository) {
				u.On("Update", &user).Return(domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/users/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   user,
			mock: func(u *mocks.UserRepository) {
				u.On("Update", &user).Return(domain.User{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/users/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			postsMock := &mocks.PostsRepository{}
			postsMock.On("Get", params.Params{LimitAll: true}, false, "", "").Return([]domain.PostData{}, 2, nil)

			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("PUT", test.url, "/users/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				t := getUserMock(mock)
				t.store.Posts = postsMock
				t.Update(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestUser_Delete - Test Delete route
func TestUser_Delete(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.UserRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully deleted user with ID: 123",
			mock: func(u *mocks.UserRepository) {
				u.On("Delete", 123).Return(nil)
			},
			url: "/users/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to delete a user",
			mock: func(u *mocks.UserRepository) {
				u.On("Delete", 123).Return(nil)
			},
			url: "/users/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			mock: func(u *mocks.UserRepository) {
				u.On("Delete", 123).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/users/123",
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(u *mocks.UserRepository) {
				u.On("Delete", 123).Return(&errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
			url: "/users/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(u *mocks.UserRepository) {
				u.On("Delete", 123).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/users/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/users/:id", nil, func(g *gin.Context) {
				getUserMock(mock).Delete(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestUser_ResetPassword - Test Reset Password route
func TestUser_ResetPassword(t *testing.T) {

	reset := domain.UserPasswordReset{
		DBPassword:      "",
		CurrentPassword: "password",
		NewPassword:     "verbiscms",
		ConfirmPassword: "verbiscms",
	}

	resetBadValidation := &domain.UserPasswordReset{
		CurrentPassword: "password",
		NewPassword:     "verbiscms",
		ConfirmPassword: "verbiscmss",
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(u *mocks.UserRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully updated password for the user with ID: 123",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, nil)
				u.On("ResetPassword", 123, reset).Return(nil)
			},
			input: reset,
			url:   "/users/reset/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update a user's password",
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, nil)
				u.On("ResetPassword", 123, reset).Return(nil)
			},
			input: reset,
			url:   "/users/reset/wrongid",
		},
		"Not found": {
			want:    `{}`,
			status:  400,
			message: "No user has been found with the ID: 123",
			input:   reset,
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
				u.On("ResetPassword", 123, reset).Return(nil)
			},
			url: "/users/reset/123",
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"confirm_password", "message":"Confirm Password must equal the New Password.", "type":"eqfield"}]}`,
			status:  400,
			message: "Validation failed",
			input:   resetBadValidation,
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, nil)
				u.On("ResetPassword", 123, reset).Return(nil)
			},
			url: "/users/reset/123",
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			input:   reset,
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, nil)
				u.On("ResetPassword", 123, reset).Return(&errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
			url: "/users/reset/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   reset,
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 123).Return(domain.User{}, nil)
				u.On("ResetPassword", 123, reset).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/users/reset/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.UserRepository{}
			test.mock(mock)

			if v, ok := binding.Validator.Engine().(*pkgValidate.Validate); ok {
				v.RegisterValidation("password", mockComparePassword)
			}

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("DELETE", test.url, "/users/reset/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				getUserMock(mock).ResetPassword(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/auth.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
)

// AuthHandler defines methods for auth methods to interact with the server
type AuthHandler interface {
	Login(g *gin.Context)
	Logout(g *gin.Context)
	ResetPassword(g *gin.Context)
	VerifyEmail(g *gin.Context)
	VerifyPasswordToken(g *gin.Context)
	SendResetPassword(g *gin.Context)
}

// Auth defines the handler for Authentication methods
type Auth struct {
	*deps.Deps
}

// newAuth - Construct
func NewAuth(d *deps.Deps) *Auth {
	return &Auth{d}
}

// Login the user
//
// Returns 200 if login was successful.
// Returns 400 if the validation failed.
// Returns 401 if the credentials didn't match.
func (c *Auth) Login(g *gin.Context) {
	const op = "AuthHandler.Login"

	var l domain.Login
	if err := g.ShouldBindJSON(&l); err != nil {
		fmt.Print(err)
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	user, err := c.Store.Auth.Authenticate(l.Email, l.Password)
	if err != nil {
		fmt.Print(err)
		Respond(g, 401, errors.Message(err), err)
		return
	}
	user.HidePassword()

	g.SetCookie("verbis-session", user.Token, 172800, "/", "", false, true)

	Respond(g, 200, "Successfully logged in & session started", user)
}

// Logout the user
//
// Returns 200 if logout was successful.
// Returns 400 if the user wasn't found.
// Returns 500 if there was an error logging out.
func (c *Auth) Logout(g *gin.Context) {
	const op = "AuthHandler.Logout"

	token := g.Request.Header.Get("token")
	_, err := c.Store.Auth.Logout(token)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	g.SetCookie("verbis-session", "", -1, "/", "", false, true)

	Respond(g, 200, "Successfully logged out", nil)
}

// Verify email
//
// TODO
func (c *Auth) VerifyEmail(g *gin.Context) {
	const op = "AuthHandler.VerifyEmail"

	token := g.Param("token")
	err := c.Store.Auth.VerifyEmail(token)
	if err != nil {
		notFound(g)
		return
	}

	g.Redirect(301, c.Store.Config.Admin.Path)
}

// Reset password
//
// Returns 200 if successful.
// Returns 400 if the ID wasn't passed or failed to convert.
func (c *Auth) ResetPassword(g *gin.Context) {
	const op = "AuthHandler.ResetPassword"

	var rp domain.ResetPassword
	if err := g.ShouldBindJSON(&rp); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err := c.Store.Auth.ResetPassword(rp.Token, rp.NewPassword)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully reset password", nil)
}

// VerifyPasswordToken
//
// Returns 200 if successful.
// Returns 404 if the token does not exist.
func (c *Auth) VerifyPasswordToken(g *gin.Context) {
	const op = "AuthHandler.VerifyPasswordToken"

	err := c.Store.Auth.VerifyPasswordToken(g.Param("token"))
	if err != nil {
		Respond(g, 404, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully verified token", nil)
}

// SendResetPassword reset password email & generate token
//
// Returns 200 if successful.
// Returns 400 if validation failed the user wasn't found.
func (c *Auth) SendResetPassword(g *gin.Context) {
	const op = "AuthHandler.SendResetPassword"

	var srp domain.SendResetPassword
	if err := g.ShouldBindJSON(&srp); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err := c.Store.Auth.SendResetPassword(srp.Email)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	}
	if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "A fresh verification link has been sent to your email", nil)
}"
}
{
file:./api/http/handler/api/cache_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// Test_NewCache - Test construct
func Test_NewCache(t *testing.T) {
	cache.Init()
	want := &Cache{}
	got := NewCache()
	assert.Equal(t, got, want)
}

// TestCache_Clear - Test Clear route
func TestCache_Clear(t *testing.T) {

	cache.Init()

	tt := map[string]struct {
		name    string
		want    string
		status  int
		message string
		input   string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully cleared server cache",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &Cache{}

			rr.RequestAndServe("POST", "/reset", "/reset", nil, func(g *gin.Context) {
				mock.Clear(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/options.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/teamwork/reload"
	"time"
)

// OptionsHandler defines methods for Options to interact with the server
type OptionsHandler interface {
	Get(g *gin.Context)
	GetByName(g *gin.Context)
	UpdateCreate(g *gin.Context)
}

// Options defines the handler for Options
type Options struct {
	*deps.Deps
}

// newOptions - Construct
func NewOptions(d *deps.Deps) *Options {
	return &Options{d}
}

// Get All
//
// Returns 200 if there are no options or success.
// Returns 500 if there was an error getting the options.
func (c *Options) Get(g *gin.Context) {
	const op = "OptionsHandler.Delete"

	options, err := c.Store.Options.Get()
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained options", options)
}

// Get By name
//
// Returns 200 if there are no options or success.
// Returns 400 if there was name param was missing.
// Returns 500 if there was an error getting the options.
func (c *Options) GetByName(g *gin.Context) {
	const op = "OptionsHandler.GetByName"

	name := g.Param("name")
	option, err := c.Store.Options.GetByName(name)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained option with name: "+name, option)
}

// UpdateCreate - Restarts the server at the end of the
// request to flush options.
//
// Returns 200 if the options was created/updated.
// Returns 400 if the validation failed on both structs.
// Returns 500 if there was an error updating/creating the options.
func (c *Options) UpdateCreate(g *gin.Context) {
	const op = "OptionsHandler.UpdateCreate"

	var options domain.OptionsDB
	if err := g.ShouldBindBodyWith(&options, binding.JSON); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	var vOptions domain.Options
	if err := g.ShouldBindBodyWith(&vOptions, binding.JSON); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	if err := c.Store.Options.UpdateCreate(&options); err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully created/updated options", nil)

	go func() {
		// Set the deps options
		c.SetOptions(&vOptions)
		time.Sleep(time.Second * 2)
		reload.Exec()
	}()
}"
}
{
file:./api/http/handler/api/cache.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/gin-gonic/gin"
)

// CacheHandler defines methods for fields to interact with the server
type CacheHandler interface {
	Clear(g *gin.Context)
}

// CacheController defines the handler for Cache
type Cache struct {
	*deps.Deps
}

// newCache - Construct
func NewCache(d *deps.Deps) *Cache {
	return &Cache{d}
}

// Clear server cache
func (c *Cache) Clear(g *gin.Context) {
	const op = "CacheHandler.Clear"
	cache.Store.Flush()
	Respond(g, 200, "Successfully cleared server cache", nil)
}"
}
{
file:./api/http/handler/api/posts.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	"strconv"
)

// PostHandler defines methods for Posts to interact with the server
type PostHandler interface {
	Get(g *gin.Context)
	GetById(g *gin.Context)
	Create(g *gin.Context)
	Update(g *gin.Context)
	Delete(g *gin.Context)
}

// Posts defines the handler for Posts
type Posts struct {
	*deps.Deps
}

// newPosts - Construct
func NewPosts(d *deps.Deps) *Posts {
	return &Posts{d}
}

// Get all posts, obtain resource param to pass to the get
// function.
//
// Returns 200 if there are no posts or success.
// Returns 400 if there was conflict or the request was invalid.
// Returns 500 if there was an error getting or formatting the posts.
func (c *Posts) Get(g *gin.Context) {
	const op = "PostHandler.Get"

	p := params.ApiParams(g, DefaultParams).Get()

	posts, total, err := c.Store.Posts.Get(p, true, g.Query("resource"), g.Query("status"))
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	pagination := http.NewPagination().Get(p, total)

	Respond(g, 200, "Successfully obtained posts", posts, pagination)
}

// Get By ID
//
// Returns 200 if the posts were obtained.
// Returns 400 if the ID wasn't passed or failed to convert.
// Returns 500 if there as an error obtaining or formatting the post.
func (c *Posts) GetById(g *gin.Context) {
	const op = "PostHandler.GetById"

	paramId := g.Param("id")
	id, err := strconv.Atoi(paramId)
	if err != nil {
		Respond(g, 400, "Pass a valid number to obtain the post by ID", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	post, err := c.Store.Posts.GetById(id, true)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained post with ID: "+paramId, post)
}

// Create
//
// Returns 200 if the post was created.
// Returns 500 if there was an error creating or formatting the post.
// Returns 400 if the the validation failed or there was a conflict with the post.
func (c *Posts) Create(g *gin.Context) {
	const op = "PostHandler.Create"

	var post domain.PostCreate
	if err := g.ShouldBindJSON(&post); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	newPost, err := c.Store.Posts.Create(&post)
	if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully created post with ID: "+strconv.Itoa(newPost.Id), newPost)
}

// Update
//
// Returns 200 if the post was updated.
// Returns 500 if there was an error updating or formatting the post.
// Returns 400 if the the validation failed, there was a conflict, or the post wasn't found.
func (c *Posts) Update(g *gin.Context) {
	const op = "PostHandler.Update"

	var post domain.PostCreate
	if err := g.ShouldBindJSON(&post); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	cache.ClearPostCache(post.Id)

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update the post", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	post.Id = id

	updatedPost, err := c.Store.Posts.Update(&post)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully updated post with ID: "+strconv.Itoa(updatedPost.Id), updatedPost)
}

// Delete
//
// Returns 200 if the post was deleted.
// Returns 500 if there was an error deleting the post.
// Returns 400 if the the post wasn't found or no ID was passed.
func (c *Posts) Delete(g *gin.Context) {
	const op = "PostHandler.Delete"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to delete a post", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.Posts.Delete(id)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully deleted post with ID: "+strconv.Itoa(id), nil)
}"
}
{
file:./api/http/handler/api/categories.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"strconv"
)

// CategoryHandler defines methods for categories to interact with the server
type CategoryHandler interface {
	Get(g *gin.Context)
	GetById(g *gin.Context)
	Create(g *gin.Context)
	Update(g *gin.Context)
	Delete(g *gin.Context)
}

// Categories defines the handler for Categories
type Categories struct {
	*deps.Deps
}

// newCategories - Construct
func NewCategories(d *deps.Deps) *Categories {
	return &Categories{d}
}

// Get all categories
//
// Returns 200 if there are no categories or success.
// Returns 500 if there was an error getting the categories.
// Returns 400 if there was conflict or the request was invalid.
func (c *Categories) Get(g *gin.Context) {
	const op = "CategoryHandler.Get"

	p := params.ApiParams(g, DefaultParams).Get()

	categories, total, err := c.Store.Categories.Get(p)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	pagination := http.NewPagination().Get(p, total)

	Respond(g, 200, "Successfully obtained categories", categories, pagination)
}

// Get By ID
//
// Returns 200 if the category was obtained.
// Returns 500 if there as an error obtaining the category.
// Returns 400 if the ID wasn't passed or failed to convert.
func (c *Categories) GetById(g *gin.Context) {
	const op = "CategoryHandler.GetById"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "Pass a valid number to obtain the category by ID", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	category, err := c.Store.Categories.GetById(id)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained category with ID: "+strconv.Itoa(id), category)
}

// Create
//
// Returns 200 if the category was created.
// Returns 500 if there was an error creating the category.
// Returns 400 if the the validation failed or there was a conflict.
func (c *Categories) Create(g *gin.Context) {
	const op = "CategoryHandler.Create"

	var category domain.Category
	if err := g.ShouldBindJSON(&category); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	newCategory, err := c.Store.Categories.Create(&category)
	if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully created category with ID: "+strconv.Itoa(category.Id), newCategory)
}

// Update
//
// Returns 200 if the category was updated.
// Returns 500 if there was an error updating the category.
// Returns 400 if the the validation failed or the category wasn't found.
func (c *Categories) Update(g *gin.Context) {
	const op = "CategoryHandler.Update"

	var category domain.Category
	if err := g.ShouldBindJSON(&category); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update the category", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	category.Id = id

	updatedCategory, err := c.Store.Categories.Update(&category)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	defer c.clearCache(updatedCategory.Id)

	Respond(g, 200, "Successfully updated category with ID: "+strconv.Itoa(category.Id), updatedCategory)
}

// Delete
//
// Returns 200 if the category was deleted.
// Returns 500 if there was an error deleting the category.
// Returns 400 if the the category wasn't found or no ID was passed.
func (c *Categories) Delete(g *gin.Context) {
	const op = "CategoryHandler.Delete"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to delete a category", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.Categories.Delete(id)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully deleted category with ID: "+strconv.Itoa(id), nil)
}

// clearCache
// Clear the post cache that have the given category ID
// attached to it.
func (c *Categories) clearCache(id int) {
	go func() {
		posts, _, err := c.Store.Posts.Get(params.Params{LimitAll: true}, false, "", "")
		if err != nil {
			log.WithFields(log.Fields{"error": err}).Error()
		}
		cache.ClearCategoryCache(id, posts)
	}()
}"
}
{
file:./api/http/handler/api/categories_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getCategoriesMock is a helper to obtain a mock categories controller
// for testing.
func getCategoriesMock(m models.CategoryRepository) *Categories {
	return &Categories{
		store: &models.Store{
			Categories: m,
		},
	}
}

// Test_NewCategories - Test construct
func Test_NewCategories(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Categories{
		store:  &store,
		config: config,
	}
	got := NewCategories(&store, config)
	assert.Equal(t, got, want)
}

// TestCategories_Get - Test Get route
func TestCategories_Get(t *testing.T) {

	categories := []domain.Category{
		{Id: 123, Slug: "/cat", Name: "Category"},
		{Id: 124, Slug: "/cat1", Name: "Category1"},
	}
	pagination := params.Params{Page: 1, Limit: 15, OrderBy: "id", OrderDirection: "ASC", Filters: nil}

	tt := map[string]struct {
		name    string
		want    string
		status  int
		message string
		mock    func(m *mocks.CategoryRepository)
	}{
		"Success": {
			want:    `[{"archive_id":null,"created_at":"0001-01-01T00:00:00Z","description":null,"id":123,"name":"Category","parent_id":null,"resource":"","slug":"/cat","updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},{"archive_id":null,"created_at":"0001-01-01T00:00:00Z","description":null,"id":124,"name":"Category1","parent_id":null,"resource":"","slug":"/cat1","updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}]`,
			status:  200,
			message: "Successfully obtained categories",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Get", pagination).Return(categories, 1, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no categories found",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no categories found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.CategoryRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/categories", "/categories", nil, func(g *gin.Context) {
				getCategoriesMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestCategories_GetById - Test GetByID route
func TestCategories_GetById(t *testing.T) {

	category := domain.Category{Id: 123, Slug: "/cat", Name: "Category"}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.CategoryRepository)
		url     string
	}{
		"Success": {
			want:    `{"archive_id":null,"created_at":"0001-01-01T00:00:00Z","description":null,"id":123,"name":"Category","parent_id":null,"resource":"","slug":"/cat","updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully obtained category with ID: 123",
			mock: func(m *mocks.CategoryRepository) {
				m.On("GetById", 123).Return(category, nil)
			},
			url: "/categories/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "Pass a valid number to obtain the category by ID",
			mock: func(m *mocks.CategoryRepository) {
				m.On("GetById", 123).Return(domain.Category{}, fmt.Errorf("error"))
			},
			url: "/categories/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no categories found",
			mock: func(m *mocks.CategoryRepository) {
				m.On("GetById", 123).Return(domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: "no categories found"})
			},
			url: "/categories/123",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.CategoryRepository) {
				m.On("GetById", 123).Return(domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/categories/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.CategoryRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/categories/:id", nil, func(g *gin.Context) {
				getCategoriesMock(mock).GetById(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestCategories_Create - Test Create route
func TestCategories_Create(t *testing.T) {

	category := domain.Category{Id: 123, Slug: "/cat", Name: "Category", Resource: "test"}
	categoryBadValidation := domain.Category{Id: 123, Name: "Category", Resource: "test"}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.CategoryRepository)
	}{
		"Success": {
			want:    `{"archive_id":null,"created_at":"0001-01-01T00:00:00Z","description":null,"id":123,"name":"Category","parent_id":null,"resource":"test","slug":"/cat","updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully created category with ID: 123",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Create", &category).Return(category, nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"slug","message":"Slug is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   categoryBadValidation,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Create", &categoryBadValidation).Return(domain.Category{}, fmt.Errorf("error"))
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Create", &category).Return(domain.Category{}, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Create", &category).Return(domain.Category{}, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Create", &category).Return(domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.CategoryRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/categories", "/categories", bytes.NewBuffer(body), func(g *gin.Context) {
				getCategoriesMock(mock).Create(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestCategories_Update - Test Update route
func TestCategories_Update(t *testing.T) {

	category := domain.Category{Id: 123, Slug: "/cat", Name: "Category", Resource: "test"}
	categoryBadValidation := domain.Category{Id: 123, Name: "Category", Resource: "test"}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.CategoryRepository)
		url     string
	}{
		"Success": {
			want:    `{"archive_id":null,"created_at":"0001-01-01T00:00:00Z","description":null,"id":123,"name":"Category","parent_id":null,"resource":"test","slug":"/cat","updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully updated category with ID: 123",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Update", &category).Return(category, nil)
			},
			url: "/categories/123",
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"slug","message":"Slug is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   categoryBadValidation,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Update", categoryBadValidation).Return(domain.Category{}, fmt.Errorf("error"))
			},
			url: "/categories/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update the category",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Update", categoryBadValidation).Return(domain.Category{}, fmt.Errorf("error"))
			},
			url: "/categories/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Update", &category).Return(domain.Category{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/categories/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   category,
			mock: func(m *mocks.CategoryRepository) {
				m.On("Update", &category).Return(domain.Category{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/categories/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.CategoryRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("PUT", test.url, "/categories/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				getCategoriesMock(mock).Update(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestCategories_Delete - Test Delete route
func TestCategories_Delete(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.CategoryRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully deleted category with ID: 123",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/categories/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to delete a category",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/categories/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/categories/123",
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
			url: "/categories/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.CategoryRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/categories/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.CategoryRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/categories/:id", nil, func(g *gin.Context) {
				getCategoriesMock(mock).Delete(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/fields_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getFieldsMock is a helper to obtain a mock fields controller
// for testing.
func getFieldsMock(m models.FieldsRepository) *Fields {
	return &Fields{
		store: &models.Store{
			Fields: m,
		},
	}
}

// Test_NewAuth - Test construct
func Test_NewFields(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Fields{
		store:  &store,
		config: config,
	}
	got := NewFields(&store, config)
	assert.Equal(t, got, want)
}

// TestAuthController_Get - Test Get route
func TestFieldController_Get(t *testing.T) {

}"
}
{
file:./api/http/handler/api/options_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getPostsMock is a helper to obtain a mock options controller
// for testing.
func getOptionsMock(m models.OptionsRepository) *Options {
	return &Options{
		store: &models.Store{
			Options: m,
		},
	}
}

// Test_NewOptions - Test construct
func Test_NewOptions(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Options{
		store:  &store,
		config: config,
	}
	got := NewwOptions(&store, config)
	assert.Equal(t, got, want)
}

// TestOptions_Get - Test Get route
func TestOptions_Get(t *testing.T) {

	options := domain.OptionsDB{
		"test1": domain.OptionDB{ID: 123, Name: "test"},
		"test2": domain.OptionDB{ID: 124, Name: "test1"},
	}

	tt := map[string]struct {
		name    string
		want    string
		status  int
		message string
		mock    func(m *mocks.OptionsRepository)
	}{
		"Success": {
			want:    `{"test1":{"id":123,"option_name":"test","option_value":null},"test2":{"id":124,"option_name":"test1","option_value":null}}`,
			status:  200,
			message: "Successfully obtained options",
			mock: func(m *mocks.OptionsRepository) {
				m.On("Get").Return(options, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no options found",
			mock: func(m *mocks.OptionsRepository) {
				m.On("Get").Return(nil, &errors.Error{Code: errors.NOTFOUND, Message: "no options found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.OptionsRepository) {
				m.On("Get").Return(nil, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(m *mocks.OptionsRepository) {
				m.On("Get").Return(nil, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.OptionsRepository) {
				m.On("Get").Return(nil, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.OptionsRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/options", "/options", nil, func(g *gin.Context) {
				getOptionsMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestOptions_GetByName - Test GetByName route
func TestOptions_GetByName(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.OptionsRepository)
		url     string
	}{
		"Success": {
			want:    `"testing"`,
			status:  200,
			message: "Successfully obtained option with name: test",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetByName", "test").Return("testing", nil)
			},
			url: "/options/test",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no option found",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetByName", "test").Return(nil, &errors.Error{Code: errors.NOTFOUND, Message: "no option found"})
			},
			url: "/options/test",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetByName", "test").Return(nil, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/options/test",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.OptionsRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/options/:name", nil, func(g *gin.Context) {
				getOptionsMock(mock).GetByName(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestOptions_UpdateCreate - Test UpdateCreate route
func TestOptions_UpdateCreate(t *testing.T) {

	vOptions := domain.Options{
		SiteTitle:        "test",
		SiteDescription:  "test",
		SiteLogo:         "test",
		SiteUrl:          "http://verbiscms.com",
		GeneralLocale:    "test",
		MediaCompression: 10,
	}

	vOptionsBadValidation := domain.Options{
		SiteTitle:        "test",
		SiteDescription:  "test",
		SiteLogo:         "test",
		GeneralLocale:    "test",
		MediaCompression: 10,
	}
	jsonVOptions, err := json.Marshal(vOptions)
	if err != nil {
		t.Fatal(err)
	}

	dbOptions := domain.OptionsDB{}
	err = json.Unmarshal(jsonVOptions, &dbOptions)
	assert.NoError(t, err)

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.OptionsRepository)
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully created/updated options",
			input:   vOptions,
			mock: func(m *mocks.OptionsRepository) {
				m.On("UpdateCreate", &dbOptions).Return(nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"site_url","message":"Site Url is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   vOptionsBadValidation,
			mock: func(m *mocks.OptionsRepository) {
				m.On("UpdateCreate", &dbOptions).Return(nil)
			},
		},
		"Validation Failed DB": {
			want:    `{}`,
			status:  400,
			message: "Validation failed",
			input:   "test",
			mock: func(m *mocks.OptionsRepository) {
				m.On("UpdateCreate", &dbOptions).Return(nil)
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   vOptions,
			mock: func(m *mocks.OptionsRepository) {
				m.On("UpdateCreate", &dbOptions).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.OptionsRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/posts", "/posts", bytes.NewBuffer(body), func(g *gin.Context) {
				getOptionsMock(mock).UpdateCreate(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/site.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
)

// SiteHandler defines methods for the Site to interact with the server
type SiteHandler interface {
	GetSite(g *gin.Context)
	GetTheme(g *gin.Context)
	GetTemplates(g *gin.Context)
	GetLayouts(g *gin.Context)
}

// Site defines the handler for Posts
type Site struct {
	*deps.Deps
}

// newSite - Construct
func NewSite(d *deps.Deps) *Site {
	return &Site{d}
}

// GetSite gets site's general config
//
// Returns 200 if site config was obtained successfully.
func (c *Site) GetSite(g *gin.Context) {
	Respond(g, 200, "Successfully obtained site config", c.Store.Site.GetGlobalConfig())
}

// GetTheme gets the theme's config from the theme path
//
// Returns 200 if theme config was obtained successfully.
// Returns 500 if there was an error getting the theme config.
func (c *Site) GetTheme(g *gin.Context) {
	Respond(g, 200, "Successfully obtained theme config", c.Store.Site.GetThemeConfig())
}

// GetTemplates gets all page templates
//
// Returns 200 if the templates were obtained successfully.
// Returns 500 if there was an error getting the templates.
func (c *Site) GetTemplates(g *gin.Context) {
	const op = "SiteHandler.GetTemplates"

	templates, err := c.Store.Site.GetTemplates()
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained templates", templates)
}

// GetTemplates gets all layouts
//
// Returns 200 if the layouts were obtained successfully.
// Returns 500 if there was an error getting the layouts.
func (c *Site) GetLayouts(g *gin.Context) {
	const op = "SiteHandler.GetLayouts"

	templates, err := c.Store.Site.GetLayouts()
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained layouts", templates)
}"
}
{
file:./api/http/handler/api/respond_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/gin-gonic/gin"
	"testing"
)

func Test_calculateRequestTime(t *testing.T) {
	gin.SetMode(gin.TestMode)

	//tt := map[string]struct {
	//	requestTime time.Time
	//	want        Meta
	//}{
	//	"Success": {
	//		requestTime: time.Now().Add(-10 * time.Second),
	//		want: Meta{
	//			RequestTime:  time.Now().Add(-10 * time.Second).UTC().String(),
	//			ResponseTime: time.Now().UTC().String(),
	//			LatencyTime:  "10s",
	//			Pagination:   nil,
	//		},
	//	},
	//}

	//for name, test := range tt {
	//t.Run(name, func(t *testing.T) {
	//	rr := httptest.NewRecorder()
	//	g, engine := gin.CreateTestContext(rr)
	//
	//	req, err := http.NewRequest("GET", "/test", nil)
	//	assert.NoError(t, err)
	//
	//	g.Request = req
	//	g.Set("request_time", test.requestTime)
	//
	//	meta := Meta{}
	//	engine.GET("/test", func(gin *gin.Context) {
	//		m := calculateRequestTime(g)
	//		meta = m
	//	})
	//	engine.ServeHTTP(rr, req)
	//
	//	time1, err := time.Parse(time.RFC850, meta.RequestTime)
	//	assert.NoError(t, err)
	//
	//	assert.WithinDuration(t, time1, test.requestTime, time.Millisecond*3)
	//	//assert.Equal(t, test.want, meta)
	//})
	//}
}"
}
{
file:./api/http/handler/api/forms.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/http"
	"github.com/gin-gonic/gin"
	"strconv"
)

// FormHandler defines methods for Form routes to interact with the server
type FormHandler interface {
	Get(g *gin.Context)
	GetById(g *gin.Context)
	Create(g *gin.Context)
	Send(g *gin.Context)
}

// Forms defines the handler for all Form Routes
type Forms struct {
	*deps.Deps
}

// NewForms - Construct
func NewForms(d *deps.Deps) *Forms {
	return &Forms{d}
}

// Get all forms
//
// Returns 200 if there are no forms or success.
// Returns 500 if there was an error getting the forms.
// Returns 400 if there was conflict or the request was invalid.
func (c *Forms) Get(g *gin.Context) {
	const op = "FormHandler.Get"

	p := params.ApiParams(g, DefaultParams).Get()

	forms, total, err := c.Store.Forms.Get(p)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	pagination := http.NewPagination().Get(p, total)

	Respond(g, 200, "Successfully obtained forms", forms, pagination)
}

// GetById
//
// Returns 200 if the form was obtained.
// Returns 500 if there as an error obtaining the form.
// Returns 400 if the ID wasn't passed or failed to convert.
func (c *Forms) GetById(g *gin.Context) {
	const op = "FormHandler.GetById"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "Pass a valid number to obtain the form by ID", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	form, err := c.Store.Forms.GetById(id)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully obtained form with ID: "+strconv.Itoa(id), form)
}

// Create
//
// Returns 200 if the form was created.
// Returns 500 if there was an error creating the form.
// Returns 400 if the the validation failed or there was a conflict.
func (c *Forms) Create(g *gin.Context) {
	const op = "FormHandler.Create"

	var form domain.Form
	if err := g.ShouldBindJSON(&form); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	newForm, err := c.Store.Forms.Create(&form)
	if errors.Code(err) == errors.INVALID || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully created form with ID: "+strconv.Itoa(form.Id), newForm)
}

// Update
//
// Returns 200 if the form was updated.
// Returns 500 if there was an error updating the form.
// Returns 400 if the the validation failed or the form wasn't found.
func (c *Forms) Update(g *gin.Context) {
	const op = "FormHandler.Update"

	var form domain.Form
	if err := g.ShouldBindJSON(&form); err != nil {
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to update the form", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}
	form.Id = id

	updatedForm, err := c.Store.Forms.Update(&form)
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully updated form with ID: "+strconv.Itoa(form.Id), updatedForm)
}

// Delete
//
// Returns 200 if the form was deleted.
// Returns 500 if there was an error deleting the form.
// Returns 400 if the the form wasn't found or no ID was passed.
func (c *Forms) Delete(g *gin.Context) {
	const op = "FormHandler.Delete"

	id, err := strconv.Atoi(g.Param("id"))
	if err != nil {
		Respond(g, 400, "A valid ID is required to delete a form", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.Forms.Delete(id)
	if errors.Code(err) == errors.NOTFOUND || errors.Code(err) == errors.CONFLICT {
		Respond(g, 400, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Successfully deleted form with ID: "+strconv.Itoa(id), nil)
}

// Send
//
// Returns 200 if the form was deleted.
// Returns 500 if there was an error deleting the form.
// Returns 400 if the the form wasn't found or no ID was passed.
func (c *Forms) Send(g *gin.Context) {
	const op = "FormHandler.Send"

	form, err := c.Store.Forms.GetByUUID(g.Param("uuid"))
	if errors.Code(err) == errors.NOTFOUND {
		Respond(g, 200, errors.Message(err), err)
		return
	} else if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	err = g.ShouldBind(form.Body)
	if err != nil {
		// If file has an empty value, no validation data is returned
		Respond(g, 400, "Validation failed", &errors.Error{Code: errors.INVALID, Err: err, Operation: op})
		return
	}

	err = c.Store.Forms.Send(&form, g.ClientIP(), g.Request.UserAgent())
	if err != nil {
		Respond(g, 500, errors.Message(err), err)
		return
	}

	Respond(g, 200, "Form submitted & sent successfully", nil)
}"
}
{
file:./api/http/handler/api/api.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"github.com/ainsleyclark/verbis/api/helpers/params"
)

var (
	// DefaultParams represents the default params if
	// none were passed for the API.
	DefaultParams = params.Defaults{
		Page:           1,
		Limit:          15,
		OrderBy:        "created_at",
		OrderDirection: "desc",
	}
)"
}
{
file:./api/http/handler/api/posts_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getPostsMock is a helper to obtain a mock posts controller
// for testing.
func getPostsMock(m models.PostsRepository) *Posts {
	return &Posts{
		store: &models.Store{
			Posts: m,
		},
	}
}

// Test_NewPosts - Test construct
func Test_NewPosts(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Posts{
		store:  &store,
		config: config,
	}
	got := NewPosts(&store, config)
	assert.Equal(t, got, want)
}

// TestPosts_Get - Test Get route
func TestPosts_Get(t *testing.T) {

	posts := []domain.PostData{
		{Post: domain.Post{Id: 123, Slug: "/post", Title: "post"}},
		{Post: domain.Post{Id: 123, Slug: "/post", Title: "post"}},
	}
	pagination := params.Params{Page: 1, Limit: 15, OrderBy: "id", OrderDirection: "ASC", Filters: nil}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.PostsRepository)
	}{
		"Success": {
			want:    `[{"author":{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},"category":null,"post":{"created_at":null,"id":123,"options":{"edit_lock":"","meta":null,"seo":null},"published_at":null,"resource":null,"slug":"/post","title":"post","updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}},{"author":{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},"category":null,"post":{"created_at":null,"id":123,"options":{"edit_lock":"","meta":null,"seo":null},"published_at":null,"resource":null,"slug":"/post","title":"post","updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}}]`,
			status:  200,
			message: "Successfully obtained posts",
			mock: func(m *mocks.PostsRepository) {
				m.On("Get", pagination, true, "", "").Return(posts, 2, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no posts found",
			mock: func(m *mocks.PostsRepository) {
				m.On("Get", pagination, true, "", "").Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no posts found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.PostsRepository) {
				m.On("Get", pagination, true, "", "").Return(nil, 0, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(m *mocks.PostsRepository) {
				m.On("Get", pagination, true, "", "").Return(nil, 0, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.PostsRepository) {
				m.On("Get", pagination, true, "", "").Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.PostsRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/posts", "/posts", nil, func(g *gin.Context) {
				getPostsMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestPosts_GetById - Test GetByID route
func TestPosts_GetById(t *testing.T) {

	post := domain.PostData{Post: domain.Post{Id: 123, Slug: "/post", Title: "post"}}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.PostsRepository)
		url     string
	}{
		"Success": {
			want:    `{"author":{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},"category":null,"post":{"created_at":null,"id":123,"options":{"edit_lock":"","meta":null,"seo":null},"published_at":null,"resource":null,"slug":"/post","title":"post","updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}}`,
			status:  200,
			message: "Successfully obtained post with ID: 123",
			mock: func(m *mocks.PostsRepository) {
				m.On("GetById", 123, true).Return(post, nil)
			},
			url: "/posts/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "Pass a valid number to obtain the post by ID",
			mock: func(m *mocks.PostsRepository) {
			},
			url: "/posts/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no posts found",
			mock: func(m *mocks.PostsRepository) {
				m.On("GetById", 123, true).Return(domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: "no posts found"})
				m.On("Format", post).Return(post, nil)
			},
			url: "/posts/123",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.PostsRepository) {
				m.On("GetById", 123, true).Return(domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/posts/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.PostsRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/posts/:id", nil, func(g *gin.Context) {
				getPostsMock(mock).GetById(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestPosts_Create - Test Create route
func TestPosts_Create(t *testing.T) {

	post := domain.Post{Id: 123, Slug: "/post", Title: "post"}
	postCreate := domain.PostCreate{Post: post}
	postBadValidation := domain.PostCreate{Post: domain.Post{Id: 123, Title: "post"}}
	postData := domain.PostData{Post: domain.Post{Id: 123, Slug: "/post", Title: "post"}}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.PostsRepository)
	}{
		"Success": {
			want:    `{"author":{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},"category":null,"post":{"created_at":null,"id":123,"options":{"edit_lock":"","meta":null,"seo":null},"published_at":null,"resource":null,"slug":"/post","title":"post","updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}}`,
			status:  200,
			message: "Successfully created post with ID: 123",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Create", &postCreate).Return(postData, nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"slug","message":"Post Slug is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   postBadValidation,
			mock: func(m *mocks.PostsRepository) {
				m.On("Create", &postBadValidation).Return(domain.PostData{}, fmt.Errorf("error"))
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Create", &postCreate).Return(domain.PostData{}, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Create", &postCreate).Return(domain.PostData{}, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Create", &postCreate).Return(domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.PostsRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/posts", "/posts", bytes.NewBuffer(body), func(g *gin.Context) {
				getPostsMock(mock).Create(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestPosts_Update - Test Update route
func TestPosts_Update(t *testing.T) {

	cache.Init()

	post := domain.Post{Id: 123, Slug: "/post", Title: "post"}
	postCreate := domain.PostCreate{Post: post}
	postBadValidation := domain.PostCreate{Post: domain.Post{Id: 123, Title: "post"}}
	postData := domain.PostData{Post: domain.Post{Id: 123, Slug: "/post", Title: "post"}}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.PostsRepository)
		url     string
	}{
		"Success": {
			want:    `{"author":{"biography":null,"created_at":"0001-01-01T00:00:00Z","email":"","email_verified_at":null,"facebook":null,"first_name":"","id":0,"instagram":null,"last_name":"","linked_in":null,"profile_picture_id":null,"role":{"description":"","id":0,"name":""},"twitter":null,"updated_at":"0001-01-01T00:00:00Z","uuid":"00000000-0000-0000-0000-000000000000"},"category":null,"post":{"created_at":null,"id":123,"options":{"edit_lock":"","meta":null,"seo":null},"published_at":null,"resource":null,"slug":"/post","title":"post","updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}}`,
			status:  200,
			message: "Successfully updated post with ID: 123",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Update", &postCreate).Return(postData, nil)
			},
			url: "/posts/123",
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"slug","message":"Post Slug is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   postBadValidation,
			mock: func(m *mocks.PostsRepository) {
				m.On("Update", postBadValidation).Return(domain.PostData{}, fmt.Errorf("error"))
			},
			url: "/posts/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update the post",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Update", &postCreate).Return(domain.PostData{}, fmt.Errorf("error"))
			},
			url: "/posts/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Update", &postCreate).Return(domain.PostData{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/posts/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   post,
			mock: func(m *mocks.PostsRepository) {
				m.On("Update", &postCreate).Return(domain.PostData{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/posts/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.PostsRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("PUT", test.url, "/posts/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				getPostsMock(mock).Update(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestPosts_Delete - Test Delete route
func TestPosts_Delete(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.PostsRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully deleted post with ID: 123",
			mock: func(m *mocks.PostsRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/posts/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to delete a post",
			mock: func(m *mocks.PostsRepository) {
				m.On("Delete", 0).Return(nil)
			},
			url: "/posts/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			mock: func(m *mocks.PostsRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/posts/123",
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.PostsRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
			url: "/posts/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.PostsRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/posts/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.PostsRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/posts/:id", nil, func(g *gin.Context) {
				getPostsMock(mock).Delete(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/forms_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getFormsMock is a helper to obtain a mock forms controller
// for testing.
func getFormsMock(m models.FormRepository) *Forms {
	return &Forms{
		store: &models.Store{
			Forms: m,
		},
	}
}

// Test_NewForms - Test construct
func Test_NewForms(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Forms{
		store:  &store,
		config: config,
	}
	got := NewForms(&store, config)
	assert.Equal(t, got, want)
}

// TestForms_Get - Test Get route
func TestForms_Get(t *testing.T) {

	forms := []domain.Form{
		{Id: 123, Name: "Form"},
		{Id: 124, Name: "Form1"},
	}
	pagination := params.Params{Page: 1, Limit: 15, OrderBy: "id", OrderDirection: "ASC", Filters: nil}

	tt := map[string]struct {
		name    string
		want    string
		status  int
		message string
		mock    func(m *mocks.FormRepository)
	}{
		"Success": {
			want:    `[{"created_at":null,"email_message":"","email_send":false,"email_subject":"","fields":null,"id":123,"name":"Form","store_db":false,"updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"},{"created_at":null,"email_message":"","email_send":false,"email_subject":"","fields":null,"id":124,"name":"Form1","store_db":false,"updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}]`,
			status:  200,
			message: "Successfully obtained forms",
			mock: func(m *mocks.FormRepository) {
				m.On("Get", pagination).Return(forms, 1, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no forms found",
			mock: func(m *mocks.FormRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no forms found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.FormRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(m *mocks.FormRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.FormRepository) {
				m.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.FormRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/forms", "/forms", nil, func(g *gin.Context) {
				getFormsMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestForms_GetById - Test GetByID route
func TestForms_GetById(t *testing.T) {

	form := domain.Form{Id: 123, Name: "Form"}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.FormRepository)
		url     string
	}{
		"Success": {
			want:    `{"created_at":null,"email_message":"","email_send":false,"email_subject":"","fields":null,"id":123,"name":"Form","store_db":false,"updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully obtained form with ID: 123",
			mock: func(m *mocks.FormRepository) {
				m.On("GetById", 123).Return(form, nil)
			},
			url: "/forms/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "Pass a valid number to obtain the form by ID",
			mock: func(m *mocks.FormRepository) {
				m.On("GetById", 123).Return(domain.Form{}, fmt.Errorf("error"))
			},
			url: "/forms/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no forms found",
			mock: func(m *mocks.FormRepository) {
				m.On("GetById", 123).Return(domain.Form{}, &errors.Error{Code: errors.NOTFOUND, Message: "no forms found"})
			},
			url: "/forms/123",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.FormRepository) {
				m.On("GetById", 123).Return(domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/forms/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.FormRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/forms/:id", nil, func(g *gin.Context) {
				getFormsMock(mock).GetById(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestForms_Create - Test Create route
func TestForms_Create(t *testing.T) {

	form := domain.Form{Id: 123, Name: "Form"}
	formBadValidation := domain.Form{Id: 123}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.FormRepository)
	}{
		"Success": {
			want:    `{"created_at":null,"email_message":"","email_send":false,"email_subject":"","fields":null,"id":123,"name":"Form","store_db":false,"updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully created form with ID: 123",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Create", &form).Return(form, nil)
			},
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"name","message":"Name is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   formBadValidation,
			mock: func(m *mocks.FormRepository) {
				m.On("Create", &formBadValidation).Return(domain.Form{}, fmt.Errorf("error"))
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Create", &form).Return(domain.Form{}, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Create", &form).Return(domain.Form{}, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Create", &form).Return(domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.FormRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("POST", "/forms", "/forms", bytes.NewBuffer(body), func(g *gin.Context) {
				getFormsMock(mock).Create(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestForms_Update - Test Update route
func TestForms_Update(t *testing.T) {

	form := domain.Form{Id: 123, Name: "Category"}
	formBadValidation := domain.Category{Id: 123}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(m *mocks.FormRepository)
		url     string
	}{
		"Success": {
			want:    `{"created_at":null,"email_message":"","email_send":false,"email_subject":"","fields":null,"id":123,"name":"Category","store_db":false,"updated_at":null,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully updated form with ID: 123",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Update", &form).Return(form, nil)
			},
			url: "/forms/123",
		},
		"Validation Failed": {
			want:    `{"errors":[{"key":"name","message":"Name is required.","type":"required"}]}`,
			status:  400,
			message: "Validation failed",
			input:   formBadValidation,
			mock: func(m *mocks.FormRepository) {
				m.On("Update", formBadValidation).Return(domain.Form{}, fmt.Errorf("error"))
			},
			url: "/forms/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update the form",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Update", form).Return(domain.Form{}, fmt.Errorf("error"))
			},
			url: "/forms/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Update", &form).Return(domain.Form{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/forms/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   form,
			mock: func(m *mocks.FormRepository) {
				m.On("Update", &form).Return(domain.Form{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/forms/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.FormRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("PUT", test.url, "/forms/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				getFormsMock(mock).Update(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestForms_Delete - Test Delete route
func TestForms_Delete(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.FormRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully deleted form with ID: 123",
			mock: func(m *mocks.FormRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/forms/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to delete a form",
			mock: func(m *mocks.FormRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/forms/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			mock: func(m *mocks.FormRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/forms/123",
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.FormRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
			url: "/forms/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.FormRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/forms/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.FormRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/forms/:id", nil, func(g *gin.Context) {
				getFormsMock(mock).Delete(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TODO
func TestForms_Send(t *testing.T) {

}"
}
{
file:./api/http/handler/api/api_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

// controllerTest represents the suite of testing methods for controllers.
type controllerTest struct {
	testing  *testing.T
	recorder *httptest.ResponseRecorder
	gin      *gin.Context
	engine   *gin.Engine
}

// newTestSuite - New recorder for testing
// controllers, initalises gin & sets gin mode.
func newTestSuite(t *testing.T) *controllerTest {
	gin.SetMode(gin.TestMode)
	gin.DefaultWriter = ioutil.Discard
	rr := httptest.NewRecorder()
	gin, engine := gin.CreateTestContext(rr)

	return &controllerTest{
		testing:  t,
		recorder: rr,
		gin:      gin,
		engine:   engine,
	}
}

// Run the API test.
func (c *controllerTest) Run(want string, status int, message string) {
	assert.JSONEq(c.testing, want, c.Data())
	assert.Equal(c.testing, status, c.recorder.Code)
	assert.Equal(c.testing, message, c.Message())
	assert.Equal(c.testing, c.recorder.Header().Get("Content-Type"), "application/json; charset=utf-8")
}

// Message gets the response message from the body
func (c *controllerTest) Message() string {
	b, ok := c.Body()["message"]
	if !ok {
		c.testing.Error("no message within the response")
	}
	return b.(string)
}

// Body gets the response body from the request
func (c *controllerTest) Body() map[string]interface{} {
	body := map[string]interface{}{}
	if err := json.Unmarshal(c.recorder.Body.Bytes(), &body); err != nil {
		c.testing.Fatal(fmt.Sprintf("error unmarshalling body %v", err))
	}
	return body
}

// getResponseData gets the response body & checks if the data key
// exists and then marshalls the data key to form a string.
func (c *controllerTest) Data() string {
	b, ok := c.Body()["data"]
	if !ok {
		c.testing.Fatal("no data within the response")
	}

	got, err := json.Marshal(b)
	if err != nil {
		c.testing.Fatal(fmt.Sprintf("error marshalling data %v", err))
	}

	return string(got)
}

// NewRequest makes a new http.Request and assigns the gin testing
// the request.
func (c *controllerTest) NewRequest(method string, url string, body io.Reader) {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		c.testing.Fatal(err)
	}
	c.gin.Request = req
}

// NewRequest makes a new http.Request and assigns the gin testing
// the request, serves HTTP.
func (c *controllerTest) RequestAndServe(method string, url string, engineUrl string, body io.Reader, handler func(ctx *gin.Context)) {
	switch method {
	case "GET":
		c.engine.GET(engineUrl, handler)
	case "POST":
		c.engine.POST(engineUrl, handler)
	case "PUT":
		c.engine.PUT(engineUrl, handler)
	case "DELETE":
		c.engine.DELETE(engineUrl, handler)
	}
	c.NewRequest(method, url, body)
	c.engine.ServeHTTP(c.recorder, c.gin.Request)
}"
}
{
file:./api/http/handler/api/media_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io"
	"mime/multipart"
	gohttp "net/http"
	"os"
	"path/filepath"
	"testing"
)

// getMediaMock is a helper to obtain a mock user controller
// for testing.
func getMediaMock(m models.MediaRepository) *Media {
	return &Media{
		store: &models.Store{
			Media: m,
		},
	}
}

// Test_NewMedia - Test construct
func Test_NewMedia(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Media{
		store:  &store,
		config: config,
	}
	got := NewMedia(&store, config)
	assert.Equal(t, got, want)
}

// TestMedia_Get - Test Get route
func TestMedia_Get(t *testing.T) {

	media := []domain.Media{
		{Id: 123, Url: "/logo.svg"},
		{Id: 124, Url: "/logo.png"},
	}
	pagination := params.Params{Page: 1, Limit: 15, OrderBy: "id", OrderDirection: "ASC", Filters: nil}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.MediaRepository)
	}{
		"Success": {
			want:    `[{"alt":"","created_at":"0001-01-01T00:00:00Z","description":"","file_name":"","file_size":0,"id":123,"sizes":null,"title":"","type":"","updated_at":"0001-01-01T00:00:00Z","url":"/logo.svg","user_id":0,"uuid":"00000000-0000-0000-0000-000000000000"},{"alt":"","created_at":"0001-01-01T00:00:00Z","description":"","file_name":"","file_size":0,"id":124,"sizes":null,"title":"","type":"","updated_at":"0001-01-01T00:00:00Z","url":"/logo.png","user_id":0,"uuid":"00000000-0000-0000-0000-000000000000"}]`,
			status:  200,
			message: "Successfully obtained media",
			mock: func(u *mocks.MediaRepository) {
				u.On("Get", pagination).Return(media, 1, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no media found",
			mock: func(u *mocks.MediaRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.NOTFOUND, Message: "no media found"})
			},
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(u *mocks.MediaRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
		},
		"Invalid": {
			want:    `{}`,
			status:  400,
			message: "invalid",
			mock: func(u *mocks.MediaRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(u *mocks.MediaRepository) {
				u.On("Get", pagination).Return(nil, 0, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.MediaRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/users", "/users", nil, func(g *gin.Context) {
				getMediaMock(mock).Get(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestMedia_GetById - Test GetByID route
func TestMedia_GetById(t *testing.T) {

	media := domain.Media{
		Id:  123,
		Url: "/logo.svg",
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(m *mocks.MediaRepository)
		url     string
	}{
		"Success": {
			want:    `{"alt":"","created_at":"0001-01-01T00:00:00Z","description":"","file_name":"","file_size":0,"id":123,"sizes":null,"title":"","type":"","updated_at":"0001-01-01T00:00:00Z","url":"/logo.svg","user_id":0,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully obtained media item with ID: 123",
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 123).Return(media, nil)
			},
			url: "/media/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "Pass a valid number to obtain the media item by ID",
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 123).Return(domain.Media{}, fmt.Errorf("error"))
			},
			url: "/media/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "no media items found",
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 123).Return(domain.Media{}, &errors.Error{Code: errors.NOTFOUND, Message: "no media items found"})
			},
			url: "/media/123",
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 123).Return(domain.Media{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/media/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.MediaRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", test.url, "/media/:id", nil, func(g *gin.Context) {
				getMediaMock(mock).GetById(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestMedia_Update - Test Update route
func TestMedia_Update(t *testing.T) {

	media := domain.Media{
		Id:  123,
		Url: "/logo.svg",
	}

	mediaBadValidation := &domain.Media{}

	tt := map[string]struct {
		want    string
		status  int
		message string
		input   interface{}
		mock    func(u *mocks.MediaRepository)
		url     string
	}{
		"Success": {
			want:    `{"alt":"","created_at":"0001-01-01T00:00:00Z","description":"","file_name":"","file_size":0,"id":123,"sizes":null,"title":"","type":"","updated_at":"0001-01-01T00:00:00Z","url":"/logo.svg","user_id":0,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully updated media item with ID: 123",
			input:   media,
			mock: func(m *mocks.MediaRepository) {
				m.On("Update", &media).Return(nil)
			},
			url: "/media/123",
		},
		"Validation Failed": {
			want:    `{}`,
			status:  400,
			message: "Validation failed",
			input:   `{"id": "wrongid"}`,
			mock: func(m *mocks.MediaRepository) {
				m.On("Update", mediaBadValidation).Return(fmt.Errorf("error"))
			},
			url: "/media/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to update the media item",
			input:   media,
			mock: func(m *mocks.MediaRepository) {
				m.On("Update", media).Return(fmt.Errorf("error"))
			},
			url: "/media/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			input:   media,
			mock: func(m *mocks.MediaRepository) {
				m.On("Update", &media).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/media/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			input:   media,
			mock: func(m *mocks.MediaRepository) {
				m.On("Update", &media).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/media/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.MediaRepository{}
			test.mock(mock)

			body, err := json.Marshal(test.input)
			if err != nil {
				t.Fatal(err)
			}

			rr.RequestAndServe("PUT", test.url, "/media/:id", bytes.NewBuffer(body), func(g *gin.Context) {
				getMediaMock(mock).Update(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestMedia_Upload - Test Upload route
func TestMedia_Upload(t *testing.T) {

	wd, err := os.Getwd()
	assert.NoError(t, err)
	apiPath := filepath.Join(filepath.Dir(wd), "../..")
	path := apiPath + "/test/testdata/spa/images/gopher.svg"

	tt := map[string]struct {
		want    string
		status  int
		message string
		files   int
		mock    func(u *mocks.MediaRepository, multi []multipart.FileHeader)
		url     string
	}{
		"Success": {
			want:    `{"alt":"","created_at":"0001-01-01T00:00:00Z","description":"","file_name":"","file_size":0,"id":0,"sizes":null,"title":"","type":"","updated_at":"0001-01-01T00:00:00Z","url":"","user_id":0,"uuid":"00000000-0000-0000-0000-000000000000"}`,
			status:  200,
			message: "Successfully uploaded media item",
			files:   1,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", &multi[0], "").Return(domain.Media{}, nil)
				m.On("Validate", &multi[0]).Return(nil)
			},
			url: "/media",
		},
		"No Form": {
			want:    `{}`,
			status:  400,
			message: "No files attached to the upload",
			files:   0,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", multipart.FileHeader{}, "").Return(domain.Media{}, nil)
				m.On("Validate", multipart.FileHeader{}).Return(nil)
			},
			url: "/media",
		},
		"No Files": {
			want:    `{}`,
			status:  400,
			message: "Attach a file to the request to be uploaded",
			files:   0,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", multipart.FileHeader{}, "").Return(domain.Media{}, nil)
				m.On("Validate", multipart.FileHeader{}).Return(nil)
			},
			url: "/media",
		},
		"Too Many Files": {
			want:    `{}`,
			status:  400,
			message: "Files are only permitted to be uploaded one at a time",
			files:   5,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", &multi[0], "").Return(domain.Media{}, nil)
				m.On("Validate", &multi[0]).Return(nil)
			},
			url: "/media",
		},
		"Invalid": {
			want:    `{}`,
			status:  415,
			message: "invalid",
			files:   1,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", &multi[0], "").Return(domain.Media{}, nil)
				m.On("Validate", &multi[0]).Return(&errors.Error{Code: errors.INVALID, Message: "invalid"})
			},
			url: "/media",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			files:   1,
			mock: func(m *mocks.MediaRepository, multi []multipart.FileHeader) {
				m.On("Upload", &multi[0], "").Return(domain.Media{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
				m.On("Validate", &multi[0]).Return(nil)
			},
			url: "/media",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)

			request, multi := newfileUploadRequest(t, test.files, "https://google.com/upload", path)

			mock := &mocks.MediaRepository{}
			test.mock(mock, multi)
			rr.gin.Request = request

			if name == "No Form" {
				rr.RequestAndServe("POST", test.url, "/media", nil, func(g *gin.Context) {
					getMediaMock(mock).Upload(rr.gin)
				})
				return
			}

			getMediaMock(mock).Upload(rr.gin)
			rr.Run(test.want, test.status, test.message)
		})
	}
}

// newfileUploadRequest - is a helper for setting up test files for the upload
// endpoint. Creates a new file upload http request with optional
// extra params
func newfileUploadRequest(t *testing.T, filesAmount int, uri string, path string) (*gohttp.Request, []multipart.FileHeader) {
	file, err := os.Open(path)
	assert.NoError(t, err)
	defer file.Close()

	reqBody := bytes.Buffer{}
	var multi []multipart.FileHeader
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	for i := 0; i < filesAmount; i++ {
		part, err := writer.CreateFormFile("file", filepath.Base(path))
		assert.NoError(t, err)
		_, err = io.Copy(part, file)
		assert.NoError(t, err)
	}

	err = writer.Close()
	assert.NoError(t, err)

	reqBody.Write(body.Bytes())

	if filesAmount != 0 {
		mr := multipart.NewReader(body, writer.Boundary())
		mt, err := mr.ReadForm(99999)
		assert.NoError(t, err)
		ft := mt.File["file"][0]
		multi = append(multi, *ft)
	}

	//&{map[] map[file:[0xc0002783c0 0xc000278410]]}

	req, err := gohttp.NewRequest("POST", uri, bytes.NewBuffer(reqBody.Bytes()))
	req.Header.Set("Content-Type", writer.FormDataContentType())

	return req, multi
}

// TestMedia_Delete - Test Delete route
func TestMedia_Delete(t *testing.T) {

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.MediaRepository)
		url     string
	}{
		"Success": {
			want:    `{}`,
			status:  200,
			message: "Successfully deleted media item with ID: 123",
			mock: func(u *mocks.MediaRepository) {
				u.On("Delete", 123).Return(nil)
			},
			url: "/media/123",
		},
		"Invalid ID": {
			want:    `{}`,
			status:  400,
			message: "A valid ID is required to delete a media item",
			mock: func(m *mocks.MediaRepository) {
				m.On("Delete", 123).Return(nil)
			},
			url: "/media/wrongid",
		},
		"Not Found": {
			want:    `{}`,
			status:  400,
			message: "not found",
			mock: func(m *mocks.MediaRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
			url: "/media/123",
		},
		"Conflict": {
			want:    `{}`,
			status:  400,
			message: "conflict",
			mock: func(m *mocks.MediaRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.CONFLICT, Message: "conflict"})
			},
			url: "/media/123",
		},
		"Internal": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.MediaRepository) {
				m.On("Delete", 123).Return(&errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
			url: "/media/123",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.MediaRepository{}
			test.mock(mock)

			rr.RequestAndServe("DELETE", test.url, "/media/:id", nil, func(g *gin.Context) {
				getMediaMock(mock).Delete(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/api/site_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package api

import (
	"encoding/json"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"testing"
)

// getSiteMock is a helper to obtain a mock site controller
// for testing.
func getSiteMock(m models.SiteRepository) *Site {
	return &Site{
		store: &models.Store{
			Site: m,
		},
	}
}

// Test_NewSite - Test construct
func Test_NewSite(t *testing.T) {
	store := models.Store{}
	config := config.Configuration{}
	want := &Site{
		store:  &store,
		config: config,
	}
	got := NewSite(&store, config)
	assert.Equal(t, got, want)
}

// TestSite_GetSite - Test GetSite route
func TestSite_GetSite(t *testing.T) {

	rr := newTestSuite(t)

	t.Run("Success", func(t *testing.T) {

		site := &domain.Site{
			Title:       "Verbis",
			Description: "VerbisCMS",
			Logo:        "/logo.svg",
			Url:         "verbiscms.com",
			Version:     "0.1",
		}
		siteMock := mocks.SiteRepository{}
		siteMock.On("GetGlobalConfig").Return(site)

		Site := Site{
			store: &models.Store{
				Site: &siteMock,
			},
		}

		Site.GetSite(rr.gin)

		want, err := json.Marshal(site)
		if err != nil {
			t.Fatal(err)
		}

		rr.Run(string(want), 200, "Successfully obtained site config")
	})
}

// TestSite_GetTheme - Test GetTheme route
func TestSite_GetTheme(t *testing.T) {

	theme := domain.ThemeConfig{
		Theme: domain.Theme{
			Title:       "Verbis",
			Description: "VerbisCMS",
			Version:     "0.1",
		},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.SiteRepository)
	}{
		"Success": {
			want:    `{"assets_path":"","editor":{"modules":null,"options":null},"file_extension":"","layout_dir":"","resources":null,"template_dir":"","theme":{"description":"VerbisCMS","title":"Verbis","version":"0.1"}}`,
			status:  200,
			message: "Successfully obtained theme config",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetThemeConfig").Return(theme, nil)
			},
		},
		//"Internal Error": {
		//	want:    `{}`,
		//	status:  500,
		//	message: "internal",
		//	mock: func(m *mocks.SiteRepository) {
		//		m.On("GetThemeConfig").Return(domain.ThemeConfig{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
		//	},
		//},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.SiteRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/theme", "/theme", nil, func(g *gin.Context) {
				getSiteMock(mock).GetTheme(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestSite_GetTemplates - Test GetTemplates route
func TestSite_GetTemplates(t *testing.T) {

	templates := domain.Templates{
		Template: []map[string]interface{}{
			{
				"test": "testing",
			},
		},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.SiteRepository)
	}{
		"Success": {
			want:    `{"templates":[{"test":"testing"}]}`,
			status:  200,
			message: "Successfully obtained templates",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetTemplates").Return(templates, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "not found",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetTemplates").Return(domain.Templates{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetTemplates").Return(domain.Templates{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.SiteRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/theme", "/theme", nil, func(g *gin.Context) {
				getSiteMock(mock).GetTemplates(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}

// TestSite_GetLayouts - Test GetLayouts route
func TestSite_GetLayouts(t *testing.T) {

	layouts := domain.Layouts{
		Layout: []map[string]interface{}{
			{
				"test": "testing",
			},
		},
	}

	tt := map[string]struct {
		want    string
		status  int
		message string
		mock    func(u *mocks.SiteRepository)
	}{
		"Success": {
			want:    `{"layouts":[{"test":"testing"}]}`,
			status:  200,
			message: "Successfully obtained layouts",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetLayouts").Return(layouts, nil)
			},
		},
		"Not Found": {
			want:    `{}`,
			status:  200,
			message: "not found",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetLayouts").Return(domain.Layouts{}, &errors.Error{Code: errors.NOTFOUND, Message: "not found"})
			},
		},
		"Internal Error": {
			want:    `{}`,
			status:  500,
			message: "internal",
			mock: func(m *mocks.SiteRepository) {
				m.On("GetLayouts").Return(domain.Layouts{}, &errors.Error{Code: errors.INTERNAL, Message: "internal"})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			rr := newTestSuite(t)
			mock := &mocks.SiteRepository{}
			test.mock(mock)

			rr.RequestAndServe("GET", "/theme", "/theme", nil, func(g *gin.Context) {
				getSiteMock(mock).GetLayouts(g)
			})

			rr.Run(test.want, test.status, test.message)
		})
	}
}"
}
{
file:./api/http/handler/handler_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package handler

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/ainsleyclark/verbis/api/http/handler/frontend"
	"github.com/ainsleyclark/verbis/api/http/handler/spa"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/stretchr/testify/assert"
	"testing"
)

// Test_New - Test construct
func Test_New(t *testing.T) {
	mockSite := mocks.SiteRepository{}
	mockSite.On("GetThemeConfig").Return(domain.ThemeConfig{}, nil)
	mockOptions := mocks.OptionsRepository{}
	mockOptions.On("GetStruct").Return(domain.Options{})
	m := &models.Store{
		Options: &mockOptions,
		Site:    &mockSite,
	}
	c := config.Configuration{}
	want := &Handler{
		Auth:       api.NewAuth(m, c),
		Cache:      api.NewCache(),
		Categories: api.NewCategories(m, c),
		Fields:     api.NewFields(m, c),
		Media:      api.NewMedia(m, c),
		Options:    api.NewwOptions(m, c),
		Posts:      api.NewPosts(m, c),
		Site:       api.NewSite(m, c),
		User:       api.NewUser(m, c),
		SPA:        spa.NewSpa(m, c),
		Frontend:   frontend.NewPublic(m, c),
		SEO:        frontend.NewSEO(m, c),
	}
	got := New(m, c)
	assert.ObjectsAreEqual(want, got)
}"
}
{
file:./api/http/middleware/cors.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/gin-gonic/gin"
)

func CORS() gin.HandlerFunc {
	return func(g *gin.Context) {
		g.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		g.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		g.Writer.Header().Set("Access-Control-Allow-Headers", "access-control-allow-origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Origin, Cache-Control, X-Requested-With, token")
		g.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if g.Request.Method == "OPTIONS" {
			g.AbortWithStatus(200)
			return
		}

		g.Next()
	}
}"
}
{
file:./api/http/middleware/cors_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

// TestCORS - Test Cors headers
func TestCORS(t *testing.T) {

	tt := map[string]struct {
		origin string
		want   string
	}{
		"Access Control": {
			origin: "Access-Control-Allow-Origin",
			want:   "*",
		},
		"Allow Credentials": {
			origin: "Access-Control-Allow-Credentials",
			want:   "true",
		},
		"Allow Headers": {
			origin: "Access-Control-Allow-Headers",
			want:   "access-control-allow-origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Origin, Cache-Control, X-Requested-With, token",
		},
		"Allow Methods": {
			origin: "Access-Control-Allow-Methods",
			want:   "POST, OPTIONS, GET, PUT, DELETE",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)
			gin.DefaultWriter = ioutil.Discard
			r := gin.Default()
			r.Use(CORS())

			server := httptest.NewServer(r)
			defer server.Close()

			client := &http.Client{}
			req, err := http.NewRequest("GET", "http://"+server.Listener.Addr().String()+"/api", nil)
			assert.NoError(t, err)
			req.Header.Add("Origin", test.origin)

			get, err := client.Do(req)
			assert.NoError(t, err)

			o := get.Header.Get(test.origin)
			assert.Equal(t, test.want, o)
		})
	}
}

// TestCORS_AbortOptions - Test Cors abort options
func TestCORS_AbortOptions(t *testing.T) {
	gin.SetMode(gin.TestMode)
	gin.DefaultWriter = ioutil.Discard
	r := gin.Default()
	r.Use(CORS())

	server := httptest.NewServer(r)
	defer server.Close()

	client := &http.Client{}
	req, err := http.NewRequest("OPTIONS", "http://"+server.Listener.Addr().String()+"/api", nil)
	assert.NoError(t, err)

	opts, err := client.Do(req)
	assert.NoError(t, err)

	assert.Equal(t, http.NoBody, opts.Body)
	assert.Equal(t, 200, opts.StatusCode)
}"
}
{
file:./api/http/middleware/emptybody.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"bytes"
	"encoding/json"
	"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/gin-gonic/gin"
	"io/ioutil"
)

func EmptyBody() gin.HandlerFunc {
	return func(g *gin.Context) {

		contentType := g.Request.Header.Get("Content-Type")
		if contentType != "application/json" && contentType != "application/json; charset=utf-8" {
			g.Next()
			return
		}

		method := g.Request.Method
		if method == "POST" || method == "PUT" {
			bodyBytes, _ := ioutil.ReadAll(g.Request.Body)

			if isEmpty(g, bodyBytes) {
				api.AbortJSON(g, 401, "Empty JSON body", nil)
				return
			}

			if !isJSON(string(bodyBytes)) {
				api.AbortJSON(g, 401, "Invalid JSON", nil)
				return
			}
		}

		g.Next()
	}
}

// Checks if the request is empty
func isEmpty(g *gin.Context, body []byte) bool {
	_ = g.Request.Body.Close() //  must close
	g.Request.Body = ioutil.NopCloser(bytes.NewBuffer(body))
	return len(body) == 0
}

// Checks if the request is valid json
func isJSON(s string) bool {
	var js interface{}
	return json.Unmarshal([]byte(s), &js) == nil
}"
}
{
file:./api/http/middleware/redirects_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/gin-contrib/location"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

// TestRedirects - Test redirects from options are working correctly
// with correct code & locationjson.
func Test_Redirects(t *testing.T) {

	tt := map[string]struct {
		status      int
		url         string
		redirectUrl string
		mock        func(u *mocks.OptionsRepository)
	}{
		"No Redirects": {
			status: 200,
			url:    "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: nil,
				})
			},
		},
		"300": {
			status:      300,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 300},
					},
				})
			},
		},
		"301": {
			status:      301,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 301},
					},
				})
			},
		},
		"302": {
			status:      302,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 302},
					},
				})
			},
		},
		"303": {
			status:      303,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 303},
					},
				})
			},
		},
		"304": {
			status:      304,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 304},
					},
				})
			},
		},
		"307": {
			status:      307,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 307},
					},
				})
			},
		},
		"308": {
			status:      308,
			url:         "/page/test",
			redirectUrl: "/page",
			mock: func(m *mocks.OptionsRepository) {
				m.On("GetStruct").Return(domain.Options{
					SeoRedirects: []domain.Redirect{
						{To: "/page", From: "http://localhost:8080/page/test", Code: 308},
					},
				})
			},
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			rr := httptest.NewRecorder()
			g, engine := gin.CreateTestContext(rr)
			engine.Use(location.Default())

			mock := &mocks.OptionsRepository{}
			test.mock(mock)
			engine.Use(Redirects(mock))

			engine.GET("/page", func(context *gin.Context) {
				g.String(200, "verbis")
				return
			})

			req, err := http.NewRequest("GET", test.url, nil)
			assert.NoError(t, err)

			engine.ServeHTTP(rr, req)

			assert.Equal(t, test.status, rr.Result().StatusCode)

			if test.redirectUrl != "" {
				loc, err := rr.Result().Location()
				assert.NoError(t, err)
				assert.Equal(t, test.redirectUrl, loc.Path)
			}
		})
	}
}"
}
{
file:./api/http/middleware/tokencheck.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/gin-gonic/gin"
)

// Administrator middleware
func AdminTokenCheck(d *deps.Deps) gin.HandlerFunc {
	return func(g *gin.Context) {

		if err := checkTokenExists(g); err != nil {
			return
		}

		u, err := checkUserToken(d, g)
		if err != nil {
			return
		}

		if u.Role.Id > 1 {
			g.Next()
		} else {
			api.AbortJSON(g, 403, "You must have access level of administrator to access this endpoint.", nil)
			return
		}
	}
}

// Operator middleware
func OperatorTokenCheck(d *deps.Deps) gin.HandlerFunc {
	return func(g *gin.Context) {

		if err := checkTokenExists(g); err != nil {
			return
		}

		u, err := checkUserToken(d, g)
		if err != nil {
			return
		}

		if u.Role.Id > 0 {
			g.Next()
		} else {
			api.AbortJSON(g, 403, "You must have access level of operator to access this endpoint.", nil)
			return
		}
	}
}

// Check if the token exists in the header
func checkTokenExists(g *gin.Context) error {
	token := g.Request.Header.Get("token")
	if token == "" {
		api.AbortJSON(g, 401, "Missing token in the request header", nil)
		return fmt.Errorf("Missing token")
	}
	return nil
}

// Check the user token and return the user if passes
func checkUserToken(d *deps.Deps, g *gin.Context) (*domain.User, error) {
	token := g.Request.Header.Get("token")

	u, err := d.Store.User.CheckToken(token)
	if err != nil {
		api.AbortJSON(g, 401, "Invalid token in the request header", nil)
		return &domain.User{}, err
	}

	if u.Role.Id == 0 {
		api.AbortJSON(g, 403, "Your account has been suspended by the administration team", nil)
		return &domain.User{}, err
	}

	return &u, nil
}

// Check to see if the session has expired
func checkSession(g *gin.Context, userId int) error {

	//if hasSession := m.Has(userId); !hasSession {
	//	return nil
	//}

	//err := m.Check(userId);
	//if err != nil {
	//	controllers.AbortJSON(g, 401, errors.Message(err), err)
	//	return err
	//}

	return nil
}"
}
{
file:./api/http/middleware/logger.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"time"
)

func Log() gin.HandlerFunc {
	return func(g *gin.Context) {
		// Start time
		startTime := time.Now()
		// Set request time for execution
		g.Set("request_time", startTime)
		// Processing request
		g.Next()
		// Error
		var verbisError errors.Error
		e, exists := g.Get("verbis_error")
		if exists {
			e, ok := e.(*errors.Error)
			if ok {
				verbisError = *e
			}
		}
		// Message
		var verbisMessage string
		m, exists := g.Get("verbis_message")
		if exists {
			m, ok := m.(string)
			if ok {
				verbisMessage = m
			}
		} else if verbisError.Message != "" {
			verbisMessage = verbisError.Message
		} else {
			verbisMessage = ""
		}
		// End time
		endTime := time.Now()
		// Execution time
		latencyTime := endTime.Sub(startTime)
		// Request mode
		reqMethod := g.Request.Method
		// Request routing
		reqUri := g.Request.RequestURI
		// Status code
		statusCode := g.Writer.Status()
		// Request IP
		clientIP := g.ClientIP()
		// Data Length
		dataLength := g.Writer.Size()
		// User agent
		clientUserAgent := g.Request.UserAgent()
		// Log fields
		fields := log.Fields{
			"status_code":    statusCode,
			"latency_time":   latencyTime,
			"client_ip":      clientIP,
			"request_method": reqMethod,
			"request_url":    reqUri,
			"data_length":    dataLength,
			"user_agent":     clientUserAgent,
			"message":        verbisMessage,
			"error":          verbisError,
		}

		if verbisError.Code == errors.TEMPLATE {
			fields["status_code"] = 500
		}

		// Log format
		if verbisError.Code == errors.TEMPLATE || verbisError.Code == errors.INTERNAL {
			log.WithFields(fields).Panic()
		} else if statusCode >= 200 && statusCode < 400 {
			log.WithFields(fields).Info()
		} else {
			log.WithFields(fields).Error()
		}
	}
}"
}
{
file:./api/http/middleware/session.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/http/handler/api"
	"github.com/gin-gonic/gin"
)

func SessionCheck(d *deps.Deps) gin.HandlerFunc {
	return func(g *gin.Context) {
		token := g.Request.Header.Get("token")

		if err := d.Store.User.CheckSession(token); err != nil {
			g.SetCookie("verbis-session", "", -1, "/", "", false, true)
			api.AbortJSON(g, 401, "Session expired, please login again", gin.H{
				"errors": gin.H{
					"session": "expired",
				},
			})
			return
		}

		g.Next()
	}
}"
}
{
file:./api/http/middleware/tokencheck_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware"
}
{
file:./api/http/middleware/emptybody_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"bytes"
	"encoding/json"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

// handler is ac helper func for the EmptyBody testing
func handler(g *gin.Context) {
	g.String(200, "verbis")
	return
}

// TestEmptyBody - Test EmptyBody handler
func TestEmptyBody(t *testing.T) {

	tt := map[string]struct {
		method        string
		header        string
		input         string
		message       string
		status        int
		returnContent string
		want          string
	}{
		"Valid": {
			want:          "verbis",
			input:         `{verbis: "cms"}`,
			method:        http.MethodDelete,
			status:        200,
			header:        "application/json",
			returnContent: "text/plain; charset=utf-8",
		},
		"Not JSON": {
			want:          "verbis",
			input:         "",
			method:        http.MethodGet,
			status:        200,
			header:        "text/plain; charset=utf-8",
			returnContent: "text/plain; charset=utf-8",
		},
		"Empty Body": {
			want:          "",
			input:         "",
			message:       "Empty JSON body",
			method:        http.MethodPost,
			status:        401,
			header:        "application/json; charset=utf-8",
			returnContent: "application/json; charset=utf-8",
		},
		"Invalid JSON": {
			want:          "",
			input:         "notjson",
			message:       "Invalid JSON",
			method:        http.MethodPost,
			status:        401,
			header:        "application/json; charset=utf-8",
			returnContent: "application/json; charset=utf-8",
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			rr := httptest.NewRecorder()
			context, engine := gin.CreateTestContext(rr)
			engine.Use(EmptyBody())

			engine.GET("/test", handler)
			engine.PUT("/test", handler)
			engine.POST("/test", handler)
			engine.DELETE("/test", handler)

			context.Request, _ = http.NewRequest(test.method, "/test", bytes.NewBuffer([]byte(test.input)))
			context.Request.Header.Add("Content-Type", test.header)
			engine.ServeHTTP(rr, context.Request)

			assert.Equal(t, test.status, rr.Code)
			assert.Equal(t, test.returnContent, rr.Header().Get("content-type"))

			if test.message != "" {
				var body map[string]interface{}
				err := json.Unmarshal(rr.Body.Bytes(), &body)
				assert.NoError(t, err)
				assert.Equal(t, test.message, body["message"])
			} else {
				assert.Equal(t, test.want, rr.Body.String())
			}
		})
	}
}

// Test_isEmpty - Test checker for empty body
func Test_isEmpty(t *testing.T) {

	tt := map[string]struct {
		want  bool
		input string
	}{
		"Empty": {
			want:  true,
			input: "",
		},
		"With Body": {
			want:  false,
			input: "{}",
		},
		"With Body JSON": {
			want:  false,
			input: `{body: "verbis"}`,
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			rr := httptest.NewRecorder()
			context, engine := gin.CreateTestContext(rr)

			var got bool
			engine.GET("/test", func(g *gin.Context) {
				bodyBytes, _ := ioutil.ReadAll(g.Request.Body)
				got = isEmpty(context, bodyBytes)
			})

			context.Request, _ = http.NewRequest("GET", "/test", bytes.NewBuffer([]byte(test.input)))
			engine.ServeHTTP(rr, context.Request)

			assert.Equal(t, test.want, got)
		})
	}
}

// Test_isJSON - Test checker for is JSON
func Test_isJSON(t *testing.T) {

	tt := map[string]struct {
		want  bool
		input string
	}{
		"Empty": {
			want:  false,
			input: "",
		},
		"With Body": {
			want:  true,
			input: "{}",
		},
		"With Body JSON": {
			want:  true,
			input: `{"body": "verbis"}`,
		},
	}

	for name, test := range tt {

		t.Run(name, func(t *testing.T) {
			gin.SetMode(gin.TestMode)

			rr := httptest.NewRecorder()
			context, engine := gin.CreateTestContext(rr)

			var got bool
			engine.GET("/test", func(g *gin.Context) {
				bodyBytes, _ := ioutil.ReadAll(g.Request.Body)
				got = isJSON(string(bodyBytes))
			})

			context.Request, _ = http.NewRequest("GET", "/test", bytes.NewBuffer([]byte(test.input)))
			engine.ServeHTTP(rr, context.Request)

			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/http/middleware/redirects.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/gin-contrib/location"
	"github.com/gin-gonic/gin"
)

func Redirects(options *domain.Options) gin.HandlerFunc {
	return func(g *gin.Context) {
		path := location.Get(g).String() + g.Request.URL.String()

		for _, v := range options.SeoRedirects {
			if path == v.From {
				g.Redirect(v.Code, v.To)
				return
			}
		}

		g.Next()
	}
}"
}
{
file:./api/http/middleware/session_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package middleware

import (
	"encoding/json"
	"fmt"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

// TestRedirects - Test redirects from options are working correctly
// with correct code & locationjson.
func Test_SessionCheck(t *testing.T) {
	gin.SetMode(gin.TestMode)

	t.Run("Session Expired", func(t *testing.T) {
		token := "tokenVal"
		mock := mocks.UserRepository{}
		mock.On("CheckSession", token).Return(fmt.Errorf("error"))

		rr := httptest.NewRecorder()
		g, engine := gin.CreateTestContext(rr)
		engine.Use(SessionCheck(&mock))

		engine.GET("/test", func(context *gin.Context) {
			g.String(200, "verbis")
		})

		g.Request, _ = http.NewRequest("GET", "/test", nil)
		g.Request.Header.Set("token", token)
		engine.ServeHTTP(rr, g.Request)

		var body map[string]interface{}
		err := json.Unmarshal(rr.Body.Bytes(), &body)
		assert.NoError(t, err)

		data, err := json.Marshal(body["data"].(map[string]interface{}))
		assert.NoError(t, err)

		assert.JSONEq(t, `{"errors":{"session":"expired"}}`, string(data))
		assert.Equal(t, "Session expired, please login again", body["message"])
		assert.Equal(t, 401, rr.Code)
		assert.Equal(t, &http.Cookie{
			Name:     "verbis-session",
			Value:    "",
			Path:     "/",
			Raw:      "verbis-session=; Path=/; Max-Age=0; HttpOnly",
			Domain:   "",
			MaxAge:   -1,
			Secure:   false,
			HttpOnly: true,
		}, rr.Result().Cookies()[0])
	})

	t.Run("Next", func(t *testing.T) {
		token := "tokenVal"
		mock := mocks.UserRepository{}
		mock.On("CheckSession", token).Return(nil)

		rr := httptest.NewRecorder()
		g, engine := gin.CreateTestContext(rr)
		engine.Use(SessionCheck(&mock))

		engine.GET("/test", func(context *gin.Context) {
			g.String(200, "verbis")
		})

		g.Request, _ = http.NewRequest("GET", "/test", nil)
		g.Request.Header.Set("token", token)
		engine.ServeHTTP(rr, g.Request)

		assert.Equal(t, "verbis", rr.Body.String())
		assert.Equal(t, 200, rr.Code)
	})
}"
}
{
file:./api/http/pagination_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package http

import (
	params2 "github.com/ainsleyclark/verbis/api/helpers/params"
	"github.com/stretchr/testify/assert"
	"testing"
)

// TestNewPagination - Test construct
func TestNewPagination(t *testing.T) {
	want := &Pagination{}
	got := NewPagination()
	assert.Equal(t, got, want)
}

// // TestPagination_Get - Test get Pagination
func TestPagination_Get(t *testing.T) {

	tt := map[string]struct {
		params params2.Params
		total  int
		want   *Pagination
	}{
		"Normal": {
			total:  10,
			params: params2.Params{Page: 1, Limit: 10, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 1, Pages: 1, Limit: 10, Total: 10, Next: false, Prev: false},
		},
		"Next": {
			total:  10,
			params: params2.Params{Page: 1, Limit: 5, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 1, Pages: 2, Limit: 5, Total: 10, Next: 2, Prev: false},
		},
		"Prev": {
			total:  10,
			params: params2.Params{Page: 2, Limit: 5, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 2, Pages: 2, Limit: 5, Total: 10, Next: false, Prev: 1},
		},
		"Prev & Next": {
			total:  100,
			params: params2.Params{Page: 5, Limit: 5, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 5, Pages: 20, Limit: 5, Total: 100, Next: 6, Prev: 4},
		},
		"Odd": {
			total:  600,
			params: params2.Params{Page: 99, Limit: 4, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 99, Pages: 150, Limit: 4, Total: 600, Next: 100, Prev: 98},
		},
		"Limit All": {
			total:  100,
			params: params2.Params{Page: 1, Limit: 0, LimitAll: true, OrderBy: "order", OrderDirection: "asc", Filters: nil},
			want:   &Pagination{Page: 1, Pages: 1, Limit: "all", Total: 100, Next: false, Prev: false},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			p := NewPagination()
			got := p.Get(test.params, test.total)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/http/csrf/csrf.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package csrf

import (
	"crypto/sha1"
	"encoding/base64"
	"errors"
	"fmt"
	"io"

	"github.com/dchest/uniuri"
	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
)

const (
	csrfSecret = "csrfSecret"
	csrfSalt   = "csrfSalt"
	csrfToken  = "csrfToken"
)

var defaultIgnoreMethods = []string{"GET", "HEAD", "OPTIONS"}

var defaultErrorFunc = func(c *gin.Context) {
	panic(errors.New("CSRF token mismatch"))
}

var defaultTokenGetter = func(c *gin.Context) string {
	r := c.Request

	if t := r.FormValue("_csrf"); len(t) > 0 {
		return t
	} else if t := r.URL.Query().Get("_csrf"); len(t) > 0 {
		return t
	} else if t := r.Header.Get("X-CSRF-TOKEN"); len(t) > 0 {
		return t
	} else if t := r.Header.Get("X-XSRF-TOKEN"); len(t) > 0 {
		return t
	}

	return ""
}

// Options stores configurations for a CSRF middleware.
type Options struct {
	Secret        string
	IgnoreMethods []string
	ErrorFunc     gin.HandlerFunc
	Routes        []string
	TokenGetter   func(c *gin.Context) string
}

func tokenize(secret, salt string) string {
	h := sha1.New()
	io.WriteString(h, salt+"-"+secret)
	hash := base64.URLEncoding.EncodeToString(h.Sum(nil))

	return hash
}

func inArray(arr []string, value string) bool {
	inarr := false

	for _, v := range arr {
		if v == value {
			inarr = true
			break
		}
	}

	return inarr
}

// Middleware validates CSRF token.
func Middleware(options Options) gin.HandlerFunc {
	ignoreMethods := options.IgnoreMethods
	errorFunc := options.ErrorFunc
	tokenGetter := options.TokenGetter

	if ignoreMethods == nil {
		ignoreMethods = defaultIgnoreMethods
	}

	if errorFunc == nil {
		errorFunc = defaultErrorFunc
	}

	if tokenGetter == nil {
		tokenGetter = defaultTokenGetter
	}

	return func(c *gin.Context) {
		session := sessions.Default(c)
		c.Set(csrfSecret, options.Secret)

		if inArray(ignoreMethods, c.Request.Method) {
			c.Next()
			return
		}

		fmt.Println(c.Request.URL)

		salt, ok := session.Get(csrfSalt).(string)

		if !ok || len(salt) == 0 {
			errorFunc(c)
			return
		}

		token := tokenGetter(c)

		if tokenize(options.Secret, salt) != token {
			errorFunc(c)
			return
		}

		c.Next()
	}
}

// GetToken returns a CSRF token.
func GetToken(c *gin.Context) string {
	session := sessions.Default(c)
	secret := c.MustGet(csrfSecret).(string)

	if t, ok := c.Get(csrfToken); ok {
		return t.(string)
	}

	salt, ok := session.Get(csrfSalt).(string)
	if !ok {
		salt = uniuri.New()
		session.Set(csrfSalt, salt)
		session.Save()
	}
	token := tokenize(secret, salt)
	c.Set(csrfToken, token)

	return token
}"
}
{
file:./api/http/csrf/csrf_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package csrf

import (
	"github.com/gin-contrib/sessions/cookie"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
)

func init() {
	gin.SetMode(gin.TestMode)
}

func newServer(options Options) *gin.Engine {
	g := gin.New()

	store := cookie.NewStore([]byte("secret123"))

	g.Use(sessions.Sessions("my_session", store))
	g.Use(Middleware(options))

	return g
}

type requestOptions struct {
	Method  string
	URL     string
	Headers map[string]string
	Body    io.Reader
}

func request(server *gin.Engine, options requestOptions) *httptest.ResponseRecorder {
	if options.Method == "" {
		options.Method = "GET"
	}

	w := httptest.NewRecorder()
	req, err := http.NewRequest(options.Method, options.URL, options.Body)

	if options.Headers != nil {
		for key, value := range options.Headers {
			req.Header.Set(key, value)
		}
	}

	server.ServeHTTP(w, req)

	if err != nil {
		panic(err)
	}

	return w
}

func TestForm(t *testing.T) {
	var token string
	g := newServer(Options{
		Secret: "secret123",
	})

	g.GET("/login", func(c *gin.Context) {
		token = GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie":       r1.Header().Get("Set-Cookie"),
			"Content-Type": "application/x-www-form-urlencoded",
		},
		Body: strings.NewReader("_csrf=" + token),
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}

func TestQueryString(t *testing.T) {
	var token string
	g := newServer(Options{
		Secret: "secret123",
	})

	g.GET("/login", func(c *gin.Context) {
		token = GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login?_csrf=" + token,
		Headers: map[string]string{
			"Cookie": r1.Header().Get("Set-Cookie"),
		},
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}

func TestQueryHeader1(t *testing.T) {
	var token string
	g := newServer(Options{
		Secret: "secret123",
	})

	g.GET("/login", func(c *gin.Context) {
		token = GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie":       r1.Header().Get("Set-Cookie"),
			"X-CSRF-Token": token,
		},
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}

func TestQueryHeader2(t *testing.T) {
	var token string
	g := newServer(Options{
		Secret: "secret123",
	})

	g.GET("/login", func(c *gin.Context) {
		token = GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie":       r1.Header().Get("Set-Cookie"),
			"X-XSRF-Token": token,
		},
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}

func TestErrorFunc(t *testing.T) {
	result := ""
	g := newServer(Options{
		Secret: "secret123",
		ErrorFunc: func(c *gin.Context) {
			result = "something wrong"
		},
	})

	g.GET("/login", func(c *gin.Context) {
		GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie": r1.Header().Get("Set-Cookie"),
		},
	})

	if result != "something wrong" {
		t.Error("Error function was not called")
	}
}

func TestIgnoreMethods(t *testing.T) {
	g := newServer(Options{
		Secret:        "secret123",
		IgnoreMethods: []string{"GET", "POST"},
	})

	g.GET("/login", func(c *gin.Context) {
		GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie": r1.Header().Get("Set-Cookie"),
		},
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}

func TestTokenGetter(t *testing.T) {
	var token string
	g := newServer(Options{
		Secret: "secret123",
		TokenGetter: func(c *gin.Context) string {
			return c.Request.FormValue("wtf")
		},
	})

	g.GET("/login", func(c *gin.Context) {
		token = GetToken(c)
	})

	g.POST("/login", func(c *gin.Context) {
		c.String(http.StatusOK, "OK")
	})

	r1 := request(g, requestOptions{URL: "/login"})
	r2 := request(g, requestOptions{
		Method: "POST",
		URL:    "/login",
		Headers: map[string]string{
			"Cookie":       r1.Header().Get("Set-Cookie"),
			"Content-Type": "application/x-www-form-urlencoded",
		},
		Body: strings.NewReader("wtf=" + token),
	})

	if body := r2.Body.String(); body != "OK" {
		t.Error("Response is not OK: ", body)
	}
}"
}
{
file:./api/http/pagination.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package http

import (
	"github.com/ainsleyclark/verbis/api/helpers/params"
	"math"
)

// Paginate defines the function for getting http params
type Paginate interface {
	Get() params.Params
}

// Pagination represents the data to be sent back from the API on
// get routes
type Pagination struct {
	Page  int         `json:"page"`
	Pages int         `json:"pages"`
	Limit interface{} `json:"limit"`
	Total int         `json:"total"`
	Next  interface{} `json:"next"`
	Prev  interface{} `json:"prev"`
}

// NewPagination - create a new pagination type
func NewPagination() *Pagination {
	return &Pagination{}
}

// Get pagination parameters
func (p *Pagination) Get(params params.Params, total int) *Pagination {

	// Calculate total pages
	var pages int
	pages = int(math.Ceil(float64(total) / float64(params.Limit)))

	// Set page to 1 if the user has passed "?limit=all"
	var limit interface{}
	if params.LimitAll {
		pages = 1
		limit = "all"
	} else {
		limit = params.Limit
	}

	// Construct pagination meta
	var pagination *Pagination
	pagination = &Pagination{
		Page:  params.Page,
		Pages: pages,
		Limit: limit,
		Total: total,
		Next:  false,
		Prev:  false,
	}

	// Calculate prev and next variables
	if params.Page < pages {
		pagination.Next = params.Page + 1
	}
	if params.Page > 1 {
		pagination.Prev = params.Page - 1
	}

	return pagination
}"
}
{
file:./api/environment/env.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package environment

import (
	"github.com/ainsleyclark/verbis/api/errors"
	validation "github.com/ainsleyclark/verbis/api/helpers/vaidation"
	pkgValidate "github.com/go-playground/validator/v10"
	"strconv"

	"github.com/joho/godotenv"
	"os"
	"path/filepath"
)

var env envMap

type envMap struct {
	AppName         string `json:"APP_NAME"`
	AppEnv          string `json:"APP_ENV"`
	AppDebug        string `json:"APP_DEBUG"`
	AppPort         string `json:"APP_PORT" binding:"required"`
	DbHost          string `json:"DB_HOST" binding:"required"`
	DbPort          string `json:"DB_PORT" binding:"required"`
	DbDatabase      string `json:"DB_DATABASE" binding:"required"`
	DbUser          string `json:"DB_USERNAME" binding:"required"`
	DbPassword      string `json:"DB_PASSWORD" binding:"required"`
	SparkpostApiKey string `json:"SPARKPOST_API_KEY"`
	SparkpostUrl    string `json:"SPARKPOST_URL"`
	MailFromAddress string `json:"MAIL_FROM_ADDRESS"`
	MailFromName    string `json:"MAIL_FROM_NAME"`
}

type Mail struct {
	SparkpostApiKey string `json:"SPARKPOST_API_KEY"`
	SparkpostUrl    string `json:"SPARKPOST_URL"`
	FromAddress     string `json:"MAIL_FROM_ADDRESS"`
	FromName        string `json:"MAIL_FROM_NAME"`
}

// Load populates environment, loads and validates the environment file.
// Returns errors.INVALID if the env file failed to load.
func Load() error {
	const op = "environment.Load"

	var (
		basePath, _ = filepath.Abs(filepath.Dir(os.Args[0]))
		envPath     = ".env"
	)

	if _, err := os.Stat(basePath + "/.env"); err == nil {
		envPath = basePath + "/.env"
	}

	if err := godotenv.Overload(envPath); err != nil {
		return &errors.Error{Code: errors.INVALID, Message: "Could not load the enviromnent file, is there a .env file in the root of the verbis project?", Operation: op, Err: err}
	}

	env = envMap{
		AppEnv:          os.Getenv("APP_ENV"),
		AppDebug:        os.Getenv("APP_DEBUG"),
		AppPort:         os.Getenv("APP_PORT"),
		DbHost:          os.Getenv("DB_HOST"),
		DbPort:          os.Getenv("DB_PORT"),
		DbDatabase:      os.Getenv("DB_DATABASE"),
		DbUser:          os.Getenv("DB_USERNAME"),
		DbPassword:      os.Getenv("DB_PASSWORD"),
		SparkpostApiKey: os.Getenv("SPARKPOST_API_KEY"),
		SparkpostUrl:    os.Getenv("SPARKPOST_URL"),
		MailFromAddress: os.Getenv("MAIL_FROM_ADDRESS"),
		MailFromName:    os.Getenv("MAIL_FROM_NAME"),
	}

	return nil
}

// Validate the environment file for missing keys
func Validate() []validation.ValidationError {
	v := validation.New()
	err := v.Package.Struct(env)
	if err != nil {
		validationErrors := err.(pkgValidate.ValidationErrors)
		return v.Process(validationErrors)
	}
	return nil
}

// App - GetAppName
func GetAppName() string {
	return env.AppName
}

// App - GetAppEv
func GetAppEnv() string {
	return env.AppEnv
}

// Database - GetPort
func GetPort() int {
	n, _ := strconv.Atoi(env.AppPort)
	return n
}

// Database - ConnectString
func ConnectString() string {
	return env.DbUser + ":" + env.DbPassword + "@tcp(" + env.DbHost + ":" + env.DbPort + ")/" + env.DbDatabase + "?tls=false&parseTime=true&multiStatements=true"
}

// Database - GetDatabaseName
func GetDatabaseName() string {
	return env.DbDatabase
}

// Mail - GetMailConfiguration
func GetMailConfiguration() Mail {
	return Mail{
		FromAddress:     env.MailFromAddress,
		FromName:        env.MailFromName,
		SparkpostApiKey: env.SparkpostApiKey,
		SparkpostUrl:    env.SparkpostUrl,
	}
}

// Env - IsProduction
func IsProduction() bool {
	return env.AppEnv == "production" || env.AppEnv == "prod"
}

// Env - IsDevelopment
func IsDevelopment() bool {
	return env.AppEnv != "production" && env.AppEnv != "prod"
}

// Env - IsDebug
func IsDebug() bool {
	return env.AppDebug != "false"
}"
}
{
file:./api/deps/deps.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package deps

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/tpl"
)

type Paths struct {
	Base    string
	Admin   string
	API     string
	Theme   string
	Uploads string
	Storage string
	Web     string
}

// Deps holds dependencies used by many.
// There will be normally only one instance of deps in play
// at a given time, i.e. one per Site built.
type Deps struct {

	// The database layer
	Store *models.Store

	// Configuration file of the site
	Config *config.Configuration

	// Cache

	Site domain.Site

	// Logger

	// Options
	Options *domain.Options

	// Paths
	Paths Paths

	// Theme
	Theme *domain.ThemeConfig

	tmpl tpl.TemplateHandler

	Running bool
}

func (d *Deps) Tmpl() tpl.TemplateHandler {
	return d.tmpl
}

func (d *Deps) SetTmpl(tmpl tpl.TemplateHandler) {
	d.tmpl = tmpl
}

func (d *Deps) SetOptions(options *domain.Options) {
	d.Options = options
}

type DepsConfig struct {

	// The database layer
	Store *models.Store

	// Config
	Config *config.Configuration

	Running bool
}

func New(cfg DepsConfig) *Deps {

	if cfg.Store == nil {
		panic("Must have a store")
	}

	if cfg.Config == nil {
		panic("Must have a configuration")
	}

	opts := cfg.Store.Options.GetStruct()

	theme := cfg.Store.Site.GetThemeConfig()

	d := &Deps{
		Store:   cfg.Store,
		Config:  cfg.Config,
		Site:    cfg.Store.Site.GetGlobalConfig(),
		Options: &opts,
		Paths: Paths{
			Base:    paths.Base(),
			Admin:   paths.Admin(),
			API:     paths.Api(),
			Theme:   paths.Theme(),
			Uploads: paths.Uploads(),
			Storage: paths.Storage(),
			Web:     paths.Web(),
		},
		Theme:   &theme,
		tmpl:    nil,
		Running: cfg.Running,
	}

	return d
}"
}
{
file:./api/fields/fields.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/fields/resolve"
	"strings"
)

// Fields defines the map of fields to be returned to the template.
type Fields map[string]interface{}

// GetFields
//
// Returns all of the fields for the current post, or post ID given.
func (s *Service) GetFields(args ...interface{}) Fields {
	fields := s.handleArgs(args)

	var f = make(Fields, 0)
	s.mapper(fields, func(field domain.PostField) {
		f[field.Name] = resolve.Field(field, s.deps).Value
	})

	return f
}

// WalkerFunc defines the function for walking the slice of domain.PostField
// when being mapped. It send the field back to the calling function for
// processing.
type WalkerFunc func(field domain.PostField)

// mapper
//
// Ranges over the fields and resolves all of the values from the given
// slice. If the field has a parent of field layout, the field will
// be skipped.
func (s *Service) mapper(fields []domain.PostField, walkerFunc WalkerFunc) {
	for _, field := range fields {

		if field.Type == "repeater" {
			repeater := s.GetRepeater(field.Name)
			if repeater != nil {
				field.Value = repeater
				walkerFunc(field)
			}
			continue
		}

		if field.Type == "flexible" {
			flexible := s.GetFlexible(field.Name)
			if flexible != nil {
				field.Value = flexible
				walkerFunc(field)
			}
			continue
		}

		if field.Key == "" || len(strings.Split(field.Key, SEPARATOR)) == 0 {
			walkerFunc(field)
		}
	}
}"
}
{
file:./api/fields/service.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
)

// FieldService defines methods for obtaining fields for the front end templates
type FieldService interface {
	GetField(name string, args ...interface{}) interface{}
	GetFieldObject(name string, args ...interface{}) domain.PostField
	GetFields(args ...interface{}) Fields
	GetLayout(name string, args ...interface{}) domain.Field
	GetLayouts(args ...interface{}) []domain.FieldGroup
	GetRepeater(input interface{}, args ...interface{}) Repeater
	GetFlexible(input interface{}, args ...interface{}) Flexible
}

const (
	// The separator that defines the split between field
	// keys for repeaters and flexible content.
	SEPARATOR = "|"
)

// Service
//
// Defines the helper for obtaining fields for front end templates.
type Service struct {
	// Used for obtaining categories, media items, posts and
	// users from the database when resolving fields.
	deps *deps.Deps
	// The original post to sort and filter the fields
	post domain.PostData
	// The original post ID.
	postId int
	// The slice of domain.PostField to create repeaters,
	// flexible content and resolving normal fields.
	fields []domain.PostField
	// The slice of domain.FieldGroup to iterate over
	// groups and layouts.
	layout []domain.FieldGroup
}

// NewService - Construct
func NewService(d *deps.Deps, p *domain.PostData) *Service {
	fields := make([]domain.PostField, 0)
	if p.Fields != nil {
		fields = p.Fields
	}

	layouts := make([]domain.FieldGroup, 0)
	if p.Layout != nil {
		layouts = p.Layout
	}

	return &Service{
		deps:   d,
		postId: p.Id,
		fields: fields,
		layout: layouts,
	}
}"
}
{
file:./api/fields/field.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/fields/resolve"
	log "github.com/sirupsen/logrus"
)

// GetField
//
// Returns the value of a specific field.
// Returns errors.NOTFOUND if the field was not found by the given key.
func (s *Service) GetField(name string, args ...interface{}) interface{} {
	fields := s.handleArgs(args)

	field, err := s.findFieldByName(name, fields)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return nil
	}

	resolved := resolve.Field(field, s.deps)

	return resolved.Value
}

// GetFieldObject
//
// Returns the raw object of a specific field.
// Returns errors.NOTFOUND if the field was not found by the given key.
func (s *Service) GetFieldObject(name string, args ...interface{}) domain.PostField {
	fields := s.handleArgs(args)

	field, err := s.findFieldByName(name, fields)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return domain.PostField{}
	}

	resolved := resolve.Field(field, s.deps)

	return resolved
}"
}
{
file:./api/fields/resolve/resolve.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	log "github.com/sirupsen/logrus"
)

// Value defines the methods used for resolving
// domain.FieldValue's. The store is required
// for use with DB calls such as Posts.
type Value struct {
	deps *deps.Deps
}

var (
	// Iterable defines the types that can be a slice,
	// by a comma delimited Original Value (1,2,3).
	Iterable = []string{
		"category",
		"image",
		"post",
		"user",
		"tags",
	}
	// Choice defines the types that can be transformed
	// into a `choice` struct.
	Choice = []string{
		"button_group",
		"radio",
		"select",
	}
)

// valuer defines the function for resolving domain.FieldValue's
type valuer func(field domain.FieldValue) (interface{}, error)

// valueMap represents a map of field types with a valuer used
// to resolve field values.
type valueMap map[string]valuer

// Field
//
// Resolve's a field value.
func Field(field domain.PostField, d *deps.Deps) domain.PostField {
	exec := &Value{
		deps: d,
	}
	resolved := exec.resolve(field)
	return resolved
}

// getMap
//
// Returns the map of functions for resolving values.
func (v *Value) getMap() valueMap {
	return valueMap{
		"button_group": v.choice,
		"category":     v.category,
		"checkbox":     v.checkbox,
		"image":        v.media,
		"number":       v.number,
		"post":         v.post,
		"radio":        v.choice,
		"range":        v.number,
		"select":       v.choice,
		"user":         v.user,
	}
}

// resolve
//
// This function is the core for resolving the fields value
// for use with templates. It determines if the given
// field values is a slice or array or singular and
// returns a resolved field value or a slice of
// interfaces.
func (v *Value) resolve(field domain.PostField) domain.PostField {
	original := field.OriginalValue

	if original.IsEmpty() {
		field.Value = field.OriginalValue.String()
		return field
	}

	if field.TypeIsInArray(Choice) && field.Key != "map" {
		field.Value = field.OriginalValue.String()
		return field
	}

	if !field.TypeIsInArray(Iterable) {
		field.Value = v.execute(field.OriginalValue.String(), field.Type)
		return field
	}

	var items []interface{}
	for _, f := range original.Array() {
		res := v.execute(f, field.Type)
		if res != nil {
			items = append(items, res)
		}
	}
	field.Value = items

	if len(items) == 1 {
		field.Value = items[0]
	}

	return field
}

// execute
//
// Executes the function based on the fields type.
// If the function is not within the valueMap,
// the original value will be returned.
func (v *Value) execute(value string, typ string) interface{} {
	fn, ok := v.getMap()[typ]
	if !ok {
		return value
	}

	val, err := fn(domain.FieldValue(value))
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
	}

	return val
}"
}
{
file:./api/fields/resolve/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
)

// media
//
// Resolves a media from the given value.
// Returns the domain.Media if it was found and no error occurred.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an integer.
func (v *Value) media(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.media"

	id, err := value.Int()
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast user ID to an integer", Operation: op, Err: err}
	}

	media, err := v.deps.Store.Media.GetById(id)
	if err != nil {
		return nil, err
	}

	return media, nil
}"
}
{
file:./api/fields/resolve/user.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
)

// user
//
// Resolves a user from the given value.
// Returns the domain.User if it was found and no error occurred.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an integer.
func (v *Value) user(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.user"

	id, err := value.Int()
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast user ID to an integer", Operation: op, Err: err}
	}

	user, err := v.deps.Store.User.GetById(id)
	if err != nil {
		return nil, err
	}

	return user.HideCredentials(), nil
}"
}
{
file:./api/fields/resolve/user_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *ResolverTestSuite) TestValue_User() {

	tt := map[string]struct {
		value domain.FieldValue
		mock  func(u *mocks.UserRepository)
		want  interface{}
	}{
		"User": {
			value: domain.FieldValue("1"),
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 1).Return(domain.User{
					UserPart: domain.UserPart{FirstName: "user"},
				}, nil)
			},
			want: domain.UserPart{FirstName: "user"},
		},
		"User Error": {
			value: domain.FieldValue("1"),
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 1).Return(domain.User{}, fmt.Errorf("not found"))
			},
			want: "not found",
		},
		"Cast Error": {
			value: domain.FieldValue("wrongval"),
			mock:  func(u *mocks.UserRepository) {},
			want:  `strconv.Atoi: parsing "wrongval": invalid syntax`,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			userMock := &mocks.UserRepository{}

			test.mock(userMock)
			v.deps.Store.User = userMock

			got, err := v.user(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_UserResolve() {

	tt := map[string]struct {
		field domain.PostField
		mock  func(u *mocks.UserRepository)
		want  interface{}
	}{
		"Success": {
			field: domain.PostField{OriginalValue: "1,2,3", Type: "user"},
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 1).Return(domain.User{UserPart: domain.UserPart{FirstName: "user1"}}, nil)
				u.On("GetById", 2).Return(domain.User{UserPart: domain.UserPart{FirstName: "user2"}}, nil)
				u.On("GetById", 3).Return(domain.User{UserPart: domain.UserPart{FirstName: "user3"}}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3", Type: "user", Value: []interface{}{
				domain.UserPart{FirstName: "user1"},
				domain.UserPart{FirstName: "user2"},
				domain.UserPart{FirstName: "user3"},
			}},
		},
		"Trailing Comma": {
			field: domain.PostField{OriginalValue: "1,2,3,", Type: "user"},
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 1).Return(domain.User{UserPart: domain.UserPart{FirstName: "user1"}}, nil)
				u.On("GetById", 2).Return(domain.User{UserPart: domain.UserPart{FirstName: "user2"}}, nil)
				u.On("GetById", 3).Return(domain.User{UserPart: domain.UserPart{FirstName: "user3"}}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3,", Type: "user", Value: []interface{}{
				domain.UserPart{FirstName: "user1"},
				domain.UserPart{FirstName: "user2"},
				domain.UserPart{FirstName: "user3"},
			}},
		},
		"Leading Comma": {
			field: domain.PostField{OriginalValue: ",1,2,3", Type: "user"},
			mock: func(u *mocks.UserRepository) {
				u.On("GetById", 1).Return(domain.User{UserPart: domain.UserPart{FirstName: "user1"}}, nil)
				u.On("GetById", 2).Return(domain.User{UserPart: domain.UserPart{FirstName: "user2"}}, nil)
				u.On("GetById", 3).Return(domain.User{UserPart: domain.UserPart{FirstName: "user3"}}, nil)
			},
			want: domain.PostField{OriginalValue: ",1,2,3", Type: "user", Value: []interface{}{
				domain.UserPart{FirstName: "user1"},
				domain.UserPart{FirstName: "user2"},
				domain.UserPart{FirstName: "user3"},
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			userMock := &mocks.UserRepository{}

			test.mock(userMock)
			v.deps.Store.User = userMock

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/tags.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

// tags defines the the array of values that are held
// in the `tags` field type.
type tags []string

// tags
//
// Uses the Array() function on the domain.FieldValue type to split
// the value by a comma delimiter, and loops over the values to
// build up a tags array to be sent back.
func (v *Value) tags(value domain.FieldValue) (interface{}, error) {
	var t tags
	for _, v := range value.Array() {
		if v != "" {
			t = append(t, v)
		}
	}
	return t, nil
}"
}
{
file:./api/fields/resolve/post.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
)

// post
//
// Resolves a post from the given value.
// Returns the domain.PostData if it was found and no error occurred.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an integer.
func (v *Value) post(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.post"

	id, err := value.Int()
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast post ID to an integer", Operation: op, Err: err}
	}

	post, err := v.deps.Store.Posts.GetById(id, false)
	if err != nil {
		return nil, err
	}

	return post, nil
}"
}
{
file:./api/fields/resolve/choice.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
)

// choice defines the properties to be sent to the template
// if the return format is set as a 'map' for choice
// fields (select, radio group etc).
type choice struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// choice
//
// Unmarshalls the domain.FieldValue into a choice type.
// Returns errors.INVALID if the unmarshal was not successful.
func (v *Value) choice(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.choice"

	var c choice
	err := json.Unmarshal([]byte(value), &c)
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("Unable to unmarshal to choice map"), Operation: op, Err: err}
	}

	return c, nil
}"
}
{
file:./api/fields/resolve/number.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/spf13/cast"
)

// number
//
// Casts the domain.FieldValue to int64.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an int64.
func (v *Value) number(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.number"

	number, err := cast.ToInt64E(value.String())
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast field to an integer", Operation: op, Err: err}
	}

	return number, nil
}"
}
{
file:./api/fields/resolve/tags_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import "github.com/ainsleyclark/verbis/api/domain"

func (t *ResolverTestSuite) TestValue_Tags() {

	tt := map[string]struct {
		value domain.FieldValue
		want  tags
	}{
		"Success": {
			value: "1,2,3,4,5",
			want:  tags{"1", "2", "3", "4", "5"},
		},
		"Single": {
			value: "1",
			want:  tags{"1"},
		},
		"Trailing Comma": {
			value: "1,2,3,4,5,",
			want:  tags{"1", "2", "3", "4", "5"},
		},
		"Leading Commas": {
			value: ",1,2,3,4,5",
			want:  tags{"1", "2", "3", "4", "5"},
		},
		"Commas Everywhere": {
			value: ",,,,1,,,,2,,3,,4,,,,5,,,,,",
			want:  tags{"1", "2", "3", "4", "5"},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got, err := v.tags(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_TagsResolve() {

	tt := map[string]struct {
		field domain.PostField
		want  domain.PostField
	}{
		"Tags": {
			field: domain.PostField{OriginalValue: "1,2,3", Type: "tags"},
			want:  domain.PostField{OriginalValue: "1,2,3", Type: "tags", Value: []interface{}{"1", "2", "3"}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/choice_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import "github.com/ainsleyclark/verbis/api/domain"

func (t *ResolverTestSuite) TestValue_Choice() {

	tt := map[string]struct {
		value domain.FieldValue
		want  interface{}
	}{
		"Success": {
			value: domain.FieldValue(`{"key": "key1", "value": "value1"}`),
			want: choice{
				Key:   "key1",
				Value: "value1",
			},
		},
		"Empty": {
			value: `{}`,
			want:  choice{},
		},
		"Failed": {
			value: `wrongval`,
			want:  "invalid character",
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got, err := v.choice(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_ChoiceResolve() {

	tt := map[string]struct {
		field domain.PostField
		want  domain.PostField
	}{
		"Button Group Value": {
			field: domain.PostField{OriginalValue: "test", Key: "value", Type: "button_group"},
			want:  domain.PostField{OriginalValue: "test", Key: "value", Type: "button_group", Value: "test"},
		},
		"Button Group Key": {
			field: domain.PostField{OriginalValue: "test", Key: "key", Type: "button_group"},
			want:  domain.PostField{OriginalValue: "test", Key: "key", Type: "button_group", Value: "test"},
		},
		"Button Group Map": {
			field: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "button_group"},
			want: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "button_group", Value: choice{
				Key:   "key1",
				Value: "value1",
			}},
		},
		"Radio Value": {
			field: domain.PostField{OriginalValue: "test", Key: "value", Type: "radio"},
			want:  domain.PostField{OriginalValue: "test", Key: "value", Type: "radio", Value: "test"},
		},
		"Radio Key": {
			field: domain.PostField{OriginalValue: "test", Key: "key", Type: "radio"},
			want:  domain.PostField{OriginalValue: "test", Key: "key", Type: "radio", Value: "test"},
		},
		"Radio Map": {
			field: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "radio"},
			want: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "radio", Value: choice{
				Key:   "key1",
				Value: "value1",
			}},
		},
		"Select Value": {
			field: domain.PostField{OriginalValue: "test", Key: "value", Type: "select"},
			want:  domain.PostField{OriginalValue: "test", Key: "value", Type: "select", Value: "test"},
		},
		"Select Key": {
			field: domain.PostField{OriginalValue: "test", Key: "key", Type: "select"},
			want:  domain.PostField{OriginalValue: "test", Key: "key", Type: "select", Value: "test"},
		},
		"Select Map": {
			field: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "select"},
			want: domain.PostField{OriginalValue: `{"key": "key1", "value": "value1"}`, Key: "map", Type: "select", Value: choice{
				Key:   "key1",
				Value: "value1",
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/bool.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/spf13/cast"
)

// checkbox
//
// Casts the domain.FieldValue to a boolean.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an bool.
func (v *Value) checkbox(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.checkbox"

	check, err := cast.ToBoolE(value.String())
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast checkbox field to an bool", Operation: op, Err: err}
	}

	return check, nil
}"
}
{
file:./api/fields/resolve/bool_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import "github.com/ainsleyclark/verbis/api/domain"

func (t *ResolverTestSuite) TestValue_Checkbox() {

	tt := map[string]struct {
		value domain.FieldValue
		want  interface{}
	}{
		"True": {
			value: domain.FieldValue("true"),
			want:  true,
		},
		"False": {
			value: domain.FieldValue("false"),
			want:  false,
		},
		"Failed": {
			value: `wrongval`,
			want:  "invalid syntax",
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got, err := v.checkbox(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/post_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *ResolverTestSuite) TestValue_Post() {

	tt := map[string]struct {
		value domain.FieldValue
		mock  func(p *mocks.PostsRepository)
		want  interface{}
	}{
		"Post": {
			value: domain.FieldValue("1"),
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, false).Return(domain.PostData{Post: domain.Post{Title: "post"}}, nil)
			},
			want: domain.PostData{
				Post: domain.Post{Title: "post"},
			},
		},
		"Post Error": {
			value: domain.FieldValue("1"),
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, false).Return(domain.PostData{}, fmt.Errorf("not found"))
			},
			want: "not found",
		},
		"Cast Error": {
			value: domain.FieldValue("wrongval"),
			mock:  func(p *mocks.PostsRepository) {},
			want:  `strconv.Atoi: parsing "wrongval": invalid syntax`,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			postMock := &mocks.PostsRepository{}

			test.mock(postMock)
			v.deps.Store.Posts = postMock

			got, err := v.post(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_PostResolve() {

	tt := map[string]struct {
		field domain.PostField
		mock  func(p *mocks.PostsRepository)
		want  domain.PostField
	}{
		"Post": {
			field: domain.PostField{OriginalValue: "1,2,3", Type: "post"},
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, false).Return(domain.PostData{Post: domain.Post{Title: "post1"}}, nil)
				p.On("GetById", 2, false).Return(domain.PostData{Post: domain.Post{Title: "post2"}}, nil)
				p.On("GetById", 3, false).Return(domain.PostData{Post: domain.Post{Title: "post3"}}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3", Type: "post", Value: []interface{}{
				domain.PostData{Post: domain.Post{Title: "post1"}},
				domain.PostData{Post: domain.Post{Title: "post2"}},
				domain.PostData{Post: domain.Post{Title: "post3"}},
			}},
		},
		"Trailing Comma": {
			field: domain.PostField{OriginalValue: "1,2,3,", Type: "post"},
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, false).Return(domain.PostData{Post: domain.Post{Title: "post1"}}, nil)
				p.On("GetById", 2, false).Return(domain.PostData{Post: domain.Post{Title: "post2"}}, nil)
				p.On("GetById", 3, false).Return(domain.PostData{Post: domain.Post{Title: "post3"}}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3,", Type: "post", Value: []interface{}{
				domain.PostData{Post: domain.Post{Title: "post1"}},
				domain.PostData{Post: domain.Post{Title: "post2"}},
				domain.PostData{Post: domain.Post{Title: "post3"}},
			}},
		},
		"Leading Comma": {
			field: domain.PostField{OriginalValue: ",1,2,3", Type: "post"},
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, false).Return(domain.PostData{Post: domain.Post{Title: "post1"}}, nil)
				p.On("GetById", 2, false).Return(domain.PostData{Post: domain.Post{Title: "post2"}}, nil)
				p.On("GetById", 3, false).Return(domain.PostData{Post: domain.Post{Title: "post3"}}, nil)
			},
			want: domain.PostField{OriginalValue: ",1,2,3", Type: "post", Value: []interface{}{
				domain.PostData{Post: domain.Post{Title: "post1"}},
				domain.PostData{Post: domain.Post{Title: "post2"}},
				domain.PostData{Post: domain.Post{Title: "post3"}},
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			postMock := &mocks.PostsRepository{}

			test.mock(postMock)
			v.deps.Store.Posts = postMock

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/resolve_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
)

func (t *ResolverTestSuite) Test_Field() {
	deps := &deps.Deps{}
	field := domain.PostField{Id: 1, Type: "text", OriginalValue: "test"}

	got := Field(field, deps)

	t.Equal(domain.PostField{Id: 1, Type: "text", OriginalValue: "test", Value: "test"}, got)
}

func (t *ResolverTestSuite) TestValue_Resolve() {

	tt := map[string]struct {
		field domain.PostField
		want  domain.PostField
	}{
		"Empty": {
			field: domain.PostField{OriginalValue: ""},
			want:  domain.PostField{OriginalValue: "", Value: ""},
		},
		"Not Iterable": {
			field: domain.PostField{OriginalValue: "999", Type: "number"},
			want:  domain.PostField{OriginalValue: "999", Type: "number", Value: int64(999)},
		},
		"Iterable": {
			field: domain.PostField{OriginalValue: "1,2,3,4,5", Type: "tags"},
			want:  domain.PostField{OriginalValue: "1,2,3,4,5", Type: "tags", Value: []interface{}{"1", "2", "3", "4", "5"}},
		},
		"Length of One": {
			field: domain.PostField{OriginalValue: "1", Type: "tags"},
			want:  domain.PostField{OriginalValue: "1", Type: "tags", Value: "1"},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetValue().resolve(test.field))
		})
	}
}

func (t *ResolverTestSuite) TestValue_Execute() {

	tt := map[string]struct {
		value string
		typ   string
		want  interface{}
	}{
		"Not found": {
			value: "test",
			typ:   "wrongval",
			want:  "test",
		},
		"Found": {
			value: "999",
			typ:   "number",
			want:  int64(999),
		},
		"Error": {
			value: "wrongval",
			typ:   "number",
			want:  nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetValue().execute(test.value, test.typ))
		})
	}
}"
}
{
file:./api/fields/resolve/number_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import "github.com/ainsleyclark/verbis/api/domain"

func (t *ResolverTestSuite) TestValue_Number() {

	tt := map[string]struct {
		value domain.FieldValue
		want  interface{}
	}{
		"Success": {
			value: "1",
			want:  int64(1),
		},
		"Large": {
			value: "99999999999999999",
			want:  int64(99999999999999999),
		},
		"Bad Cast": {
			value: "wrongval",
			want:  "unable to cast",
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got, err := v.number(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_NumberResolve() {

	tt := map[string]struct {
		field domain.PostField
		want  domain.PostField
	}{
		"Number": {
			field: domain.PostField{OriginalValue: "999", Type: "number"},
			want:  domain.PostField{OriginalValue: "999", Type: "number", Value: int64(999)},
		},
		"Range": {
			field: domain.PostField{OriginalValue: "999", Type: "range"},
			want:  domain.PostField{OriginalValue: "999", Type: "range", Value: int64(999)},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/category.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
)

// category
//
// Resolves a category from the given value.
// Returns the domain.Category if it was found and no error occurred.
// Returns errors.INVALID if the domain.FieldValue could not be cast to an integer.
func (v *Value) category(value domain.FieldValue) (interface{}, error) {
	const op = "FieldResolver.category"

	id, err := value.Int()
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: "Unable to cast category ID to an integer", Operation: op, Err: err}
	}

	category, err := v.deps.Store.Categories.GetById(id)
	if err != nil {
		return nil, err
	}

	return category, nil
}"
}
{
file:./api/fields/resolve/media_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *ResolverTestSuite) TestValue_Media() {

	tt := map[string]struct {
		value domain.FieldValue
		mock  func(m *mocks.MediaRepository)
		want  interface{}
	}{
		"Media": {
			value: domain.FieldValue("1"),
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{Url: "image"}, nil)
			},
			want: domain.Media{Url: "image"},
		},
		"Media Error": {
			value: domain.FieldValue("1"),
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{}, fmt.Errorf("not found"))
			},
			want: "not found",
		},
		"Cast Error": {
			value: domain.FieldValue("wrongval"),
			mock:  func(m *mocks.MediaRepository) {},
			want:  `strconv.Atoi: parsing "wrongval": invalid syntax`,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			mediaMock := &mocks.MediaRepository{}

			test.mock(mediaMock)
			v.deps.Store.Media = mediaMock

			got, err := v.media(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_MediaResolve() {

	tt := map[string]struct {
		field domain.PostField
		mock  func(m *mocks.MediaRepository)
		want  interface{}
	}{
		"Success": {
			field: domain.PostField{OriginalValue: "1,2,3", Type: "image"},
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{Url: "image1"}, nil)
				m.On("GetById", 2).Return(domain.Media{Url: "image2"}, nil)
				m.On("GetById", 3).Return(domain.Media{Url: "image3"}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3", Type: "image", Value: []interface{}{
				domain.Media{Url: "image1"},
				domain.Media{Url: "image2"},
				domain.Media{Url: "image3"},
			}},
		},
		"Trailing Comma": {
			field: domain.PostField{OriginalValue: "1,2,3,", Type: "image"},
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{Url: "image1"}, nil)
				m.On("GetById", 2).Return(domain.Media{Url: "image2"}, nil)
				m.On("GetById", 3).Return(domain.Media{Url: "image3"}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3,", Type: "image", Value: []interface{}{
				domain.Media{Url: "image1"},
				domain.Media{Url: "image2"},
				domain.Media{Url: "image3"},
			}},
		},
		"Leading Comma": {
			field: domain.PostField{OriginalValue: ",1,2,3", Type: "image"},
			mock: func(m *mocks.MediaRepository) {
				m.On("GetById", 1).Return(domain.Media{Url: "image1"}, nil)
				m.On("GetById", 2).Return(domain.Media{Url: "image2"}, nil)
				m.On("GetById", 3).Return(domain.Media{Url: "image3"}, nil)
			},
			want: domain.PostField{OriginalValue: ",1,2,3", Type: "image", Value: []interface{}{
				domain.Media{Url: "image1"},
				domain.Media{Url: "image2"},
				domain.Media{Url: "image3"},
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			mediaMock := &mocks.MediaRepository{}

			test.mock(mediaMock)
			v.deps.Store.Media = mediaMock

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/category_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *ResolverTestSuite) TestValue_Category() {

	tt := map[string]struct {
		value domain.FieldValue
		mock  func(c *mocks.CategoryRepository)
		want  interface{}
	}{
		"Category": {
			value: domain.FieldValue("1"),
			mock: func(c *mocks.CategoryRepository) {
				c.On("GetById", 1).Return(domain.Category{Name: "cat"}, nil)
			},
			want: domain.Category{Name: "cat"},
		},
		"Category Error": {
			value: domain.FieldValue("1"),
			mock: func(c *mocks.CategoryRepository) {
				c.On("GetById", 1).Return(domain.Category{}, fmt.Errorf("not found"))
			},
			want: "not found",
		},
		"Cast Error": {
			value: domain.FieldValue("wrongval"),
			mock:  func(c *mocks.CategoryRepository) {},
			want:  `strconv.Atoi: parsing "wrongval": invalid syntax`,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			categoryMock := &mocks.CategoryRepository{}

			test.mock(categoryMock)
			v.deps.Store.Categories = categoryMock

			got, err := v.category(test.value)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *ResolverTestSuite) TestValue_CategoryResolve() {

	tt := map[string]struct {
		field domain.PostField
		mock  func(c *mocks.CategoryRepository)
		want  domain.PostField
	}{
		"Success": {
			field: domain.PostField{OriginalValue: "1,2,3", Type: "category"},
			mock: func(c *mocks.CategoryRepository) {
				c.On("GetById", 1).Return(domain.Category{Name: "cat1"}, nil)
				c.On("GetById", 2).Return(domain.Category{Name: "cat2"}, nil)
				c.On("GetById", 3).Return(domain.Category{Name: "cat3"}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3", Type: "category", Value: []interface{}{
				domain.Category{Name: "cat1"},
				domain.Category{Name: "cat2"},
				domain.Category{Name: "cat3"},
			}},
		},
		"Trailing Comma": {
			field: domain.PostField{OriginalValue: "1,2,3,", Type: "category"},
			mock: func(c *mocks.CategoryRepository) {
				c.On("GetById", 1).Return(domain.Category{Name: "cat1"}, nil)
				c.On("GetById", 2).Return(domain.Category{Name: "cat2"}, nil)
				c.On("GetById", 3).Return(domain.Category{Name: "cat3"}, nil)
			},
			want: domain.PostField{OriginalValue: "1,2,3,", Type: "category", Value: []interface{}{
				domain.Category{Name: "cat1"},
				domain.Category{Name: "cat2"},
				domain.Category{Name: "cat3"},
			}},
		},
		"Leading Comma": {
			field: domain.PostField{OriginalValue: ",1,2,3", Type: "category"},
			mock: func(c *mocks.CategoryRepository) {
				c.On("GetById", 1).Return(domain.Category{Name: "cat1"}, nil)
				c.On("GetById", 2).Return(domain.Category{Name: "cat2"}, nil)
				c.On("GetById", 3).Return(domain.Category{Name: "cat3"}, nil)
			},
			want: domain.PostField{OriginalValue: ",1,2,3", Type: "category", Value: []interface{}{
				domain.Category{Name: "cat1"},
				domain.Category{Name: "cat2"},
				domain.Category{Name: "cat3"},
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			v := t.GetValue()
			categoryMock := &mocks.CategoryRepository{}

			test.mock(categoryMock)
			v.deps.Store.Categories = categoryMock

			got := v.resolve(test.field)

			t.Equal(test.want, got)
		})
	}
}"
}
{
file:./api/fields/resolve/suite_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package resolve

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/logger"
	"github.com/ainsleyclark/verbis/api/models"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/suite"
	"io/ioutil"
	"testing"
)

type ResolverTestSuite struct {
	suite.Suite
}

type noStringer struct{}

func TestResolver(t *testing.T) {
	suite.Run(t, new(ResolverTestSuite))
}

func (t *ResolverTestSuite) BeforeTest(suiteName, testName string) {
	err := logger.Init(config.Configuration{})
	log.SetOutput(ioutil.Discard)
	t.NoError(err)
}

func (t *ResolverTestSuite) GetValue() *Value {
	return &Value{
		&deps.Deps{
			Store:   &models.Store{},
		},
	}
}"
}
{
file:./api/fields/converter/location_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package location

import (
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/logger"
	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"
)

type LocationTestSuite struct {
	suite.Suite
	Path string
}

func TestLocation(t *testing.T) {
	suite.Run(t, new(LocationTestSuite))
}

func (t *LocationTestSuite) BeforeTest(suiteName, testName string) {
	cache.Init()

	err := logger.Init(config.Configuration{})
	log.SetOutput(ioutil.Discard)
	t.NoError(err)

	wd, err := os.Getwd()
	t.NoError(err)
	t.Path = filepath.Join(filepath.Dir(wd)+"./..") + "/test/testdata/fields"
}

func TestNewLocation(t *testing.T) {
	oldStoragePath := storagePath
	defer func() {
		storagePath = oldStoragePath
	}()
	storagePath = "test"

	assert.Equal(t, &Location{JsonPath: "test/fields"}, NewLocation())
}

func (t *LocationTestSuite) TestLocation_GetLayout() {

	tt := map[string]struct {
		cacheable bool
		jsonPath  string
		want      interface{}
	}{
		"Bad Path": {
			cacheable: false,
			jsonPath:  "wrongval",
			want:      []domain.FieldGroup{},
		},
		"Not Cached": {
			cacheable: false,
			jsonPath:  "/test-get-layout",
			want:      []domain.FieldGroup{{Title: "title", Fields: []domain.Field{{Name: "test"}}}},
		},
		"Cacheable Nil": {
			cacheable: true,
			jsonPath:  "/test-get-layout",
			want:      []domain.FieldGroup{{Title: "title", Fields: []domain.Field{{Name: "test"}}}},
		},
		"Cacheable": {
			cacheable: true,
			jsonPath:  "/test-get-layout",
			want:      []domain.FieldGroup{{Title: "title", Fields: []domain.Field{{Name: "test"}}}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			l := &Location{JsonPath: t.Path + test.jsonPath}
			t.Equal(test.want, l.GetLayout(domain.PostData{}, test.cacheable))
		})
	}
}

func (t *LocationTestSuite) TestLocation_GroupResolver() {

	r := "resource"
	uu := uuid.New()

	tt := map[string]struct {
		post   domain.PostData
		groups []domain.FieldGroup
		want   interface{}
	}{
		"None": {
			want: []domain.FieldGroup{},
		},
		"Already Added": {
			post: domain.PostData{Post: domain.Post{Id: 1, Title: "title", Status: "published"}},
			groups: []domain.FieldGroup{
				{Title: "status", UUID: uu},
				{Title: "status", UUID: uu},
			},
			want: []domain.FieldGroup{{Title: "status", UUID: uu}},
		},
		"Status": {
			post: domain.PostData{Post: domain.Post{Id: 1, Title: "title", Status: "published"}},
			groups: []domain.FieldGroup{
				{
					Title: "status",
					Locations: [][]domain.FieldLocation{
						{{Param: "status", Operator: "==", Value: "published"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "status"}},
		},
		"Post": {
			post: domain.PostData{Post: domain.Post{Id: 1}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "post", Operator: "==", Value: "1"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "post"}},
		},
		"Page Template": {
			post: domain.PostData{Post: domain.Post{PageTemplate: "template"}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "page_template", Operator: "==", Value: "template"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "post"}},
		},
		"Layout": {
			post: domain.PostData{Post: domain.Post{PageLayout: "layout"}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "page_layout", Operator: "==", Value: "layout"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "post"}},
		},
		"Resource": {
			post: domain.PostData{Post: domain.Post{Resource: &r}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "resource", Operator: "==", Value: r}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "post"}},
		},
		"Nil Resource": {
			post: domain.PostData{Post: domain.Post{Resource: nil}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "resource", Operator: "==", Value: "false"}},
					},
				},
			},
			want: []domain.FieldGroup{},
		},
		"Category": {
			post: domain.PostData{Category: &domain.Category{Id: 1}},
			groups: []domain.FieldGroup{
				{
					Title: "category",
					Locations: [][]domain.FieldLocation{
						{{Param: "category", Operator: "==", Value: "1"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "category"}},
		},
		"Nil Category": {
			post: domain.PostData{Category: nil},
			groups: []domain.FieldGroup{
				{
					Title: "category",
					Locations: [][]domain.FieldLocation{
						{{Param: "category", Operator: "==", Value: "false"}},
					},
				},
			},
			want: []domain.FieldGroup{},
		},
		"Author": {
			post: domain.PostData{Author: domain.UserPart{Id: 1}},
			groups: []domain.FieldGroup{
				{
					Title: "post",
					Locations: [][]domain.FieldLocation{
						{{Param: "author", Operator: "==", Value: "1"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "post"}},
		},
		"Role": {
			post: domain.PostData{Author: domain.UserPart{
				Role: domain.UserRole{
					Id: 1,
				},
			},
			},
			groups: []domain.FieldGroup{
				{
					Title: "role",
					Locations: [][]domain.FieldLocation{
						{{Param: "role", Operator: "==", Value: "1"}},
					},
				},
			},
			want: []domain.FieldGroup{{Title: "role"}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			l := &Location{Groups: test.groups}
			t.Equal(test.want, l.groupResolver(test.post))
		})
	}
}

func (t *LocationTestSuite) TestLocation_fieldGroupWalker() {

	testPath := "/test-field-groups/"

	var fg []domain.FieldGroup

	id, err := uuid.Parse("6a4d7442-1020-490f-a3e2-436f9135bc24")
	t.NoError(err)

	// For bad path
	err = os.Chmod(t.Path+testPath+"open-error/location.json", 000)
	t.NoError(err)
	defer func() {
		err = os.Chmod(t.Path+testPath+"open-error/location.json", 777)
		t.NoError(err)
	}()

	tt := map[string]struct {
		path string
		want interface{}
	}{
		"Success": {
			path: testPath + "/success",
			want: []domain.FieldGroup{{UUID: id, Title: "Title", Fields: []domain.Field{{Name: "test"}}}, {UUID: id, Title: "Title", Fields: []domain.Field{{Name: "test"}}}},
		},
		"Bad Path": {
			path: testPath + "/wrongval",
			want: "no such file or directory",
		},
		"Unmarshal Error": {
			path: testPath + "/unmarshal",
			want: fg,
		},
		"Open Error": {
			path: testPath + "/open-error",
			want: fg,
		},
		"Empty Fields": {
			path: testPath + "/empty",
			want: fg,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {

			l := &Location{
				JsonPath: t.Path + test.path,
			}
			got, err := l.fieldGroupWalker()

			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *LocationTestSuite) Test_CheckLocation() {

	tt := map[string]struct {
		check    string
		location domain.FieldLocation
		want     bool
	}{
		"Equal Match": {
			check:    "val",
			location: domain.FieldLocation{Operator: "==", Value: "val"},
			want:     true,
		},
		"Equal Not Match": {
			check:    "val",
			location: domain.FieldLocation{Operator: "==", Value: "wrongval"},
			want:     false,
		},
		"Not Equal Match": {
			check:    "val",
			location: domain.FieldLocation{Operator: "!=", Value: "val"},
			want:     false,
		},
		"Not Equal Not Match": {
			check:    "val",
			location: domain.FieldLocation{Operator: "!=", Value: "wrongval"},
			want:     true,
		},
		"Wrong Operator": {
			check:    "val",
			location: domain.FieldLocation{Operator: "wrong", Value: "val"},
			want:     false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, checkLocation(test.check, test.location))
		})
	}
}

func (t *LocationTestSuite) Test_CheckMatch() {

	tt := map[string]struct {
		matches []bool
		want    bool
	}{
		"Matches": {
			matches: []bool{true, false, true, false},
			want:    false,
		},
		"Not Matched": {
			matches: []bool{true, true, true, true},
			want:    true,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, checkMatch(test.matches))
		})
	}
}

func (t *LocationTestSuite) Test_HasBeenAdded() {

	key := uuid.New()

	tt := map[string]struct {
		fg   []domain.FieldGroup
		key  string
		want bool
	}{
		"Added": {
			fg:   []domain.FieldGroup{{UUID: key}},
			key:  key.String(),
			want: true,
		},
		"Not Added": {
			fg:   []domain.FieldGroup{{UUID: uuid.New()}},
			key:  key.String(),
			want: false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, hasBeenAdded(test.key, test.fg))
		})
	}
}"
}
{
file:./api/fields/converter/location.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package location

import (
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/cache"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/paths"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
)

// Finder defines the method for obtaining field layouts.
type Finder interface {
	GetLayout(post domain.PostData, cacheable bool) []domain.FieldGroup
}

// Location defines
type Location struct {
	// Groups defines the current field groups that
	// are saved to disk in storage.
	Groups []domain.FieldGroup
	// jsonPath defines where JSON files containing
	// domain.FieldGroups are kept
	JsonPath string
}

var (
	// Storage path of the application.
	storagePath = paths.Storage()
)

// NewLocation - Construct
func NewLocation() *Location {
	return &Location{
		JsonPath: storagePath + "/fields",
	}
}

// GetLayout
//
// Obtains layouts specific for the arguments passed. If
// caching allows and the domain.FieldGroups have
// been cached, it will return the cached
// version
func (l *Location) GetLayout(post domain.PostData, cacheable bool) []domain.FieldGroup {

	// If the cache allows for caching of layouts & if the
	// layout has already been cached, return.
	var found bool
	if cacheable {
		cached, found := cache.Store.Get("field_layout_" + post.UUID.String())
		if found {
			return cached.([]domain.FieldGroup)
		}
	}

	fg, err := l.fieldGroupWalker()
	if err != nil {
		fmt.Println(err)
		log.WithFields(log.Fields{"error": err}).Error()
	}
	l.Groups = fg

	// Get the groups from the resolver
	groups := l.groupResolver(post)

	// Set the cache field layout if the cache was not found
	if !found && cacheable {
		cache.Store.Set("field_layout_"+post.UUID.String(), groups, cache.RememberForever)
	}

	return groups
}

// groupResolver
//
// Loops over all of the locations within the config json file
// that is defined. Compares the location sets with with
// properties of the post, user and category passed.
// Produces an array of field groups that can be
// returned for the post.
func (l *Location) groupResolver(post domain.PostData) []domain.FieldGroup {
	var fg []domain.FieldGroup

	// Loop over the groups
	for _, group := range l.Groups {

		// Check for empty locations json
		if len(group.Locations) == 0 && !hasBeenAdded(group.UUID.String(), fg) {
			fg = append(fg, group)
		} else {

			// Check and Loop over locations
			for _, location := range group.Locations {

				if !hasBeenAdded(group.UUID.String(), fg) {

					// Loop over rule sets
					var locationSet []bool
					for _, rule := range location {

						switch rule.Param {
						case "status":
							locationSet = append(locationSet, checkLocation(post.Status, rule))
						case "post":
							locationSet = append(locationSet, checkLocation(strconv.Itoa(post.Id), rule))
						case "page_template":
							locationSet = append(locationSet, checkLocation(post.PageTemplate, rule))
						case "page_layout":
							locationSet = append(locationSet, checkLocation(post.PageLayout, rule))
						case "resource":
							if post.Resource != nil {
								locationSet = append(locationSet, checkLocation(*post.Resource, rule))
							} else {
								locationSet = append(locationSet, checkLocation("", rule))
							}
						case "category":
							if post.Category != nil {
								locationSet = append(locationSet, checkLocation(strconv.Itoa(post.Category.Id), rule))
							} else {
								locationSet = append(locationSet, checkLocation("", rule))
							}
						case "author":
							locationSet = append(locationSet, checkLocation(strconv.Itoa(post.Author.Id), rule))
						case "role":
							locationSet = append(locationSet, checkLocation(strconv.Itoa(post.Author.Role.Id), rule))
						}
					}

					// Remove from the array for the front end
					group.Locations = nil

					if checkMatch(locationSet) {
						fg = append(fg, group)
					}
				}
			}
		}
	}

	// Append empty if nil
	if fg == nil {
		fg = []domain.FieldGroup{}
	}

	return fg
}

// FieldGroupWalker
//
// This function will loop over all of the json files that have been
// stored in /storage/fields and append them to the array to be
// returned.
//
// Returns errors.INTERNAL if the path file not be read or be unmarshalled
func (l *Location) fieldGroupWalker() ([]domain.FieldGroup, error) {
	const op = "Fields.GetFieldGroups"

	var fg []domain.FieldGroup
	err := filepath.Walk(l.JsonPath, func(path string, info os.FileInfo, err error) error {

		if err != nil {
			return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("No file or directory with the path: %s", path), Operation: op, Err: err}
		}

		if filepath.Ext(info.Name()) == ".json" {

			file, err := ioutil.ReadFile(path)
			if err != nil {
				log.WithFields(log.Fields{
					"error": &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to read field file with the path: %s", path), Operation: op, Err: err},
				}).Error()
				return nil
			}

			var fields domain.FieldGroup
			err = json.Unmarshal(file, &fields)
			if err != nil {
				log.WithFields(log.Fields{
					"error": &errors.Error{Code: errors.INTERNAL, Message: "Unable to unmarshal the field struct", Operation: op, Err: fmt.Errorf("cannot parse file %s: %s", info.Name(), err.Error())},
				}).Error()
				return nil
			}

			if fields.Fields == nil {
				log.WithFields(log.Fields{
					"error": &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("No fields exist with the path: %s", path), Operation: op, Err: fmt.Errorf("layout does not contain any fields")},
				}).Error()
				return nil
			}

			fg = append(fg, fields)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return fg, nil
}

// checkLocation
//
// Checks to see if there has been a match within the location
// json passed, the string could be resource. page
// template or anything defined within fields.
func checkLocation(check string, location domain.FieldLocation) bool {
	var match = false

	switch location.Operator {
	case "==":
		if check == location.Value {
			match = true
		}
	case "!=":
		if check != location.Value {
			match = true
		}
	}

	return match
}

// checkMatch
//
// Checks to see if the there has been a match within
// the location json block by using an array of booleans, if there
// has already been a match, it will return false. Useful
// for and location json blocks not or.
func checkMatch(matches []bool) bool {
	for _, a := range matches {
		if !a {
			return false
		}
	}
	return true
}

// hasBeenAdded
//
// Checks to see if there already been a match within
// the array of field groups by comparing key and
// the UUID.
func hasBeenAdded(key string, fg []domain.FieldGroup) bool {
	for _, v := range fg {
		if v.UUID.String() == key {
			return true
		}
	}
	return false
}"
}
{
file:./api/fields/layout/uuid_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestWalkerByUUID(t *testing.T) {

	id := uuid.New()

	repeater := []domain.Field{
		{UUID: id},
	}

	nested := []domain.Field{
		{UUID: uuid.New(), SubFields: &repeater},
	}

	doubleNested := []domain.Field{
		{UUID: uuid.New(), SubFields: &nested},
	}

	tt := map[string]struct {
		uuid  uuid.UUID
		field domain.Field
		found bool
		want  domain.Field
	}{
		"Normal Field": {
			uuid:  id,
			field: domain.Field{UUID: id},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Repeater": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New(), SubFields: &repeater},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Nested Repeater": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New(), SubFields: &nested},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Double Nested Repeater": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New(), SubFields: &doubleNested},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Nil Sub Fields": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New(), SubFields: nil},
			found: false,
			want:  domain.Field{},
		},
		"Flexible Content": {
			uuid: id,
			field: domain.Field{UUID: uuid.New(), Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &repeater,
				},
			}},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Flexible Content Repeater": {
			uuid: id,
			field: domain.Field{UUID: uuid.New(), Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &repeater,
				},
			}},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Flexible Content Nested Repeater": {
			uuid: id,
			field: domain.Field{UUID: uuid.New(), Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &nested,
				},
			}},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Flexible Content Double Nested Repeater": {
			uuid: id,
			field: domain.Field{UUID: uuid.New(), Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &doubleNested,
				},
			}},
			found: true,
			want:  domain.Field{UUID: id},
		},
		"Nil Flexible Content": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New(), Layouts: map[string]domain.FieldLayout{}},
			found: false,
			want:  domain.Field{},
		},
		"Not Found": {
			uuid:  id,
			field: domain.Field{UUID: uuid.New()},
			found: false,
			want:  domain.Field{},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, found := walkerByUUID(test.uuid, test.field)
			assert.Equal(t, test.found, found)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/fields/layout/walk_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestByUUID(t *testing.T) {

	id := uuid.New()
	field := domain.Field{UUID: id, Type: "text"}
	fields := []domain.Field{field}

	tt := map[string]struct {
		uuid   uuid.UUID
		groups []domain.FieldGroup
		want   interface{}
	}{
		"Found": {
			uuid:   id,
			groups: []domain.FieldGroup{{Fields: fields}},
			want:   field,
		},
		"Not Found": {
			uuid:   uuid.New(),
			groups: []domain.FieldGroup{{Fields: fields}},
			want:   fmt.Sprintf("unable to find field with UUID of"),
		},
		"No Layouts": {
			uuid:   uuid.New(),
			groups: nil,
			want:   fmt.Sprintf("no groups exist, unable to range over groups and find fields"),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ByUUID(test.uuid, test.groups)

			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}

			assert.Equal(t, test.want, got)
		})
	}
}

func TestByName(t *testing.T) {

	field := domain.Field{Name: "test", Type: "text"}
	fields := []domain.Field{field}

	tt := map[string]struct {
		name   string
		groups []domain.FieldGroup
		want   interface{}
	}{
		"Found": {
			name:   "test",
			groups: []domain.FieldGroup{{Fields: fields}},
			want:   field,
		},
		"Not Found": {
			name:   "wrong",
			groups: []domain.FieldGroup{{Fields: fields}},
			want:   fmt.Sprintf("unable to find field with name of"),
		},
		"No Layouts": {
			name:   "test",
			groups: nil,
			want:   fmt.Sprintf("no groups exist, unable to range over groups and find fields"),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, err := ByName(test.name, test.groups)

			if err != nil {
				assert.Contains(t, err.Error(), test.want)
				return
			}

			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/fields/layout/walk.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/google/uuid"
)

// ByUUID
//
// Traverses the given domain.FieldGroups and compares the
// field UUID until a match has been found.
// Returns a domain.Field if the fields was resolved.
// Returns errors.NOTFOUND if the field was unable to be located or no groups exist.
func ByUUID(uuid uuid.UUID, groups []domain.FieldGroup) (domain.Field, error) {
	const op = "Fields.Walker.ByUUID"

	if len(groups) == 0 {
		return domain.Field{}, &errors.Error{Code: errors.NOTFOUND, Message: "No groups exists", Operation: op, Err: fmt.Errorf("no groups exist, unable to range over groups and find fields")}
	}

	for _, g := range groups {
		for _, f := range g.Fields {
			field, found := walkerByUUID(uuid, f)
			if !found {
				continue
			}
			return field, nil
		}
	}

	return domain.Field{}, &errors.Error{Code: errors.NOTFOUND, Message: "Unable to find field", Operation: op, Err: fmt.Errorf("unable to find field with UUID of: %v", uuid)}
}

// ByName
//
// Traverses the given domain.FieldGroups and compares the
// field name until a match has been found.
// Returns a domain.Field if the fields was resolved.
// Returns errors.NOTFOUND if the field was unable to be located or no groups exist.
func ByName(name string, groups []domain.FieldGroup) (domain.Field, error) {
	const op = "Fields.Walker.ByUUID"

	if len(groups) == 0 {
		return domain.Field{}, &errors.Error{Code: errors.NOTFOUND, Message: "No groups exists", Operation: op, Err: fmt.Errorf("no groups exist, unable to range over groups and find fields")}
	}

	for _, g := range groups {
		for _, f := range g.Fields {
			field, found := walkerByName(name, f)
			if !found {
				continue
			}
			return field, nil
		}

	}

	return domain.Field{}, &errors.Error{Code: errors.NOTFOUND, Message: "Unable to find field", Operation: op, Err: fmt.Errorf("unable to find field with name of: %s", name)}
}"
}
{
file:./api/fields/layout/name_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestWalkerByName(t *testing.T) {

	repeater := []domain.Field{
		{Name: "test"},
	}

	nested := []domain.Field{
		{Name: "wrong", SubFields: &repeater},
	}

	doubleNested := []domain.Field{
		{Name: "wrong", SubFields: &nested},
	}

	tt := map[string]struct {
		field domain.Field
		found bool
		want  domain.Field
	}{
		"Normal Field": {
			field: domain.Field{Name: "test"},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Repeater": {
			field: domain.Field{Name: "wrong", SubFields: &repeater},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Nested Repeater": {
			field: domain.Field{Name: "wrong", SubFields: &nested},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Double Nested Repeater": {
			field: domain.Field{Name: "wrong", SubFields: &doubleNested},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Nil Sub Fields": {
			field: domain.Field{Name: "wrong", SubFields: nil},
			found: false,
			want:  domain.Field{},
		},
		"Flexible Content": {
			field: domain.Field{Name: "wrong", Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &repeater,
				},
			}},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Flexible Content Repeater": {
			field: domain.Field{Name: "wrong", Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &repeater,
				},
			}},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Flexible Content Nested Repeater": {
			field: domain.Field{Name: "wrong", Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &nested,
				},
			}},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Flexible Content Double Nested Repeater": {
			field: domain.Field{Name: "wrong", Layouts: map[string]domain.FieldLayout{
				"layout": {
					SubFields: &doubleNested,
				},
			}},
			found: true,
			want:  domain.Field{Name: "test"},
		},
		"Not Found": {
			field: domain.Field{Name: "wrong"},
			found: false,
			want:  domain.Field{},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			got, found := walkerByName("test", test.field)
			assert.Equal(t, test.found, found)
			assert.Equal(t, test.want, got)
		})
	}
}"
}
{
file:./api/fields/layout/uuid.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/google/uuid"
)

// walkerByUUID
//
// Uses recursion to locate a field by UUID by comparing the given UUID
// and the field's UUID, the sub fields (repeaters) and the sub
// fields of flexible content.
// Returns a domain.Field and true if it was found.
// Returns false if it wasn't.
func walkerByUUID(uuid uuid.UUID, field domain.Field) (domain.Field, bool) {

	// Account for normal field
	if field.UUID == uuid {
		return field, true
	}

	// Account for repeaters
	if field.SubFields != nil {
		for _, subField := range *field.SubFields {
			if f, found := walkerByUUID(uuid, subField); found {
				return f, true
			}
		}
	}

	// Account for flexible content
	if len(field.Layouts) != 0 {
		for _, layout := range field.Layouts {
			for _, subField := range *layout.SubFields {
				if f, found := walkerByUUID(uuid, subField); found {
					return f, true
				}
			}
		}
	}

	// Field not found
	return domain.Field{}, false
}"
}
{
file:./api/fields/layout/name.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package layout

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

// walkerByName
//
// Uses recursion to locate a field by name by comparing the given name
// and the field's name, the sub fields (repeaters) and the sub
// fields of flexible content.
// Returns a domain.Field and true if it was found.
// Returns false if it wasn't.
func walkerByName(name string, field domain.Field) (domain.Field, bool) {

	// Account for normal field
	if field.Name == name {
		return field, true
	}

	// Account for repeaters
	if field.SubFields != nil {
		for _, subField := range *field.SubFields {
			if f, found := walkerByName(name, subField); found {
				return f, true
			}
		}
	}

	// Account for flexible content
	if len(field.Layouts) != 0 {
		for _, layout := range field.Layouts {
			for _, subField := range *layout.SubFields {
				if f, found := walkerByName(name, subField); found {
					return f, true
				}
			}
		}
	}

	// Field not found
	return domain.Field{}, false
}"
}
{
file:./api/fields/service_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/config"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/models"
)

func (t *FieldTestSuite) TestNewService() {
	m := &models.Store{}

	var l = make([]domain.FieldGroup, 0)
	var f = make([]domain.PostField, 0)

	pd := &domain.PostData{
		Post: domain.Post{
			Id: 1,
		},
		Layout: l,
		Fields: f,
	}

	deps := &deps.Deps{
		Store:  m,
		Config: &config.Configuration{},
	}

	service := &Service{
		deps:   deps,
		postId: 1,
		fields: f,
		layout: l,
	}

	t.Equal(NewService(deps, pd), service)
}"
}
{
file:./api/fields/repeater_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

func (t *FieldTestSuite) TestService_GetRepeater() {

	tt := map[string]struct {
		fields []domain.PostField
		input  interface{}
		want   interface{}
		err    bool
	}{
		"Cast to Repeater": {
			fields: nil,
			input: Repeater{
				Row{{Id: 1, Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "repeater|0|text"}},
				Row{{Id: 2, Type: "text", Name: "text", OriginalValue: "text2", Value: "text2", Key: "repeater|1|text"}},
			},
			want: Repeater{
				Row{{Id: 1, Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "repeater|0|text"}},
				Row{{Id: 2, Type: "text", Name: "text", OriginalValue: "text2", Value: "text2", Key: "repeater|1|text"}},
			},
			err: false,
		},
		"No Stringer": {
			fields: nil,
			input:  noStringer{},
			want:   "unable to cast fields.noStringer{} of type fields.noStringer to string",
			err:    true,
		},
		"No Field": {
			fields: nil,
			input:  "test",
			want:   "no field exists with the name: test",
			err:    true,
		},
		"Wrong Field Type": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "test", OriginalValue: "text", Key: ""},
			},
			input: "test",
			want:  "field with the name: test, is not a repeater",
			err:   true,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(test.fields)

			got := s.GetRepeater(test.input)
			if test.err {
				t.Contains(t.logWriter.String(), test.want)
				t.Reset()
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *FieldTestSuite) TestService_ResolveRepeater() {

	tt := map[string]struct {
		fields []domain.PostField
		key    string
		want   interface{}
	}{
		"Bad Cast to Int": {
			fields: []domain.PostField{
				{Id: 1, Type: "repeater", Name: "repeater", OriginalValue: "@$$%^&%$^&"},
				{Id: 2, Type: "text", Name: "text", OriginalValue: "text1", Key: "repeater|0|text"},
			},
			key:  "repeater",
			want: Repeater{},
		},
		"Simple": {
			fields: []domain.PostField{
				{Type: "repeater", Name: "repeater", OriginalValue: "3"},
				{Type: "text", Name: "text", OriginalValue: "text1", Key: "repeater|0|text"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "repeater|0|text2"},
				{Type: "text", Name: "text", OriginalValue: "text3", Key: "repeater|1|text"},
				{Type: "text", Name: "text2", OriginalValue: "text4", Key: "repeater|1|text2"},
				{Type: "text", Name: "text", OriginalValue: "text5", Key: "repeater|2|text"},
				{Type: "text", Name: "text2", OriginalValue: "text6", Key: "repeater|2|text2"},
			},
			key: "repeater",
			want: Repeater{
				Row{
					{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "repeater|0|text"},
					{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "repeater|0|text2"},
				},
				Row{
					{Type: "text", Name: "text", OriginalValue: "text3", Value: "text3", Key: "repeater|1|text"},
					{Type: "text", Name: "text2", OriginalValue: "text4", Value: "text4", Key: "repeater|1|text2"},
				},
				Row{
					{Type: "text", Name: "text", OriginalValue: "text5", Value: "text5", Key: "repeater|2|text"},
					{Type: "text", Name: "text2", OriginalValue: "text6", Value: "text6", Key: "repeater|2|text2"},
				},
			},
		},
		"Nested": {
			fields: []domain.PostField{
				{Type: "repeater", Name: "repeater", OriginalValue: "2"},
				{Type: "text", Name: "parent_text", OriginalValue: "R1", Key: "repeater|0|parent_text"},
				{Type: "text", Name: "parent_text", OriginalValue: "R2", Key: "repeater|1|parent_text"},
				{Type: "repeater", Name: "nested", OriginalValue: "2", Key: "repeater|0|nested"},
				{Type: "text", Name: "nested_text", OriginalValue: "N1", Key: "repeater|0|nested|0|nested_test"},
				{Type: "text", Name: "nested_text", OriginalValue: "N2", Key: "repeater|0|nested|1|nested_test"},
				{Type: "repeater", Name: "nested", OriginalValue: "2", Key: "repeater|1|nested"},
				{Type: "text", Name: "nested_text", OriginalValue: "N3", Key: "repeater|1|nested|0|nested_test"},
				{Type: "text", Name: "nested_text", OriginalValue: "N4", Key: "repeater|1|nested|1|nested_test"},
			},
			key: "repeater",
			want: Repeater{
				Row{
					{Type: "text", Name: "parent_text", OriginalValue: "R1", Value: "R1", Key: "repeater|0|parent_text"},
					{Type: "repeater", Name: "nested", OriginalValue: "2", Key: "repeater|0|nested", Value: Repeater{
						Row{{Type: "text", Name: "nested_text", OriginalValue: "N1", Value: "N1", Key: "repeater|0|nested|0|nested_test"}},
						Row{{Type: "text", Name: "nested_text", OriginalValue: "N2", Value: "N2", Key: "repeater|0|nested|1|nested_test"}},
					}},
				},
				Row{
					{Type: "text", Name: "parent_text", OriginalValue: "R2", Value: "R2", Key: "repeater|1|parent_text"},
					{Type: "repeater", Name: "nested", OriginalValue: "2", Key: "repeater|1|nested", Value: Repeater{
						Row{{Type: "text", Name: "nested_text", OriginalValue: "N3", Value: "N3", Key: "repeater|1|nested|0|nested_test"}},
						Row{{Type: "text", Name: "nested_text", OriginalValue: "N4", Value: "N4", Key: "repeater|1|nested|1|nested_test"}},
					}},
				},
			},
		},
		"Nested Nested": {
			fields: []domain.PostField{
				{Type: "repeater", Name: "repeater", OriginalValue: "2"},
				{Type: "text", Name: "parent_text", OriginalValue: "R1", Key: "repeater|0|parent_text"},
				{Type: "text", Name: "parent_text", OriginalValue: "R2", Key: "repeater|1|parent_text"},
				{Type: "repeater", Name: "nested", OriginalValue: "1", Key: "repeater|0|nested"},
				{Type: "text", Name: "nested_text", OriginalValue: "N1", Key: "repeater|0|nested|0|nested_test"},

				{Type: "repeater", Name: "nested_nested", OriginalValue: "1", Key: "repeater|0|nested|0|nested_nested"},
				{Type: "text", Name: "nested_nested_text", OriginalValue: "NN1", Key: "repeater|0|nested|0|nested_nested|0|nested_nested_text"},

				{Type: "repeater", Name: "nested", OriginalValue: "1", Key: "repeater|1|nested"},
				{Type: "text", Name: "nested_text", OriginalValue: "N2", Key: "repeater|1|nested|0|nested_test"},

				{Type: "repeater", Name: "nested_nested", OriginalValue: "1", Key: "repeater|1|nested|0|nested_nested"},
				{Type: "text", Name: "nested_nested_text", OriginalValue: "NN1", Key: "repeater|1|nested|0|nested_nested|0|nested_nested_text"},
			},
			key: "repeater",
			want: Repeater{
				Row{
					{Type: "text", Name: "parent_text", OriginalValue: "R1", Value: "R1", Key: "repeater|0|parent_text"},
					{Type: "repeater", Name: "nested", OriginalValue: "1", Key: "repeater|0|nested", Value: Repeater{
						Row{
							{Type: "text", Name: "nested_text", OriginalValue: "N1", Value: "N1", Key: "repeater|0|nested|0|nested_test"},
							{Type: "repeater", Name: "nested_nested", OriginalValue: "1", Key: "repeater|0|nested|0|nested_nested", Value: Repeater{
								Row{
									{Type: "text", Name: "nested_nested_text", OriginalValue: "NN1", Value: "NN1", Key: "repeater|0|nested|0|nested_nested|0|nested_nested_text"},
								},
							}},
						},
					}},
				},
				Row{
					{Type: "text", Name: "parent_text", OriginalValue: "R2", Value: "R2", Key: "repeater|1|parent_text"},
					{Type: "repeater", Name: "nested", OriginalValue: "1", Key: "repeater|1|nested", Value: Repeater{
						Row{
							{Type: "text", Name: "nested_text", OriginalValue: "N2", Value: "N2", Key: "repeater|1|nested|0|nested_test"},
							{Type: "repeater", Name: "nested_nested", OriginalValue: "1", Key: "repeater|1|nested|0|nested_nested", Value: Repeater{
								Row{
									{Type: "text", Name: "nested_nested_text", OriginalValue: "NN1", Value: "NN1", Key: "repeater|1|nested|0|nested_nested|0|nested_nested_text"},
								},
							}},
						},
					}},
				},
			},
		},

		// TODO FLEXIBLE
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(test.fields)

			got := s.GetRepeater(test.key)
			//if err != nil {
			//	t.Contains(err.Error(), test.want)
			//	return
			//}

			t.Equal(test.want, got)
		})
	}
}

func (t *FieldTestSuite) TestRepeater_HasRows() {

	tt := map[string]struct {
		repeater Repeater
		want     interface{}
	}{
		"With Rows": {
			repeater: Repeater{
				Row{
					{Id: 1}, {Id: 2}, {Id: 3},
				},
			},
			want: true,
		},
		"Without Rows": {
			repeater: Repeater{},
			want:     false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.repeater.HasRows())
		})
	}
}

func (t *FieldTestSuite) TestRow_SubField() {

	row := Row{
		{Id: 1, Name: "test1", Type: "text", OriginalValue: "1", Value: "1"},
		{Id: 2, Name: "test2", Type: "text", OriginalValue: "2", Value: "2"},
		{Id: 3, Name: "test3", Type: "text", OriginalValue: "3", Value: "3"},
	}

	tt := map[string]struct {
		key  string
		want interface{}
	}{
		"Found": {
			key:  "test1",
			want: "1",
		},
		"Found 2": {
			key:  "test2",
			want: "2",
		},
		"Found 3": {
			key:  "test3",
			want: "3",
		},
		"Not Found": {
			key:  "wrongval",
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, row.SubField(test.key))
		})
	}
}

func (t *FieldTestSuite) TestRow_HasField() {

	row := Row{
		{Id: 1, Name: "test1", Type: "text", OriginalValue: "1", Value: "1"},
		{Id: 2, Name: "test2", Type: "text", OriginalValue: "2", Value: "2"},
		{Id: 3, Name: "test3", Type: "text", OriginalValue: "3", Value: "3"},
	}

	tt := map[string]struct {
		key  string
		want interface{}
	}{
		"True": {
			key:  "test1",
			want: true,
		},
		"False": {
			key:  "wrongval",
			want: false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, row.HasField(test.key))
		})
	}
}

func (t *FieldTestSuite) TestRow_First() {

	tt := map[string]struct {
		row  Row
		want interface{}
	}{
		"Found": {
			row: Row{
				{Id: 1, Name: "test1", Type: "text", OriginalValue: "1", Value: "1"},
				{Id: 2, Name: "test2", Type: "text", OriginalValue: "2", Value: "2"},
				{Id: 3, Name: "test3", Type: "text", OriginalValue: "3", Value: "3"},
			},
			want: domain.PostField{Id: 1, Name: "test1", Type: "text", OriginalValue: "1", Value: "1"},
		},
		"Not Found": {
			row:  Row{},
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.row.First())
		})
	}
}

func (t *FieldTestSuite) TestRow_Last() {

	tt := map[string]struct {
		row  Row
		want interface{}
	}{
		"Found": {
			row: Row{
				{Id: 1, Name: "test1", Type: "text", OriginalValue: "1", Value: "1"},
				{Id: 2, Name: "test2", Type: "text", OriginalValue: "2", Value: "2"},
				{Id: 3, Name: "test3", Type: "text", OriginalValue: "3", Value: "3"},
			},
			want: domain.PostField{Id: 3, Name: "test3", Type: "text", OriginalValue: "3", Value: "3"},
		},
		"Not Found": {
			row:  Row{},
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.row.Last())
		})
	}
}"
}
{
file:./api/fields/flexible_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
)

func (t *FieldTestSuite) TestService_GetFlexible() {

	tt := map[string]struct {
		fields []domain.PostField
		input  interface{}
		want   interface{}
		err    bool
	}{
		"Cast to Flexible": {
			fields: nil,
			input: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
					},
				},
			},
			want: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
					},
				},
			},
			err: false,
		},
		"No Stringer": {
			fields: nil,
			input:  noStringer{},
			want:   "unable to cast fields.noStringer{} of type fields.noStringer to string",
			err:    true,
		},
		"No Field": {
			fields: nil,
			input:  "test",
			want:   "no field exists with the name: test",
			err:    true,
		},
		"Wrong Field Type": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "test", OriginalValue: "text", Key: ""},
			},
			input: "test",
			want:  "field with the name: test, is not flexible content",
			err:   true,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(test.fields)

			got := s.GetFlexible(test.input)
			if test.err {
				t.Contains(t.logWriter.String(), test.want)
				t.Reset()
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *FieldTestSuite) TestService_ResolveFlexible() {

	tt := map[string]struct {
		flexible domain.PostField
		fields   []domain.PostField
		key      string
		want     interface{}
	}{
		"One Layout": {
			flexible: domain.PostField{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1"},
			fields: []domain.PostField{
				{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1,layout2,layout3"},
				{Type: "text", Name: "text1", OriginalValue: "text1", Key: "flex|0|text1"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|text2"},
			},
			key: "flex",
			want: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
					},
				},
			},
		},
		"Simple": {
			flexible: domain.PostField{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1,layout2,layout3"},
			fields: []domain.PostField{
				{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1,layout2,layout3"},
				{Type: "text", Name: "text1", OriginalValue: "text1", Key: "flex|0|text1"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|text2"},
				{Type: "text", Name: "text3", OriginalValue: "text3", Key: "flex|1|text3"},
				{Type: "text", Name: "text4", OriginalValue: "text4", Key: "flex|1|text4"},
				{Type: "text", Name: "text5", OriginalValue: "text5", Key: "flex|2|text5"},
				{Type: "text", Name: "text6", OriginalValue: "text6", Key: "flex|2|text6"},
			},
			key: "flex",
			want: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
					},
				},
				{
					Name: "layout2",
					SubFields: SubFields{
						{Type: "text", Name: "text3", OriginalValue: "text3", Value: "text3", Key: "flex|1|text3"},
						{Type: "text", Name: "text4", OriginalValue: "text4", Value: "text4", Key: "flex|1|text4"},
					},
				},
				{
					Name: "layout3",
					SubFields: SubFields{
						{Type: "text", Name: "text5", OriginalValue: "text5", Value: "text5", Key: "flex|2|text5"},
						{Type: "text", Name: "text6", OriginalValue: "text6", Value: "text6", Key: "flex|2|text6"},
					},
				},
			},
		},
		"Nested": {
			flexible: domain.PostField{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1"},
			fields: []domain.PostField{
				{Type: "text", Name: "text1", OriginalValue: "text1", Key: "flex|0|text1"},
				{Type: "flexible", Name: "nested", OriginalValue: "nestedlayout", Key: "flex|0|nested"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|nested|0|text1"},
			},
			key: "flex",
			want: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "flexible", Name: "nested", OriginalValue: "nestedlayout", Key: "flex|0|nested", Value: Flexible{
							{
								Name: "nestedlayout",
								SubFields: SubFields{
									{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|nested|0|text1"},
								},
							},
						}},
					},
				},
			},
		},
		"Repeater": {
			flexible: domain.PostField{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1,layout1"},
			fields: []domain.PostField{
				{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1,layout2"},
				{Type: "text", Name: "text1", OriginalValue: "text1", Key: "flex|0|text1"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|text2"},
				{Type: "text", Name: "text3", OriginalValue: "text3", Key: "flex|1|text3"},
				{Type: "text", Name: "text4", OriginalValue: "text4", Key: "flex|1|text4"},

				{Type: "repeater", Name: "repeater", OriginalValue: "1", Key: "flex|0|repeater"},
				{Type: "text", Name: "text", OriginalValue: "text1", Key: "flex|0|repeater|0|text"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|repeater|0|text2"},

				{Type: "repeater", Name: "repeater", OriginalValue: "1", Key: "flex|1|repeater"},
				{Type: "text", Name: "text", OriginalValue: "text1", Key: "flex|1|repeater|0|text"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|1|repeater|0|text2"},
			},
			key: "flex",
			want: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
						{Type: "repeater", Name: "repeater", OriginalValue: "1", Key: "flex|0|repeater", Value: Repeater{
							Row{
								{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "flex|0|repeater|0|text"},
								{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|repeater|0|text2"},
							}},
						},
					},
				},
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text3", OriginalValue: "text3", Value: "text3", Key: "flex|1|text3"},
						{Type: "text", Name: "text4", OriginalValue: "text4", Value: "text4", Key: "flex|1|text4"},
						{Type: "repeater", Name: "repeater", OriginalValue: "1", Key: "flex|1|repeater", Value: Repeater{
							Row{
								{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "flex|1|repeater|0|text"},
								{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|1|repeater|0|text2"},
							}},
						},
					},
				},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetService(test.fields).resolveFlexible("", test.flexible, test.fields))
		})
	}
}

func (t *FieldTestSuite) TestFlexible_HasRows() {

	tt := map[string]struct {
		flexible Flexible
		want     interface{}
	}{
		"With Rows": {
			flexible: Flexible{
				{Name: "layout", SubFields: SubFields{domain.PostField{Id: 1, Name: "test"}}},
			},
			want: true,
		},
		"Without Rows": {
			flexible: Flexible{},
			want:     false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.flexible.HasRows())
		})
	}
}

func (t *FieldTestSuite) TestSubFields_SubField() {

	subfield := SubFields{
		{Id: 1, Name: "test1", Value: 1},
		{Id: 2, Name: "test2", Value: 2},
		{Id: 3, Name: "test3", Value: 3},
	}

	tt := map[string]struct {
		key  string
		want interface{}
	}{
		"Found": {
			key:  "test1",
			want: 1,
		},
		"Not Found": {
			key:  "wrongval",
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, subfield.SubField(test.key))
		})
	}
}

func (t *FieldTestSuite) TestSubFields_First() {

	tt := map[string]struct {
		subfields SubFields
		want      interface{}
	}{
		"Found": {
			subfields: SubFields{
				{Id: 1, Name: "test1", Value: 1},
				{Id: 2, Name: "test2", Value: 2},
				{Id: 3, Name: "test3", Value: 3},
			},
			want: domain.PostField{Id: 1, Name: "test1", Value: 1},
		},
		"Not Found": {
			subfields: SubFields{},
			want:      nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.subfields.First())
		})
	}
}

func (t *FieldTestSuite) TestSubFields_Last() {

	tt := map[string]struct {
		subfields SubFields
		want      interface{}
	}{
		"Found": {
			subfields: SubFields{
				{Id: 1, Name: "test1", Value: 1},
				{Id: 2, Name: "test2", Value: 2},
				{Id: 3, Name: "test3", Value: 3},
			},
			want: domain.PostField{Id: 3, Name: "test3", Value: 3},
		},
		"Not Found": {
			subfields: SubFields{},
			want:      nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, test.subfields.Last())
		})
	}
}"
}
{
file:./api/fields/layout.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/fields/layout"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cast"
)

// GetGroup
//
func (s *Service) GetLayout(name string, args ...interface{}) domain.Field {
	l, err := layout.ByName(name, s.handleLayoutArgs(args))
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return domain.Field{}
	}
	return l
}

// GetGroups
//
func (s *Service) GetLayouts(args ...interface{}) []domain.FieldGroup {
	return s.handleLayoutArgs(args)
}

// handleLayoutArgs
//
func (s *Service) handleLayoutArgs(args []interface{}) []domain.FieldGroup {
	switch len(args) {
	case 1:
		layout := s.getLayoutByPost(args[0])
		return layout
	default:
		return s.layout
	}
}

// getLayoutByPost
//
// Returns the layout by Post with the given ID.
// Logs errors.INVALID if the id failed to be cast to an int.
// Logs if the post if was not found or there was an error obtaining/formatting the post.
func (s *Service) getLayoutByPost(id interface{}) []domain.FieldGroup {
	const op = "FieldsService.getFieldsByPost"

	i, err := cast.ToIntE(id)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Unable to cast Post ID to integer", Operation: op, Err: err},
		}).Error()
		return nil
	}

	post, err := s.deps.Store.Posts.GetById(i, true)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return nil
	}

	return post.Layout
}"
}
{
file:./api/fields/common_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *FieldTestSuite) TestService_HandleArgs() {

	tt := map[string]struct {
		fields []domain.PostField
		args   []interface{}
		mock   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)
		want   []domain.PostField
	}{
		"Default": {
			fields: []domain.PostField{{Name: "test"}},
			args:   nil,
			want:   []domain.PostField{{Name: "test"}},
		},
		"1 Args (Post Fields)": {
			args: []interface{}{domain.PostData{
				Post:   domain.Post{Id: 1, Title: "post"},
				Fields: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
			}},
			want: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
		},
		"1 Args (Post)": {
			fields: nil,
			args:   []interface{}{1},
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 1).Return([]domain.PostField{
					{Id: 1, Type: "text", Name: "post"},
				}, nil)
			},
			want: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
		},
		"1 Args (Post Template)": {
			fields: nil,
			args: []interface{}{domain.PostTemplate{
				Post:   domain.Post{Id: 1, Title: "post"},
				Fields: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
			}},
			mock: nil,
			want: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
		},
		"1 Args (Fields)": {
			fields: nil,
			args:   []interface{}{[]domain.PostField{{Id: 1, Type: "text", Name: "post"}}},
			mock:   nil,
			want:   []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
		},
		"1 Args (Post Error)": {
			fields: []domain.PostField{{Name: "test"}},
			args:   []interface{}{1},
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 1).Return(nil, fmt.Errorf("error"))
			},
			want: nil,
		},
		"Cast Error": {
			fields: nil,
			args:   []interface{}{noStringer{}},
			mock:   nil,
			want:   nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetMockService(test.fields, test.mock).handleArgs(test.args))
		})
	}
}

func (t *FieldTestSuite) TestService_GetFieldsByPost() {

	tt := map[string]struct {
		id   int
		mock func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)
		want []domain.PostField
	}{
		"Success": {
			id: 1,
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 1).Return([]domain.PostField{
					{Id: 1, Type: "text", Name: "post"},
				}, nil)
			},
			want: []domain.PostField{{Id: 1, Type: "text", Name: "post"}},
		},
		"Get Error": {
			id: 1,
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 1).Return(nil, fmt.Errorf("error"))
			},
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetMockService(nil, test.mock).getFieldsByPost(test.id))
		})
	}
}

func (t *FieldTestSuite) TestService_FindFieldByName() {

	tt := map[string]struct {
		name   string
		fields []domain.PostField
		want   interface{}
	}{
		"Success": {
			name:   "test",
			fields: []domain.PostField{{Id: 1, Type: "text", Name: "test"}},
			want:   domain.PostField{Id: 1, Type: "text", Name: "test"},
		},
		"Fail": {
			name:   "test",
			fields: nil,
			want:   "no field exists with the name: test",
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(test.fields)

			got, err := s.findFieldByName(test.name, test.fields)
			if err != nil {
				t.Contains(err.Error(), test.want)
				return
			}

			t.Equal(test.want, got)
		})
	}
}

//func (t *FieldTestSuite) TestResolve_Walker() {
//
//	tt := map[string]struct {
//		resolver resolve
//		want     interface{}
//	}{
//		"No Prefix": {
//			resolver: resolve{
//				Key:   "",
//				Index: 0,
//				Field: domain.PostField{Type: "repeater", Name: "repeater", OriginalValue: "1"},
//				Fields: []domain.PostField{
//					{Type: "text", Name: "text", OriginalValue: "text1", Key: ""},
//				},
//			},
//			want: domain.PostField{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: ""},
//		},
//		"Success": {
//			resolver: resolve{
//				Key:   "",
//				Index: 0,
//				Field: domain.PostField{Type: "repeater", Name: "repeater", OriginalValue: "1"},
//				Fields: []domain.PostField{
//					{Type: "text", Name: "text", OriginalValue: "text1", Key: "repeater|0|text"},
//				},
//			},
//			want: domain.PostField{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "repeater|0|text"},
//		},
//	}
//
//	for name, test := range tt {
//		t.Run(name, func() {
//			test.resolver.Service = t.GetService(nil)
//			test.resolver.Walker(func(field domain.PostField) {
//				t.Equal(test.want, field)
//			})
//		})
//	}
//}"
}
{
file:./api/fields/flexible.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cast"
)

// Flexible represents the collection of layouts used
// for the flexible content function in templates.
type Flexible []Layout

// Layout represents the collection of subfield's and
// layout's name.
type Layout struct {
	Name      string
	SubFields SubFields
}

// Subfields represents the collection of fields used
// for templates. It has various functions attached
// to it making it easier to loop over.
type SubFields []domain.PostField

// GetFlexible
//
// Returns the collection of Layouts from the given key and returns
// a new Flexible.
//
// Returns errors.INVALID if the field type is not flexible content.
// Returns errors.INTERNAL if the layouts could not be cast to a string slice.
func (s *Service) GetFlexible(input interface{}, args ...interface{}) Flexible {
	const op = "FieldsService.GetFlexible"

	flexible, ok := input.(Flexible)
	if ok {
		return flexible
	}

	name, err := cast.ToStringE(input)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Could not cast input to string", Operation: op, Err: err},
		}).Error()
		return nil
	}

	fields := s.handleArgs(args)

	field, err := s.findFieldByName(name, fields)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return nil
	}

	if field.Type != "flexible" {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Field is not flexible content", Operation: op, Err: fmt.Errorf("field with the name: %s, is not flexible content", name)},
		}).Error()
		return nil
	}

	return s.resolveFlexible("", field, fields)
}

// getLayouts
//
// Loops over the given layouts (e.g ["layout1","layout2"] and builds up
// an array of SUbFields if the SubField layout matches the ranged
// layout.
// Fields are resolved dependant on the format parameter.
// Returns a new Flexible.
func (s *Service) resolveFlexible(key string, field domain.PostField, fields []domain.PostField) Flexible {
	layouts := field.OriginalValue.Array()

	var flexible = make(Flexible, len(layouts))
	for index := 0; index < len(flexible); index++ {

		r := walker{
			Key:     key,
			Index:   index,
			Field:   field,
			Fields:  fields,
			Service: s,
		}

		var subFields SubFields
		r.Walk(func(f domain.PostField) {
			subFields = append(subFields, f)
		})

		flexible[index] = Layout{
			Name:      layouts[index],
			SubFields: subFields,
		}
	}

	return flexible
}

// HasRows
//
// Determines if the Flexible content has any rows.
func (f Flexible) HasRows() bool {
	return len(f) != 0
}

// SubField
//
// Returns a sub field by key or nil if it wasn't found.
func (s SubFields) SubField(name string) interface{} {
	for _, sub := range s {
		if name == sub.Name {
			return sub.Value
		}
	}
	return nil
}

// First
//
// Returns the first element in the sub fields, or nil if
// the length of the sub fields is zero.
func (s SubFields) First() interface{} {
	if len(s) == 0 {
		return nil
	}
	return s[0]
}

// Last
//
// Returns the last element in the sub fields, or nil if
// the length of the sub fields is zero.
func (s SubFields) Last() interface{} {
	if len(s) == 0 {
		return nil
	}
	return s[len(s)-1]
}"
}
{
file:./api/fields/fields_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *FieldTestSuite) TestService_GetFields() {

	tt := map[string]struct {
		fields []domain.PostField
		mock   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)
		args   []interface{}
		want   interface{}
	}{
		"None": {
			fields: []domain.PostField{},
			args:   nil,
			want:   Fields{},
		},
		"Simple": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "key1", OriginalValue: "1"},
				{Id: 2, Type: "text", Name: "key2", OriginalValue: "2"},
				{Id: 3, Type: "text", Name: "key3", OriginalValue: "3"},
			},
			args: nil,
			want: Fields{
				"key1": "1",
				"key2": "2",
				"key3": "3",
			},
		},
	}
	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetMockService(test.fields, test.mock).GetFields(test.args...))
		})
	}
}

func (t *FieldTestSuite) TestService_Mapper() {

	tt := map[string]struct {
		fields []domain.PostField
		want   interface{}
	}{
		"Simple": {
			fields: []domain.PostField{{Id: 1, Type: "text", Name: "key1", Value: "1"}},
			want:   domain.PostField{Id: 1, Type: "text", Name: "key1", Value: "1"},
		},
		"No Separator": {
			fields: []domain.PostField{{Id: 1, Type: "text", Name: "key1", Key: "map", Value: 1}},
			want:   domain.PostField{Id: 1, Type: "text", Name: "key1", Key: "map", Value: 1},
		},
		"Repeater": {
			fields: []domain.PostField{
				{Type: "repeater", Name: "repeater", OriginalValue: "1"},
				{Type: "text", Name: "text", OriginalValue: "text1", Key: "repeater|0|text"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "repeater|0|text2"},
			},
			want: domain.PostField{Type: "repeater", Name: "repeater", OriginalValue: "1", Value: Repeater{
				Row{
					{Type: "text", Name: "text", OriginalValue: "text1", Value: "text1", Key: "repeater|0|text"},
					{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "repeater|0|text2"},
				}},
			},
		},
		"Flexible": {
			fields: []domain.PostField{
				{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1"},
				{Type: "text", Name: "text1", OriginalValue: "text1", Key: "flex|0|text1"},
				{Type: "text", Name: "text2", OriginalValue: "text2", Key: "flex|0|text2"},
			},
			want: domain.PostField{Id: 1, Type: "flexible", Name: "flex", OriginalValue: "layout1", Value: Flexible{
				{
					Name: "layout1",
					SubFields: SubFields{
						{Type: "text", Name: "text1", OriginalValue: "text1", Value: "text1", Key: "flex|0|text1"},
						{Type: "text", Name: "text2", OriginalValue: "text2", Value: "text2", Key: "flex|0|text2"},
					},
				},
			}},
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(test.fields)

			s.mapper(test.fields, func(field domain.PostField) {
				t.Equal(test.want, field)
			})
		})
	}
}"
}
{
file:./api/fields/common.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/fields/resolve"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cast"
	"strings"
)

// handleArgs
//
// The array of interfaces are presumed to be the following:
// [0] for Post ID, fields are obtained by the post given.
//
// Returns the fields to be modified & processed.
func (s *Service) handleArgs(args []interface{}) []domain.PostField {
	const op = "FieldsService.handleArgs"

	if len(args) == 0 {
		return s.fields
	}

	switch f := args[0].(type) {
	case domain.PostData:
		return f.Fields
	case []domain.PostField:
		return f
	case domain.PostTemplate:
		return f.Fields
	}

	id, err := cast.ToIntE(args[0])
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Invalid argument passed to ", Operation: op, Err: fmt.Errorf("unable to cast post id to integer")},
		}).Error()
		return nil
	}

	return s.getFieldsByPost(id)

}

// getFieldsByPost
//
// Returns the fields by Post with the given ID.
// Logs errors.INVALID if the id failed to be cast to an int.
// Logs if the post if was not found or there was an error obtaining the post.
func (s *Service) getFieldsByPost(id int) []domain.PostField {

	fields, err := s.deps.Store.Fields.GetByPost(id)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return nil
	}

	return fields
}

// findFieldByName
//
// Returns a singular domain.PostField by the given name.
// Returns errors.NOTFOUND if the field does not exist.
func (s *Service) findFieldByName(name string, fields []domain.PostField) (domain.PostField, error) {
	const op = "FieldsService.findFieldByName"
	for _, field := range fields {
		if name == field.Name {
			return field, nil
		}
	}
	return domain.PostField{}, &errors.Error{Code: errors.NOTFOUND, Message: "Field does not exist", Operation: op, Err: fmt.Errorf("no field exists with the name: %s", name)}
}

// walker represents the struct to be passed when resolving
// repeaters and flexible content types.
type walker struct {
	Key    string
	Index  int
	Field  domain.PostField
	Fields []domain.PostField
	*Service
}

// Walk
//
// Constructs a pipe based on the key, name, SEPARATOR and the index
// in order to look up dynamic Flexible content and Repeater
// types. The key `flex|0|repeater|0|text` will be split
// and looked up. If the child value is of type Repeater
// or Flexible the function will call itself meaning
// all values will be resolved.
// The appender func outputs the field to the caller once resolved.
func (r *walker) Walk(appender func(domain.PostField)) {

	pipe := r.Key + r.Field.Name + SEPARATOR + cast.ToString(r.Index)

	for _, v := range r.Fields {

		pipeLen := strings.Split(pipe, SEPARATOR)
		keyLen := strings.Split(v.Key, SEPARATOR)

		if strings.HasPrefix(v.Key, pipe) && len(pipeLen)+1 == len(keyLen) {

			fieldType := v.Type
			if fieldType == "repeater" {
				v.Value = r.resolveRepeater(pipe+SEPARATOR, v, r.Fields)
				appender(v)
				return
			}

			if fieldType == "flexible" {
				v.Value = r.resolveFlexible(pipe+SEPARATOR, v, r.Fields)
				appender(v)
				return
			}

			appender(resolve.Field(v, r.deps))
		}
	}
}"
}
{
file:./api/fields/layout_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *FieldTestSuite) TestService_GetLayout() {

	tt := map[string]struct {
		id     interface{}
		name   string
		layout []domain.FieldGroup
		args   []interface{}
		want   interface{}
		err    bool
	}{
		"Success": {
			id:   1,
			name: "key3",
			layout: []domain.FieldGroup{
				{
					Title:  "test1",
					Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}},
				},
				{
					Title:  "test2",
					Fields: []domain.Field{{Name: "key3"}, {Name: "key4"}},
				},
			},
			args: nil,
			want: domain.Field{Name: "key3"},
		},
		"Error": {
			id:     1,
			name:   "key3",
			layout: nil,
			args:   nil,
			want:   "no groups exist",
			err:    true,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(nil)
			s.layout = test.layout

			got := s.GetLayout(test.name, test.args...)
			if test.err {
				t.Contains(t.logWriter.String(), test.want)
				t.Reset()
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *FieldTestSuite) TestService_GetLayouts() {

	var f []domain.FieldGroup

	fg := []domain.FieldGroup{
		{
			Title:  "test1",
			Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}},
		},
		{
			Title:  "test2",
			Fields: []domain.Field{{Name: "key3"}, {Name: "key4"}},
		},
	}

	tt := map[string]struct {
		id     interface{}
		layout []domain.FieldGroup
		args   []interface{}
		want   interface{}
	}{
		"Success": {
			id:     1,
			layout: fg,
			args:   nil,
			want:   fg,
		},
		"Error": {
			id:     1,
			layout: nil,
			args:   nil,
			want:   f,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetService(nil)
			s.layout = test.layout

			t.Equal(test.want, s.GetLayouts(test.args...))
		})
	}
}

func (t *FieldTestSuite) TestService_HandleLayoutArgs() {

	var f []domain.FieldGroup

	tt := map[string]struct {
		layout []domain.FieldGroup
		args   []interface{}
		mock   func(p *mocks.PostsRepository)
		want   interface{}
	}{
		"Default": {
			layout: []domain.FieldGroup{
				{Title: "test1", Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}}},
			},
			args: nil,
			want: []domain.FieldGroup{
				{Title: "test1", Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}}},
			},
		},
		"1 Args (Post)": {
			layout: nil,
			args:   []interface{}{1},
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, true).Return(domain.PostData{
					Post: domain.Post{Id: 1, Title: "post"},
					Layout: []domain.FieldGroup{
						{Title: "test1", Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}}},
					},
				}, nil)
			},
			want: []domain.FieldGroup{
				{Title: "test1", Fields: []domain.Field{{Name: "key1"}, {Name: "key2"}}},
			},
		},
		"1 Args (Post Error)": {
			layout: nil,
			args:   []interface{}{1},
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, true).Return(domain.PostData{}, fmt.Errorf("error"))
			},
			want: f,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetPostsMockService(nil, test.mock)
			s.layout = test.layout
			t.Equal(test.want, s.handleLayoutArgs(test.args))
		})
	}
}

func (t *FieldTestSuite) TestService_GetLayoutsByPost() {

	tt := map[string]struct {
		id   interface{}
		mock func(p *mocks.PostsRepository)
		want []domain.FieldGroup
	}{
		"Success": {
			id: 1,
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, true).Return(domain.PostData{
					Post:   domain.Post{Id: 1, Title: "post"},
					Layout: []domain.FieldGroup{{Title: "test"}},
				}, nil)
			},
			want: []domain.FieldGroup{{Title: "test"}},
		},
		"Cast Error": {
			id:   noStringer{},
			want: nil,
		},
		"Not Found": {
			id: 1,
			mock: func(p *mocks.PostsRepository) {
				p.On("GetById", 1, true).Return(domain.PostData{}, fmt.Errorf("error"))
			},
			want: nil,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			t.Equal(test.want, t.GetPostsMockService(nil, test.mock).getLayoutByPost(test.id))
		})
	}
}"
}
{
file:./api/fields/field_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
)

func (t *FieldTestSuite) TestService_GetField() {

	tt := map[string]struct {
		fields []domain.PostField
		key    string
		mock   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)
		args   []interface{}
		want   interface{}
		err    bool
	}{
		"Success": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "key1", OriginalValue: "test"},
			},
			key:  "key1",
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {},
			args: nil,
			want: "test",
		},
		"No Field": {
			fields: nil,
			key:    "wrongval",
			mock:   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {},
			args:   nil,
			want:   "no field exists with the name: wrongval",
			err:    true,
		},
		"Post": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "key1", OriginalValue: "test"},
			},
			key: "key2",
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 2).Return([]domain.PostField{{Id: 2, Type: "text", Name: "key2", OriginalValue: "test"}}, nil)
			},
			args: []interface{}{2},
			want: "test",
			err:  false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetMockService(test.fields, test.mock)

			got := s.GetField(test.key, test.args...)
			if test.err {
				t.Contains(t.logWriter.String(), test.want)
				t.Reset()
				return
			}

			t.Equal(test.want, got)
		})
	}
}

func (t *FieldTestSuite) TestService_GetFieldObject() {

	tt := map[string]struct {
		fields []domain.PostField
		key    string
		mock   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)
		args   []interface{}
		want   interface{}
		err    bool
	}{
		"Success": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "key1", OriginalValue: "test"},
			},
			key:  "key1",
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {},
			args: nil,
			want: domain.PostField{Id: 1, Type: "text", Name: "key1", OriginalValue: "test", Value: "test"},
			err:  false,
		},
		"No Field": {
			fields: nil,
			key:    "wrongval",
			mock:   func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {},
			args:   nil,
			want:   "no field exists with the name: wrongval",
			err:    true,
		},
		"Post": {
			fields: []domain.PostField{
				{Id: 1, Type: "text", Name: "key1"},
			},
			key: "key2",
			mock: func(f *mocks.FieldsRepository, c *mocks.CategoryRepository) {
				f.On("GetByPost", 2).Return([]domain.PostField{{Id: 2, Type: "text", Name: "key2", OriginalValue: "test"}}, nil)
			},
			args: []interface{}{2},
			want: domain.PostField{Id: 2, Type: "text", Name: "key2", OriginalValue: "test", Value: "test"},
			err:  false,
		},
	}

	for name, test := range tt {
		t.Run(name, func() {
			s := t.GetMockService(test.fields, test.mock)

			got := s.GetFieldObject(test.key, test.args...)
			if test.err {
				t.Contains(t.logWriter.String(), test.want)
				t.Reset()
				return
			}

			t.Equal(test.want, got)

		})
	}
}"
}
{
file:./api/fields/suite_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"bytes"
	"github.com/ainsleyclark/verbis/api/deps"
	"github.com/ainsleyclark/verbis/api/domain"
	mocks "github.com/ainsleyclark/verbis/api/mocks/models"
	"github.com/ainsleyclark/verbis/api/models"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/suite"
	"testing"
)

type FieldTestSuite struct {
	suite.Suite
	logWriter bytes.Buffer
}

type noStringer struct{}

func TestFields(t *testing.T) {
	suite.Run(t, new(FieldTestSuite))
}

func (t *FieldTestSuite) BeforeTest(suiteName, testName string) {
	b := bytes.Buffer{}
	t.logWriter = b
	log.SetOutput(&t.logWriter)
}

func (t *FieldTestSuite) Reset() {
	t.logWriter.Reset()
}

func (t *FieldTestSuite) GetMockService(fields []domain.PostField, fnc func(f *mocks.FieldsRepository, c *mocks.CategoryRepository)) *Service {
	fieldsMock := &mocks.FieldsRepository{}
	categoryMock := &mocks.CategoryRepository{}

	if fnc != nil {
		fnc(fieldsMock, categoryMock)
	}

	s := t.GetService(fields)
	s.deps = &deps.Deps{
		Store: &models.Store{
			Categories: categoryMock,
			Fields:     fieldsMock,
		},
	}

	return s
}

func (t *FieldTestSuite) GetPostsMockService(fields []domain.PostField, fnc func(p *mocks.PostsRepository)) *Service {
	postsMocks := &mocks.PostsRepository{}

	if fnc != nil {
		fnc(postsMocks)
	}

	s := t.GetService(fields)
	s.deps = &deps.Deps{
		Store: &models.Store{
			Posts: postsMocks,
		},
	}

	return s
}

func (t *FieldTestSuite) GetTypeMockService(fnc func(c *mocks.CategoryRepository, m *mocks.MediaRepository, p *mocks.PostsRepository, u *mocks.UserRepository)) *Service {

	categoryMock := &mocks.CategoryRepository{}
	mediaMock := &mocks.MediaRepository{}
	postsMock := &mocks.PostsRepository{}
	userMock := &mocks.UserRepository{}

	if fnc != nil {
		fnc(categoryMock, mediaMock, postsMock, userMock)
	}

	s := t.GetService(nil)
	s.deps = &deps.Deps{
		Store: &models.Store{
			Categories: categoryMock,
			Media:      mediaMock,
			Posts:      postsMock,
			User:       userMock,
		},
	}

	return s
}

func (t *FieldTestSuite) GetService(fields []domain.PostField) *Service {
	return &Service{
		fields: fields,
		deps:   &deps.Deps{},
	}
}"
}
{
file:./api/fields/repeater.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fields

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/errors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cast"
)

// Repeater represents the collection of rows used
// for the repeater function in templates.
type Repeater []Row

// Row represents the collection of the repeaters
// containing `sub_fields.
type Row []domain.PostField

// GetRepeater
//
// Returns the collection of children from the given key and returns
// a new Repeater.
//
// Returns errors.NOTFOUND if the field was not found by the given key.
// Returns errors.INVALID if the field type is not a repeater or the name could not be cast.
func (s *Service) GetRepeater(input interface{}, args ...interface{}) Repeater {
	const op = "FieldsService.GetRepeater"

	repeater, ok := input.(Repeater)
	if ok {
		return repeater
	}

	name, err := cast.ToStringE(input)
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Could not cast input to string", Operation: op, Err: err},
		}).Error()
		return nil
	}

	fields := s.handleArgs(args)

	field, err := s.findFieldByName(name, fields)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error()
		return nil
	}

	if field.Type != "repeater" {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Field is not a repeater", Operation: op, Err: fmt.Errorf("field with the name: %s, is not a repeater", name)},
		}).Error()
		return nil
	}

	return s.resolveRepeater("", field, fields)
}

// getFieldChildren
//
// Loops through the given slice of domain.PostField and compares the
// uuid passed with the field's parent UUID.
// It's not necessary to use a database call for this look up, as we will
// be looping through them anyway to append and format the fields.
// Returns the sorted slice of fields.
func (s *Service) resolveRepeater(key string, field domain.PostField, fields []domain.PostField) Repeater {
	const op = "FieldsService.resolveRepeater"

	amount, err := field.OriginalValue.Int()
	if err != nil {
		log.WithFields(log.Fields{
			"error": &errors.Error{Code: errors.INVALID, Message: "Unable to cast repeater value to integer", Operation: op, Err: err},
		}).Error()
		return Repeater{}
	}

	var repeater = make(Repeater, amount)
	for index := 0; index < len(repeater); index++ {

		r := walker{
			Key:     key,
			Index:   index,
			Field:   field,
			Fields:  fields,
			Service: s,
		}

		var row Row
		r.Walk(func(f domain.PostField) {
			row = append(row, f)
		})

		repeater[index] = row
	}

	return repeater
}

// HasRows
//
// Determines if the Repeater has any rows.
func (r Repeater) HasRows() bool {
	return len(r) != 0
}

// SubField
//
// Returns a sub field by key or nil if it wasn't found.
func (r Row) SubField(name string) interface{} {
	for _, sub := range r {
		if name == sub.Name {
			return sub.Value
		}
	}
	return nil
}

// HasField
//
// Returns true if a field exists within the row.
func (r Row) HasField(name string) bool {
	for _, sub := range r {
		if name == sub.Name {
			return true
		}
	}
	return false
}

// First
//
// Returns the first element in the repeater, or nil if
// the length of the repeater is zero.
func (r Row) First() interface{} {
	if len(r) == 0 {
		return nil
	}
	return r[0]
}

// Last
//
// Returns the last element in the repeater, or nil if
// the length of the repeater is zero.
func (r Row) Last() interface{} {
	if len(r) == 0 {
		return nil
	}
	return r[len(r)-1]
}"
}
{
file:./api/errors/errors_test.go
contents:
"package errors

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestError_Error(t *testing.T) {

	tt := map[string]struct {
		input *Error
		want  string
	}{
		"Normal": {
			&Error{Code: INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("err")},
			"op: err",
		},
		"Nil Operation": {
			&Error{Code: INTERNAL, Message: "test", Operation: "", Err: fmt.Errorf("err")},
			"err",
		},
		"Nil Err": {
			&Error{Code: INTERNAL, Message: "test", Operation: "", Err: nil},
			"<internal> test",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.input.Error(), test.want)
		})
	}
}

func TestError_Code(t *testing.T) {

	tt := map[string]struct {
		input error
		want  string
	}{
		"Normal": {
			&Error{Code: INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("err")},
			"internal",
		},
		"Nil Input": {
			nil,
			"",
		},
		"Nil Code": {
			&Error{Code: "", Message: "test", Operation: "op", Err: fmt.Errorf("err")},
			"internal",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.want, Code(test.input))
		})
	}
}

func Test_Message(t *testing.T) {

	tt := map[string]struct {
		input error
		want  string
	}{
		"Normal": {
			&Error{Code: INTERNAL, Message: "test", Operation: "op", Err: fmt.Errorf("err")},
			"test",
		},
		"Nil Input": {
			nil,
			"",
		},
		"Nil Message": {
			&Error{Code: "", Message: "", Operation: "op", Err: fmt.Errorf("err")},
			GlobalError,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.want, Message(test.input))
		})
	}
}"
}
{
file:./api/errors/errors.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package errors

import (
	"bytes"
	"fmt"
)

// Application error codes.
const (
	CONFLICT = "conflict"  // Action cannot be performed
	INTERNAL = "internal"  // Internal error
	INVALID  = "invalid"   // Validation failed
	NOTFOUND = "not_found" // Entity does not exist
	TEMPLATE = "template"  // Templating error
)

// Global Error message when no message has been found.
const GlobalError = "An internal error has occurred."

// Error defines a standard application error.
type Error struct {
	Code      string `json:"code"`
	Message   string `json:"message"`
	Operation string `json:"operation"`
	Err       error  `json:"error"`
}

// Error
//
// Returns the string representation of the error message.
func (e *Error) Error() string {
	var buf bytes.Buffer

	// Print the current operation in our stack, if any.
	if e.Operation != "" {
		fmt.Fprintf(&buf, "%s: ", e.Operation)
	}

	// If wrapping an error, print its Error() message.
	// Otherwise print the error code & message.
	if e.Err != nil {
		buf.WriteString(e.Err.Error())
	} else {
		if e.Code != "" {
			_, _ = fmt.Fprintf(&buf, "<%s> ", e.Code)
		}
		buf.WriteString(e.Message)
	}

	return buf.String()
}

// ErrorCode
//
// Returns the code of the root error, if available.
// Otherwise returns INTERNAL.
func Code(err error) string {
	if err == nil {
		return ""
	} else if e, ok := err.(*Error); ok && e.Code != "" {
		return e.Code
	} else if ok && e.Err != nil {
		return Code(e.Err)
	}
	return INTERNAL
}

// ErrorMessage
//
// Returns the human-readable message of the error, if
// available. Otherwise returns a generic error
// message.
func Message(err error) string {
	if err == nil {
		return ""
	} else if e, ok := err.(*Error); ok && e.Message != "" {
		return e.Message
	} else if ok && e.Err != nil {
		return Message(e.Err)
	}
	return GlobalError
}"
}
{
file:./api/domain/fields.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import "github.com/google/uuid"

// FieldGroup defines a group of JSON fields
type FieldGroup struct {
	UUID      uuid.UUID         `json:"uuid"`
	Title     string            `json:"title"`
	Fields    []Field           `json:"fields,omitempty"`
	Locations [][]FieldLocation `json:"location,omitempty"`
}

// Field defines an individual field type
type Field struct {
	UUID         uuid.UUID                  `json:"uuid"`
	Label        string                     `json:"label"`
	Name         string                     `json:"name"`
	Type         string                     `json:"type"`
	Instructions string                     `json:"instructions"`
	Required     bool                       `json:"required"`
	Logic        *[][]FieldConditionalLogic `json:"conditional_logic"`
	Wrapper      *FieldWrapper              `json:"wrapper"`
	Options      map[string]interface{}     `json:"options"`
	SubFields    *[]Field                   `json:"sub_fields,omitempty"`
	Layouts      map[string]FieldLayout     `json:"layouts,omitempty"`
}

type FieldLayout struct {
	UUID      uuid.UUID `json:"uuid"`
	Name      string    `json:"name"`
	Label     string    `json:"label"`
	Display   string    `json:"didpslay"`
	SubFields *[]Field  `json:"sub_fields,omitempty"`
}

type FieldFilter struct {
	Resource     string `json:"resource"`
	PageTemplate string `json:"template"`
	Layout       string `json:"layout"`
	Category     string `json:"category"`
}

// FieldLocation defines where the FieldGroup will appear
type FieldLocation struct {
	Param    string
	Operator string
	Value    string
}

type FieldWrapper struct {
	Width int `json:"width"`
}

type FieldConditionalLogic struct {
	Field    string `json:"field"`
	Operator string `json:"operator"`
	Value    string `json:"value"`
}"
}
{
file:./api/domain/media.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"time"
)

// Media defines the media entity for interacting with the database
// and sending data back
type Media struct {
	Id          int        `db:"id" json:"id"`
	UUID        uuid.UUID  `db:"uuid" json:"uuid"`
	Url         string     `db:"url" json:"url"`
	Title       string     `db:"title" json:"title"`
	Alt         string     `db:"alt" json:"alt"`
	Description string     `db:"description" json:"description"`
	FilePath    string     `db:"file_path" json:"-"`
	FileSize    int        `db:"file_size" json:"file_size"`
	FileName    string     `db:"file_name" json:"file_name"`
	Sizes       MediaSizes `db:"sizes" json:"sizes"`
	Type        string     `db:"type" json:"type"`
	UserID      int        `db:"user_id" json:"user_id"`
	CreatedAt   time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time  `db:"updated_at" json:"updated_at"`
}

type MediaSize struct {
	UUID     uuid.UUID `db:"uuid" json:"uuid"`
	Url      string    `db:"url" json:"url"`
	Name     string    `db:"name" json:"name"`
	SizeName string    `db:"size_name" json:"size_name"`
	FileSize int       `db:"file_size" json:"file_size"`
	Width    int       `db:"width" json:"width"`
	Height   int       `db:"height" json:"height"`
	Crop     bool      `db:"crop" json:"crop"`
}

type MediaSizeOptions struct {
	Name   string `db:"name" json:"name" binding:"required,numeric"`
	Width  int    `db:"width" json:"width" binding:"required,numeric"`
	Height int    `db:"height" json:"height" binding:"required,numeric"`
	Crop   bool   `db:"crop" json:"crop"`
}

type MediaSizes map[string]MediaSize

func (m MediaSizes) Scan(value interface{}) error {
	if value == nil {
		return nil
	}
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("scan not supported")
	}
	if bytes == nil {
		return nil
	}
	return json.Unmarshal(bytes, &m)
}

func (m MediaSizes) Value() (driver.Value, error) {
	if len(m) == 0 {
		return nil, nil
	}
	j, err := json.Marshal(m)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal to domain.MediaSizes")
	}

	return driver.Value(j), nil
}"
}
{
file:./api/domain/user.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"github.com/google/uuid"
	"time"
)

type User struct {
	UserPart
	Password      string     `db:"password" json:"password,omitempty" binding:""`
	Token         string     `db:"token" json:"token,omitempty"`
	TokenLastUsed *time.Time `db:"token_last_used" json:"token_last_used,omitempty"`
}

// UserPart defines the User with non-sensitive information
type UserPart struct {
	Id               int        `db:"id" json:"id"`
	UUID             uuid.UUID  `db:"uuid" json:"uuid"`
	FirstName        string     `db:"first_name" json:"first_name" binding:"required,max=150,alpha"`
	LastName         string     `db:"last_name" json:"last_name" binding:"required,max=150,alpha"`
	Email            string     `db:"email" json:"email" binding:"required,email,max=255"`
	Website          *string    `db:"website" json:"website,omitempty" binding:"omitempty,url"`
	Facebook         *string    `db:"facebook" json:"facebook"`
	Twitter          *string    `db:"twitter" json:"twitter"`
	Linkedin         *string    `db:"linked_in" json:"linked_in"`
	Instagram        *string    `db:"instagram" json:"instagram"`
	Biography        *string    `db:"biography" json:"biography"`
	Role             UserRole   `db:"roles" json:"role"`
	ProfilePictureID *int       `db:"profile_picture_id" json:"profile_picture_id"`
	EmailVerifiedAt  *time.Time `db:"email_verified_at" json:"email_verified_at"`
	CreatedAt        time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time  `db:"updated_at" json:"updated_at"`
}

type Users []User

type UsersParts []UserPart

func (u Users) HideCredentials() UsersParts {
	var p UsersParts
	for _, v := range u {
		p = append(p, v.HideCredentials())
	}
	return p
}

type UserCreate struct {
	User
	Password        string `db:"password" json:"password,omitempty" binding:"required,min=8,max=60"`
	ConfirmPassword string `json:"confirm_password,omitempty" binding:"required,eqfield=Password,required"`
}

type UserPasswordReset struct {
	DBPassword      string `json:"-" binding:""`
	CurrentPassword string `json:"current_password" binding:"required,password"`
	NewPassword     string `json:"new_password" binding:"required,min=8,max=60"`
	ConfirmPassword string `json:"confirm_password" binding:"eqfield=NewPassword,required"`
}

type UserRole struct {
	Id          int    `db:"id" json:"id" binding:"required,numeric"`
	Name        string `db:"name" json:"name"`
	Description string `db:"description" json:"description"`
}

func (u *User) HidePassword() {
	u.Password = ""
}

func (u *User) HideCredentials() UserPart {
	return UserPart{
		Id:               u.Id,
		UUID:             u.UUID,
		FirstName:        u.FirstName,
		LastName:         u.LastName,
		Email:            u.Email,
		Website:          u.Website,
		Facebook:         u.Facebook,
		Twitter:          u.Twitter,
		Linkedin:         u.Linkedin,
		Instagram:        u.Instagram,
		Biography:        u.Biography,
		Role:             u.Role,
		ProfilePictureID: u.ProfilePictureID,
		EmailVerifiedAt:  u.EmailVerifiedAt,
		CreatedAt:        u.CreatedAt,
		UpdatedAt:        u.UpdatedAt,
	}
}"
}
{
file:./api/domain/auth.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"time"
)

// Auth
type Auth struct{}

// PasswordReset defines the struct for interacting with the
// password resets table.
type PasswordReset struct {
	Id        int       `db:"id" json:"-"`
	Email     string    `db:"email" json:"email" binding:"required,email"`
	Token     string    `db:"token" json:"token" binding:"required,email"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type Login struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required"`
}

type ResetPassword struct {
	NewPassword     string `json:"new_password" binding:"required,min=8,max=60"`
	ConfirmPassword string `json:"confirm_password" binding:"eqfield=NewPassword,required"`
	Token           string `db:"token" json:"token" binding:"required"`
}

type SendResetPassword struct {
	Email string `json:"email" binding:"required,email"`
}"
}
{
file:./api/domain/options.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"encoding/json"
)

type OptionsDB map[string]interface{}

type OptionDB struct {
	ID    int             `db:"id" json:"id"`
	Name  string          `db:"option_name" json:"option_name" binding:"required"`
	Value json.RawMessage `db:"option_value" json:"option_value" binding:"required"`
}

type Options struct {
	// Site
	SiteTitle       string `json:"site_title" binding:"required"`
	SiteDescription string `json:"site_description" binding:"required"`
	SiteLogo        string `json:"site_logo" binding:"required"`
	SiteUrl         string `json:"site_url" binding:"required,url"`
	// General
	GeneralLocale string `json:"general_locale" binding:"required"`
	// Contact
	ContactEmail     string `json:"contact_email" binding:"omitempty,email"`
	ContactTelephone string `json:"contact_telephone"`
	ContactAddress   string `json:"contact_address"`
	// Social
	SocialFacebook  string `json:"social_facebook" binding:"omitempty,url"`
	SocialTwitter   string `json:"social_twitter" binding:"omitempty,url"`
	SocialInstagram string `json:"social_instagram" binding:"omitempty,url"`
	SocialLinkedIn  string `json:"social_linkedin" binding:"omitempty,url"`
	SocialYoutube   string `json:"social_youtube" binding:"omitempty,url"`
	SocialPinterest string `json:"social_pinterest" binding:"omitempty,url"`
	// Code Injection
	CodeInjectionHead string `json:"codeinjection_head" binding:"omitempty"`
	CodeInjectionFoot string `json:"codeinjection_foot" binding:"omitempty"`
	// Meta
	MetaTitle               string `json:"meta_title" binding:"omitempty"`
	MetaDescription         string `json:"meta_description" binding:"omitempty"`
	MetaFacebookTitle       string `json:"meta_facebook_title" binding:"omitempty"`
	MetaFacebookDescription string `json:"meta_facebook_description" binding:"omitempty"`
	MetaFacebookImageId     int    `json:"meta_facebook_image_id" binding:"numeric"`
	MetaTwitterTitle        string `json:"meta_twitter_title" binding:"omitempty"`
	MetaTwitterDescription  string `json:"meta_twitter_description" binding:"omitempty"`
	MetaTwitterImageId      int    `json:"meta_twitter_image_id" binding:"omitempty,numeric"`
	// SEO
	SeoPublic           bool       `json:"seo_public"`
	SeoSitemapServe     bool       `json:"seo_sitemap_serve"`
	SeoSitemapRedirects bool       `json:"seo_sitemap_redirects"`
	SeoSitemapExcluded  []string   `json:"seo_sitemap_excluded"`
	SeoEnforceSlash     bool       `json:"seo_enforce_slash"`
	SeoRobotsServe      bool       `json:"seo_robots_serve"`
	SeoRobots           string     `json:"seo_robots"`
	SeoRedirects        []Redirect `json:"seo_redirects"`
	// Media
	MediaCompression     int        `json:"media_compression" binding:"required"`
	MediaConvertWebP     bool       `json:"media_convert_webp"`
	MediaServeWebP       bool       `json:"media_serve_webp"`
	MediaUploadMaxSize   int        `json:"media_upload_max_size" binding:"numeric"`
	MediaUploadMaxWidth  int        `json:"media_upload_max_width" binding:"numeric"`
	MediaUploadMaxHeight int        `json:"media_upload_max_height" binding:"numeric"`
	MediaOrganiseDate    bool       `json:"media_organise_year_month"`
	MediaSizes           MediaSizes `json:"media_images_sizes"`
	// Server Cache
	CacheServerTemplates bool `json:"cache_server_templates"`
	CacheServerAssets    bool `json:"cache_server_assets"`
	CacheServerUploads   bool `json:"cache_server_uploads"`
	CacheServerFields    bool `json:"cache_server_field_layouts"`
	// Frontend Caching
	CacheFrontend          bool     `json:"cache_frontend"`
	CacheFrontendRequest   string   `json:"cache_frontend_request"`
	CacheFrontendSeconds   int64    `json:"cache_frontend_seconds"`
	CacheFrontendExtension []string `json:"cache_frontend_extensions"`
	// Gzip
	Gzip                   bool     `json:"gzip"`
	GzipCompression        string   `json:"gzip_compression"`
	GzipUsePaths           bool     `json:"gzip_use_paths"`
	GzipExcludedExtensions []string `json:"gzip_excluded_extensions"`
	GzipExcludedPaths      []string `json:"gzip_excluded_paths"`
	// Minify
	MinifyHTML bool `json:"minify_html"`
	MinifyJS   bool `json:"minify_js"`
	MinifyCSS  bool `json:"minify_css"`
	MinifySVG  bool `json:"minify_svg"`
	MinifyJSON bool `json:"minify_json"`
	MinifyXML  bool `json:"minify_xml"`
	// Forms
	FormSendEmailAddresses []string `json:"form_send_email_addresses"`
	FormFromEmailAddress   string   `json:"form_from_email_addresses"`
	FormIncludeLogo        bool     `json:"form_email_include_logo"`
	FormEmailDisclosure    string   `json:"form_email_disclosure"`
}

type Redirect struct {
	To   string `json:"to" binding:"required"`
	From string `json:"from" binding:"required"`
	Code int    `json:"code" binding:"required,numeric"`
}"
}
{
file:./api/domain/types.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

type DBMap map[string]interface{}

func (m DBMap) Scan(value interface{}) error {
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("scan not supported")
	}
	if bytes == nil || value == nil {
		return nil
	}
	return json.Unmarshal(bytes, &m)
}

func (m DBMap) Value() (driver.Value, error) {
	j, err := json.Marshal(m)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal to map[string]interface")
	}
	return driver.Value(j), nil
}"
}
{
file:./api/domain/posts.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/google/uuid"
	"strconv"
	"strings"
	"time"
)

type PostData struct {
	Post     `json:"post"`
	Author   UserPart     `json:"author"`
	Category *Category    `json:"category"`
	Layout   []FieldGroup `json:"layout,omitempty"`
	Fields   []PostField  `json:"fields,omitempty"`
}

type Post struct {
	Id                int         `db:"id" json:"id" binding:"numeric"`
	UUID              uuid.UUID   `db:"uuid" json:"uuid"`
	Slug              string      `db:"slug" json:"slug" binding:"required,max=150"`
	Title             string      `db:"title" json:"title" binding:"required,max=500"`
	Status            string      `db:"status" json:"status,omitempty"`
	Resource          *string     `db:"resource" json:"resource,max=150"`
	PageTemplate      string      `db:"page_template" json:"page_template,omitempty" binding:"max=150"`
	PageLayout        string      `db:"layout" json:"layout,omitempty" binding:"max=150"`
	CodeInjectionHead *string     `db:"codeinjection_head" json:"codeinjection_head,omitempty"`
	CodeInjectionFoot *string     `db:"codeinjection_foot" json:"codeinjection_foot,omitempty"`
	UserId            int         `db:"user_id" json:"-"`
	PublishedAt       *time.Time  `db:"published_at" json:"published_at"`
	CreatedAt         *time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt         *time.Time  `db:"updated_at" json:"updated_at"`
	SeoMeta           PostOptions `db:"options" json:"options"`
}

// TplPost defines the Post data for
// templates.
type PostTemplate struct {
	Post
	Author   UserPart
	Category *Category
	Fields   []PostField
}

func (p *PostData) Tpl() PostTemplate {
	return PostTemplate{
		Post:     p.Post,
		Author:   p.Author,
		Category: p.Category,
		Fields:   p.Fields,
	}
}

type PostCreate struct {
	Post
	Author   int         `json:"author,omitempty" binding:"numeric"`
	Category *int        `json:"category,omitempty" binding:"omitempty,numeric"`
	Fields   []PostField `json:"fields,omitempty"`
}

type PostField struct {
	Id            int         `db:"id" json:"-"`
	PostId        int         `db:"post_id" json:"-"`
	UUID          uuid.UUID   `db:"uuid" json:"uuid" binding:"required"`
	Type          string      `db:"type" json:"type"`
	Name          string      `db:"name" json:"name"`
	Key           string      `db:"field_key" json:"key"`
	Value         interface{} `json:"-"`
	OriginalValue FieldValue  `db:"value" json:"value"`
}

type FieldValue string

func (f PostField) TypeIsInArray(arr []string) bool {
	for _, v := range arr {
		if v == f.Type {
			return true
		}
	}
	return false
}

func (f FieldValue) Array() []string {
	return strings.Split(string(f), ",")
}

func (f FieldValue) IsEmpty() bool {
	return string(f) == ""
}

func (f FieldValue) String() string {
	return string(f)
}

func (f FieldValue) Int() (int, error) {
	const op = "FieldValue.Int"
	i, err := strconv.Atoi(f.String())
	if err != nil {
		return 0, &errors.Error{Code: errors.INVALID, Message: "Unable to cast FieldValue to an integer", Operation: op, Err: err}
	}
	return i, nil
}

type PostOptions struct {
	Id       int       `json:"-"`
	PageId   int       `json:"-" binding:"required|numeric"`
	Meta     *PostMeta `db:"meta" json:"meta"`
	Seo      *PostSeo  `db:"seo" json:"seo"`
	EditLock string    `db:"edit_lock" json:"edit_lock"`
}

type PostMeta struct {
	Title       string       `json:"title,omitempty"`
	Description string       `json:"description,omitempty"`
	Twitter     PostTwitter  `json:"twitter,omitempty"`
	Facebook    PostFacebook `json:"facebook,omitempty"`
}

type PostTwitter struct {
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
	ImageId     int    `json:"image_id,numeric,omitempty"`
}

type PostFacebook struct {
	Title       string `json:"title,omitempty"`
	Description string `json:"description,omitempty"`
	ImageId     int    `json:"image_id,numeric,omitempty"`
}

func (m *PostMeta) Scan(value interface{}) error {
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("scan not supported")
	}
	if bytes == nil || value == nil {
		return nil
	}
	return json.Unmarshal(bytes, &m)
}

func (m *PostMeta) Value() (driver.Value, error) {
	j, err := json.Marshal(m)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal to domain.PostMeta")
	}
	return driver.Value(j), nil
}

type PostSeo struct {
	Public         bool   `json:"public"`
	ExcludeSitemap bool   `json:"exclude_sitemap"`
	Canonical      string `json:"canonical"`
}

func (m *PostSeo) Scan(value interface{}) error {
	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("scan not supported")
	}
	if bytes == nil || value == nil {
		return nil
	}
	return json.Unmarshal(bytes, &m)
}

func (m *PostSeo) Value() (driver.Value, error) {
	j, err := json.Marshal(m)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal to domain.PostSeo")
	}
	return driver.Value(j), nil
}"
}
{
file:./api/domain/categories.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"github.com/google/uuid"
	"time"
)

// Category defines the categories for posts
type Category struct {
	Id          int       `db:"id" json:"id"`
	UUID        uuid.UUID `db:"uuid" json:"uuid"`
	Slug        string    `db:"slug" json:"slug" binding:"required,max=150"`
	Name        string    `db:"name" json:"name" binding:"required,max=150"`
	Description *string   `db:"description" json:"description,max=500"`
	Resource    string    `db:"resource" json:"resource" binding:"required,max=150"`
	ParentId    *int      `db:"parent_id" json:"parent_id" binding:"omitempty,numeric"`
	ArchiveId   *int      `db:"archive_id" json:"archive_id" binding:"omitempty,numeric"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
}"
}
{
file:./api/domain/site.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

// Site
type Site struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Logo        string `json:"logo"`
	Url         string `json:"url"`
	Version     string `json:"version"`
}

// Theme
type ThemeConfig struct {
	Theme         Theme               `yaml:"theme" json:"theme"`
	Resources     map[string]Resource `yaml:"resources" json:"resources"`
	AssetsPath    string              `yaml:"assets_path" json:"assets_path"`
	FileExtension string              `yaml:"file_extension" json:"file_extension"`
	TemplateDir   string              `yaml:"template_dir" json:"template_dir"`
	LayoutDir     string              `yaml:"layout_dir" json:"layout_dir"`
	Editor        Editor              `yaml:"editor" json:"editor"`
}

type Theme struct {
	Title       string `yaml:"title" json:"title"`
	Description string `yaml:"description" json:"description"`
	Version     string `yaml:"version" json:"version"`
}

// Resources
type Resources struct {
	Resource []Resource `json:"resources"`
}

type Resource struct {
	Name             string `yaml:"name" json:"name"`
	FriendlyName     string `yaml:"friendly_name" json:"friendly_name"`
	SingularName     string `yaml:"singular_name" json:"singular_name"`
	Slug             string `yaml:"slug" json:"slug"`
	Icon             string `yaml:"icon" json:"icon"`
	Hidden           bool   `yaml:"hidden" json:"hidden"`
	HideCategorySlug bool   `yaml:"hide_category_slug" json:"hide_category_slug"`
}

// Templates
type Templates struct {
	Template []map[string]interface{} `json:"templates"`
}

// Layouts
type Layouts struct {
	Layout []map[string]interface{} `json:"layouts"`
}

// Editor
type Editor struct {
	Modules []string               `yaml:"modules" json:"modules"`
	Options map[string]interface{} `yaml:"options" json:"options"`
}"
}
{
file:./api/domain/forms.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package domain

import (
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx/types"
	"strings"
	"time"
)

// Form defines the form for sending form the API.
type Form struct {
	Id           int           `db:"id" json:"id" binding:"numeric"`
	UUID         uuid.UUID     `db:"uuid" json:"uuid"`
	Name         string        `db:"name" json:"name" binding:"required,max=500"`
	Fields       []FormField   `db:"fields" json:"fields"`
	EmailSend    types.BitBool `db:"email_send" json:"email_send"`
	EmailMessage string        `db:"email_message" json:"email_message"`
	EmailSubject string        `db:"email_subject" json:"email_subject"`
	Recipients   string        `db:"recipients" json:"recipients"`
	StoreDB      types.BitBool `db:"store_db" json:"store_db"`
	Body         interface{}   `db:"-" json:"-"`
	CreatedAt    *time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt    *time.Time    `db:"updated_at" json:"updated_at"`
}

// FormField defines a field from the pivot table.
type FormField struct {
	Id         int           `db:"id" json:"id" binding:"numeric"`
	UUID       uuid.UUID     `db:"uuid" json:"uuid"`
	FormId     int           `db:"form_id" json:"-"`
	Key        string        `db:"key" json:"key" binding:"required"`
	Label      FormLabel     `db:"label" json:"label" binding:"required"`
	Type       string        `db:"type" json:"type" binding:"required"`
	Validation *string       `db:"validation" json:"validation"`
	Required   types.BitBool `db:"required" json:"required"`
	Options    DBMap         `db:"options" json:"options"`
}

// FormSubmission defines a submission of the form.
type FormSubmission struct {
	Id        int        `db:"id" json:"id" binding:"numeric"`
	UUID      uuid.UUID  `db:"uuid" json:"uuid"`
	FormId    int        `db:"form_id" json:"form_id"`
	Fields    DBMap      `db:"fields" json:"fields"`
	IpAddress string     `db:"ip_address" json:"ip_address"`
	UserAgent string     `db:"user_agent" json:"user_agent"`
	SentAt    *time.Time `db:"sent_at" json:"sent_at"`
}

// FormLabel defines the label/name for form fields.
type FormLabel string

// GetRecipients splits the recipients string and returns
// a slice of email addresses.
func (f *Form) GetRecipients() []string {
	return strings.Split(f.Recipients, ",")
}

// Name converts the label to a dynamic-struct friendly name.
func (f FormLabel) Name() string {
	s := strings.ReplaceAll(string(f), " ", "")
	return strings.Title(s)
}

// Stringer on the FormLabel type
func (f FormLabel) String() string {
	return string(f)
}"
}
{
file:./api/helpers/encryption/token.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package encryption

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	log "github.com/sirupsen/logrus"
	"golang.org/x/crypto/bcrypt"
	"math/rand"
	"strconv"
	"time"
)

// GenerateUserToken generates a new user token based on name & email.
func GenerateUserToken(name string, email string) string {
	emailHash := MD5Hash(email)
	hash := MD5Hash(name + time.Now().String() + "3de" + strconv.Itoa(rand.Intn(143-0)+0) + emailHash)
	token := strconv.Itoa(rand.Intn(143-0)+0) + hash + strconv.Itoa(rand.Intn(143-0)+0)
	return token
}

// GenerateEmailToken generates a token based on the email given.
// Returns errors.INTERNAL if the bcrypt failed to generate
// from password.
func GenerateEmailToken(email string) (string, error) {
	const op = "encryption.GenerateEmailToken"
	hash, err := bcrypt.GenerateFromPassword([]byte(email), bcrypt.DefaultCost)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not generate the email token with the email: %s", email), Operation: op, Err: err}
	}
	return MD5Hash(string(hash)), nil
}

// GenerateSessionToken returns a session unique token based
// on the provided email string
func GenerateSessionToken(email string) string {
	const op = "encryption.GenerateSessionToken"
	hash, err := bcrypt.GenerateFromPassword([]byte(email), bcrypt.DefaultCost)
	if err != nil {
		log.WithFields(log.Fields{
			"error": errors.Error{Code: errors.INTERNAL, Message: "Could not generate the session token.", Operation: op, Err: err},
		}).Error()
	}
	hasher := md5.New()
	hasher.Write(hash)
	return hex.EncodeToString(hasher.Sum(nil))
}"
}
{
file:./api/helpers/encryption/hash.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package encryption

import (
	"crypto/md5"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"golang.org/x/crypto/bcrypt"
	"math/rand"
)

// GenerateRandomHash generates a unique random md5 hash
// Returns errors.INTERNAL if the hash failed to generate.
func GenerateRandomHash() (string, error) {
	const op = "encryption.GenerateRandomHash"
	hash, err := bcrypt.GenerateFromPassword([]byte(newSHA1Hash(36)), bcrypt.DefaultCost)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: "Could not generate a random hash", Operation: op, Err: err}
	}
	hasher := md5.New()
	hasher.Write(hash)
	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// newSHA1Hash generates a new SHA1 hash based on
// a random number of characters.
func newSHA1Hash(n ...int) string {
	noRandomCharacters := 32

	if len(n) > 0 {
		noRandomCharacters = n[0]
	}

	randString := RandomString(int64(noRandomCharacters), true)

	hash := sha1.New()
	hash.Write([]byte(randString))
	bs := hash.Sum(nil)

	return fmt.Sprintf("%x", bs)
}

// randomString generates a random string of n length
func RandomString(n int64, numeric bool) string {
	var characterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	if !numeric {
		characterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	}
	b := make([]rune, n)
	for i := range b {
		b[i] = characterRunes[rand.Intn(len(characterRunes))]
	}
	return string(b)
}"
}
{
file:./api/helpers/encryption/md5.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package encryption

import (
	"crypto/md5"
	"encoding/hex"
)

// MD5Hash generates a a random MD% based on the string given.
func MD5Hash(text string) string {
	hash := md5.Sum([]byte(text))
	return hex.EncodeToString(hash[:])
}"
}
{
file:./api/helpers/encryption/password.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package encryption

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"golang.org/x/crypto/bcrypt"
	"math/rand"
)

// HashPassword gets the password in byte format and generates
// a hashed password with the default cost of 10.
//
// Returns errors.INTERNAL if the bcrypt failed to generate
// from password.
func HashPassword(password string) (string, error) {
	const op = "encryption.HashPassword"
	bytePassword := []byte(password)
	hashedPassword, err := bcrypt.GenerateFromPassword(bytePassword, bcrypt.DefaultCost)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not hash the password with the string: %s", password), Operation: op, Err: err}
	}
	return string(hashedPassword), err
}

// CreatePassword creates a random password with a character
// length of 24.
func CreatePassword() string {
	var characterRunes = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@:\\/@$%=^&&*()_+?><")
	b := make([]rune, 24)
	for i := range b {
		b[i] = characterRunes[rand.Intn(len(characterRunes))]
	}
	return string(b)
}"
}
{
file:./api/helpers/vaidation/validatior.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package validation

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/domain"
	"github.com/ainsleyclark/verbis/api/helpers"
	"github.com/gin-gonic/gin/binding"
	pkgValidate "github.com/go-playground/validator/v10"
	"golang.org/x/crypto/bcrypt"
	"regexp"
	"strings"
)

// Validator defines methods for checking the validation errors
type Validator interface {
	Process(errors pkgValidate.ValidationErrors) []ValidationError
	CmdCheck(key string, data interface{}) error
	message(kind string, field string, param string) string
}

// Validation defines site wide validation for endpoints
// and using the Package validation helper.
type Validation struct {
	Package *pkgValidate.Validate
}

// ValidationError defines the structure when returning
// validation errors.
type ValidationError struct {
	Key     string `json:"key"`
	Type    string `json:"type"`
	Message string `json:"message"`
}

// New - Construct & set tag name
func New() *Validation {
	v := &Validation{
		Package: pkgValidate.New(),
	}

	v.Package.SetTagName("binding")

	if v, ok := binding.Validator.Engine().(*pkgValidate.Validate); ok {
		v.RegisterValidation("password", comparePassword)
	}

	return v
}

// Process handles validation errors and passes back to respond.
func (v *Validation) Process(errors pkgValidate.ValidationErrors) []ValidationError {

	var returnErrors []ValidationError
	for _, e := range errors {

		field := e.Field()
		result := strings.Split(e.Namespace(), ".")

		// TODO: Clean up here
		if len(result) > 2 && !strings.Contains(e.Namespace(), "PostCreate") || !strings.Contains(e.Namespace(), "UserCreate") {
			field = ""
			for i := 1; i < len(result); i++ {
				field += result[i]
			}
		}

		field = strings.Replace(field, "Part", "", -1)
		field = strings.Replace(field, "User", "", -1)

		reg := regexp.MustCompile(`[A-Z][^A-Z]*`)
		fieldString := ""

		if field == "" {
			field = e.StructField()
		}

		submatchall := reg.FindAllString(field, -1)
		for _, element := range submatchall {
			if element == "User" || element == "Post" {
				continue
			}
			fieldString += strings.ToLower(element) + "_"
		}

		returnErrors = append(returnErrors, ValidationError{
			Key:     strings.TrimRight(fieldString, "_"),
			Type:    e.Tag(),
			Message: v.message(e.Tag(), field, e.Param()),
		})
	}

	return returnErrors
}

// CmdCheck is a function for checking validation by struct on the command line.
func (v *Validation) CmdCheck(key string, data interface{}) error {

	err := v.Package.Struct(data)

	if err != nil {
		validationErrors, _ := err.(pkgValidate.ValidationErrors)
		formatted := v.Process(validationErrors)

		for _, e := range formatted {
			if e.Key == key {
				return fmt.Errorf(e.Message)
			}
		}
	}

	return nil
}

// message checks the kind, field and parameters and binds custom
// error messages.
func (v *Validation) message(kind string, field string, param string) string {
	var errorMsg string

	field = helpers.StringsAddSpace(field)
	param = helpers.StringsAddSpace(param)

	switch kind {
	case "required":
		errorMsg = field + " is required."
	case "email":
		errorMsg = "Enter a valid email address."
	case "min":
		errorMsg = "Enter a minimum of " + param + " characters."
	case "max":
		errorMsg = "Enter a maximum of " + param + " characters."
	case "alpha":
		errorMsg = field + " must be alpha."
	case "alphanum":
		errorMsg = field + " must be alphanumeric."
	case "ip":
		errorMsg = field + " must be valid IP address."
	case "url":
		errorMsg = "Enter a valid url."
	case "eqfield":
		errorMsg = field + " must equal the " + param + "."
	case "password":
		errorMsg = field + " doesn't match our records."
	}

	return errorMsg
}

// comparePassword for the password field on the domain.UserPasswordReset
// (custom validation)
func comparePassword(fl pkgValidate.FieldLevel) bool {
	curPass := fl.Field().String()
	reset := fl.Parent().Interface().(*domain.UserPasswordReset)

	err := bcrypt.CompareHashAndPassword([]byte(reset.DBPassword), []byte(curPass))
	if err != nil {
		return false
	}

	return true
}"
}
{
file:./api/helpers/paths/paths.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paths

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/ainsleyclark/verbis/api/helpers/files"
	"os"
	"path/filepath"
)

// Base path of project
func Base() string {
	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		return ""
	}
	return dir
}

// BaseCheck environment is passable to run Terminal
func BaseCheck() error {
	const op = "paths.BaseCheck"
	basePath := Base()

	if !files.Exists(basePath + "/.env") {
		return fmt.Errorf("Could not locate the .env file in the current directory")
	}

	if !files.DirectoryExists(basePath + "/admin") {
		return &errors.Error{Code: errors.INVALID, Message: "Could not locate the Verbis admin folder in the current directory", Operation: op, Err: fmt.Errorf("%s does not exist", basePath+"/admin")}
	}

	if !files.DirectoryExists(basePath + "/storage") {
		return &errors.Error{Code: errors.INVALID, Message: "Could not locate the Verbis storage folder in the current directory", Operation: op, Err: fmt.Errorf("%s does not exist", basePath+"/storage")}
	}

	if !files.DirectoryExists(basePath + "/config") {
		return &errors.Error{Code: errors.INVALID, Message: "Could not locate the Verbis config folder in the current directory", Operation: op, Err: fmt.Errorf("%s does not exist", basePath+"/config")}
	}

	if !files.DirectoryExists(basePath + "/storage") {
		return &errors.Error{Code: errors.INVALID, Message: "Could not locate the Verbis storage folder in the current directory", Operation: op, Err: fmt.Errorf("%s does not exist", basePath+"/storage")}
	}

	return nil
}

// Admin path of project
func Admin() string {
	return Base() + "/admin"
}

// API path of project
func Api() string {
	return Base() + "/api"
}

// Migration is the Database migration path
func Migration() string {
	if api.SuperAdmin {
		return Api() + "/database/migrations"
	} else {
		return Api() + "/database"
	}
}

// Theme path
func Theme() string {
	return Base() + "/theme"
}

// Storage path
func Storage() string {
	return Base() + "/storage"
}

// Storage path
func Uploads() string {
	return Storage() + "/uploads"
}

// Web (Verbis specific)
func Web() string {
	return Api() + "/web"
}

func Forms() string {
	return Storage() + "/forms"
}"
}
{
file:./api/helpers/html/renderer.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package html

import (
	"bytes"
	"github.com/ainsleyclark/verbis/api/errors"
	"html/template"
)

// RenderTemplate executes the html and returns a string
// Returns errors.INTERNAL if the template failed to be created
// or be executed.
func RenderTemplate(layout string, data interface{}, files ...string) (string, error) {
	const op = "html.RenderTemplate"

	t, err := template.New("").ParseFiles(files...)
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: "Unable to create a new template", Operation: op, Err: err}
	}

	var tpl bytes.Buffer
	if err := t.ExecuteTemplate(&tpl, layout, data); err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: "Unable to render the template", Operation: op, Err: err}
	}

	return tpl.String(), nil
}"
}
{
file:./api/helpers/webp/decoder_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"github.com/stretchr/testify/assert"
	"golang.org/x/image/webp"
	"os"
	"testing"
)

func TestDecode(t *testing.T) {
	f, err := os.Open("source.webp")
	assert.Nil(t, err)
	imgSource, err := Decode(f)
	assert.Nil(t, err)
	f.Seek(0, 0)
	imgTarget, err := webp.Decode(f)
	assert.Nil(t, err)
	assert.Equal(t, imgSource.Bounds(), imgTarget.Bounds())
}"
}
{
file:./api/helpers/webp/dwebp.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"bytes"
	"errors"
	"github.com/nickalie/go-binwrapper"
	"image"
	"image/png"
	"io"
)

// DWebP wraps dwebp tool used for decompression of WebP files into PNG.
// https://developers.google.com/speed/webp/docs/dwebp
type DWebP struct {
	*binwrapper.BinWrapper
	inputFile  string
	input      io.Reader
	outputFile string
	output     io.Writer
}

// NewDWebP creates new WebP instance
func NewDWebP() *DWebP {
	bin := &DWebP{
		BinWrapper: CreateBinWrapper(),
	}
	bin.ExecPath("dwebp")

	return bin
}

// InputFile sets webp file to convert.
// Input or InputImage called before will be ignored.
func (c *DWebP) InputFile(file string) *DWebP {
	c.input = nil
	c.inputFile = file
	return c
}

// Input sets reader to convert.
// InputFile or InputImage called before will be ignored.
func (c *DWebP) Input(reader io.Reader) *DWebP {
	c.inputFile = ""
	c.input = reader
	return c
}

// OutputFile specify the name of the output image file.
// Output called before will be ignored.
func (c *DWebP) OutputFile(file string) *DWebP {
	c.output = nil
	c.outputFile = file
	return c
}

// Output specify writer to write image file content.
// OutputFile called before will be ignored.
func (c *DWebP) Output(writer io.Writer) *DWebP {
	c.outputFile = ""
	c.output = writer
	return c
}

// Version returns dwebp version.
func (c *DWebP) Version() (string, error) {
	return version(c.BinWrapper)
}

// Run starts dwebp with specified parameters.
func (c *DWebP) Run() (image.Image, error) {
	defer c.BinWrapper.Reset()

	output, err := c.getOutput()

	if err != nil {
		return nil, err
	}

	c.Arg("-o", output)

	err = c.setInput()

	if err != nil {
		return nil, err
	}

	if c.output != nil {
		c.SetStdOut(c.output)
	}

	err = c.BinWrapper.Run()

	if err != nil {
		return nil, errors.New(err.Error() + ". " + string(c.StdErr()))
	}

	if c.output == nil && c.outputFile == "" {
		return png.Decode(bytes.NewReader(c.BinWrapper.StdOut()))
	}

	return nil, nil
}

func (c *DWebP) setInput() error {
	if c.input != nil {
		c.Arg("--").Arg("-")
		c.StdIn(c.input)
	} else if c.inputFile != "" {
		c.Arg(c.inputFile)
	} else {
		return errors.New("Undefined input")
	}

	return nil
}

func (c *DWebP) getOutput() (string, error) {
	if c.outputFile != "" {
		return c.outputFile, nil
	}

	return "-", nil
}"
}
{
file:./api/helpers/webp/cwebp_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"golang.org/x/image/webp"
	"image/jpeg"
	"io"
	"net/http"
	"os"
	"testing"
)

func init() {
	DetectUnsupportedPlatforms()
	downloadFile("https://upload.wikimedia.org/wikipedia/commons/e/e3/Avola-Syracuse-Sicilia-Italy_-_Creative_Commons_by_gnuckx_%283858115914%29.jpg", "source.jpg")
	downloadFile("https://upload.wikimedia.org/wikipedia/commons/d/d1/Snail_in_Forest_on_Lichtscheid_2.webp", "source.webp")
}

func downloadFile(url, target string) {
	_, err := os.Stat(target)

	if err != nil {
		resp, err := http.Get(url)

		if err != nil {
			fmt.Printf("Error while downloading test image: %v\n", err)
			panic(err)
		}

		defer resp.Body.Close()

		f, err := os.Create(target)

		if err != nil {
			panic(err)
		}

		defer f.Close()

		_, err = io.Copy(f, resp.Body)

		if err != nil {
			panic(err)
		}
	}
}

func TestEncodeImage(t *testing.T) {
	c := NewCWebP()
	f, err := os.Open("source.jpg")
	assert.Nil(t, err)
	img, err := jpeg.Decode(f)
	assert.Nil(t, err)
	c.InputImage(img)
	c.OutputFile("target.webp")
	err = c.Run()
	assert.Nil(t, err)
	validateWebp(t)
}

func TestEncodeReader(t *testing.T) {
	c := NewCWebP()
	f, err := os.Open("source.jpg")
	assert.Nil(t, err)
	c.Input(f)
	c.OutputFile("target.webp")
	err = c.Run()
	assert.Nil(t, err)
	validateWebp(t)
}

func TestEncodeFile(t *testing.T) {
	c := NewCWebP()
	c.InputFile("source.jpg")
	c.OutputFile("target.webp")
	err := c.Run()
	assert.Nil(t, err)
	validateWebp(t)
}

func TestEncodeWriter(t *testing.T) {
	f, err := os.Create("target.webp")
	assert.Nil(t, err)
	defer f.Close()

	c := NewCWebP()
	c.InputFile("source.jpg")
	c.Output(f)
	err = c.Run()
	assert.Nil(t, err)
	f.Close()
	validateWebp(t)
}

func TestVersionCWebP(t *testing.T) {
	c := NewCWebP()
	r, err := c.Version()
	assert.Nil(t, err)

	if _, ok := os.LookupEnv("DOCKER_ARM_TEST"); !ok {
		assert.Equal(t, "0.6.0", r)
	}
}

func validateWebp(t *testing.T) {
	defer os.Remove("target.webp")
	fSource, err := os.Open("source.jpg")
	assert.Nil(t, err)
	imgSource, err := jpeg.Decode(fSource)
	assert.Nil(t, err)
	fTarget, err := os.Open("target.webp")
	assert.Nil(t, err)
	defer fTarget.Close()
	imgTarget, err := webp.Decode(fTarget)
	assert.Nil(t, err)
	assert.Equal(t, imgSource.Bounds(), imgTarget.Bounds())
}"
}
{
file:./api/helpers/webp/decoder.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"image"
	"io"
)

// Decode reads a WebP image from r and returns it as an image.Image.
func Decode(r io.Reader) (image.Image, error) {
	return NewDWebP().Input(r).Run()
}"
}
{
file:./api/helpers/webp/encoder.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"image"
	"io"
)

// Encoder encodes image.Image into webp using cwebp.
type Encoder struct {
	//Specify the compression factor for RGB channels between 0 and 100. The default is 75.
	//
	//A small factor produces a smaller file with lower quality. Best quality is achieved by using a value of 100.
	Quality uint
}

// Encode writes the Image m to w in WebP format. Any Image may be encoded.
func (e *Encoder) Encode(w io.Writer, m image.Image) error {
	return NewCWebP().
		Quality(e.Quality).
		InputImage(m).
		Output(w).
		Run()

}

//Encode writes the Image m to w in WebP format. Any Image may be encoded.
func Encode(w io.Writer, m image.Image) error {
	e := &Encoder{Quality: 75}
	return e.Encode(w, m)
}"
}
{
file:./api/helpers/webp/webpbin.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"bytes"
	"github.com/nickalie/go-binwrapper"
	"image"
	"image/png"
	"io"
	"io/ioutil"
	"runtime"
	"strings"
)

var skipDownload bool
var dest = "bin/webp"

// DetectUnsupportedPlatforms detects platforms without prebuilt binaries (alpine and arm).
// For this platforms libwebp tools should be built manually.
// See https://github.com/nickalie/go-webpbin/blob/master/docker/Dockerfile and https://github.com/nickalie/go-webpbin/blob/master/docker/Dockerfile.arm for details
func DetectUnsupportedPlatforms() {
	if runtime.GOARCH == "arm" {
		SkipDownload()
	} else if runtime.GOOS == "linux" {
		output, err := ioutil.ReadFile("/etc/issue")

		if err == nil && bytes.Contains(bytes.ToLower(output), []byte("alpine")) {
			SkipDownload()
		}
	}
}

// SkipDownload skips binary download.
func SkipDownload() {
	skipDownload = true
	dest = ""
}

// Dest sets directory to download libwebp binaries or where to look for them if SkipDownload is used. Default is "vendor/webp"
func Dest(value string) {
	dest = value
}

func CreateBinWrapper() *binwrapper.BinWrapper {
	base := "https://storage.googleapis.com/downloads.webmproject.org/releases/webp/"

	b := binwrapper.NewBinWrapper().AutoExe()

	if !skipDownload {
		b.Src(
			binwrapper.NewSrc().
				URL(base + "libwebp-0.6.0-mac-10.12.tar.gz").
				Os("darwin")).
			Src(
				binwrapper.NewSrc().
					URL(base + "libwebp-0.6.0-linux-x86-32.tar.gz").
					Os("linux").
					Arch("x86")).
			Src(
				binwrapper.NewSrc().
					URL(base + "libwebp-0.6.0-linux-x86-64.tar.gz").
					Os("linux").
					Arch("x64")).
			Src(
				binwrapper.NewSrc().
					URL(base + "libwebp-0.6.0-windows-x64.zip").
					Os("win32").
					Arch("x64")).
			Src(
				binwrapper.NewSrc().
					URL(base + "libwebp-0.6.0-windows-x86.zip").
					Os("win32").
					Arch("x86"))
	}

	return b.Strip(2).Dest(dest)
}

func createReaderFromImage(img image.Image) (io.Reader, error) {
	enc := &png.Encoder{
		CompressionLevel: png.NoCompression,
	}

	var buffer bytes.Buffer
	err := enc.Encode(&buffer, img)

	if err != nil {
		return nil, err
	}

	return &buffer, nil
}

func version(b *binwrapper.BinWrapper) (string, error) {
	b.Reset()
	err := b.Run("-version")

	if err != nil {
		return "", err
	}

	version := string(b.StdOut())
	version = strings.Replace(version, "\n", "", -1)
	version = strings.Replace(version, "\r", "", -1)
	return version, nil
}"
}
{
file:./api/helpers/webp/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"strings"
)

// Accepts checks to see if the browser accepts WebP images
func Accepts(g *gin.Context) bool {
	acceptHeader := g.Request.Header.Get("Accept")
	return strings.Contains(acceptHeader, "image/webp")
}

// GetData first checks to see if the browser accepts WebP images
// and if the mime type is jpg or a png.
// Returns a data was found, nil if it hasn't.
func GetData(g *gin.Context, path string, mime string) []byte {
	if Accepts(g) && mime == "image/jpeg" || mime == "image/png" {
		data, found := ioutil.ReadFile(path + ".webp")
		if found != nil {
			return nil
		}
		return data
	}
	return nil
}

// Converts an image to webp based on compression and decoded image.
// Compression level is also set.
func Convert(path string, compression int) {
	const op = "Webp.Convert"

	err := NewCWebP().
		Quality(uint(compression)).
		InputFile(path).
		OutputFile(path + ".webp").
		Run()

	if err != nil {
		log.WithFields(log.Fields{
			"error": errors.Error{Code: errors.INTERNAL, Message: "Could not convert the image to webp", Operation: op, Err: err},
		}).Error()
	}
}"
}
{
file:./api/helpers/webp/encoder_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"bytes"
	"github.com/stretchr/testify/assert"
	"golang.org/x/image/webp"
	"image/jpeg"
	"os"
	"testing"
)

func TestEncode(t *testing.T) {
	f, err := os.Open("source.jpg")
	assert.Nil(t, err)
	imgSource, err := jpeg.Decode(f)
	assert.Nil(t, err)
	var b bytes.Buffer
	err = Encode(&b, imgSource)
	assert.Nil(t, err)
	imgTarget, err := webp.Decode(bytes.NewReader(b.Bytes()))
	assert.Nil(t, err)
	assert.Equal(t, imgSource.Bounds(), imgTarget.Bounds())
}"
}
{
file:./api/helpers/webp/cwebp.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"errors"
	"fmt"
	"github.com/nickalie/go-binwrapper"
	"image"
	"io"
)

type cropInfo struct {
	x      int
	y      int
	width  int
	height int
}

// CWebP compresses an image using the WebP format. Input format can be either PNG, JPEG, TIFF, WebP or raw Y'CbCr samples.
// https://developers.google.com/speed/webp/docs/cwebp
type CWebP struct {
	*binwrapper.BinWrapper
	inputFile  string
	inputImage image.Image
	input      io.Reader
	outputFile string
	output     io.Writer
	quality    int
	crop       *cropInfo
}

// NewCWebP creates new CWebP instance.
func NewCWebP() *CWebP {
	bin := &CWebP{
		BinWrapper: CreateBinWrapper(),
		quality:    -1,
	}
	bin.ExecPath("cwebp")

	return bin
}

// Version returns cwebp version.
func (c *CWebP) Version() (string, error) {
	return version(c.BinWrapper)
}

// InputFile sets image file to convert.
// Input or InputImage called before will be ignored.
func (c *CWebP) InputFile(file string) *CWebP {
	c.input = nil
	c.inputImage = nil
	c.inputFile = file
	return c
}

// Input sets reader to convert.
// InputFile or InputImage called before will be ignored.
func (c *CWebP) Input(reader io.Reader) *CWebP {
	c.inputFile = ""
	c.inputImage = nil
	c.input = reader
	return c
}

// InputImage sets image to convert.
// InputFile or Input called before will be ignored.
func (c *CWebP) InputImage(img image.Image) *CWebP {
	c.inputFile = ""
	c.input = nil
	c.inputImage = img
	return c
}

// OutputFile specify the name of the output WebP file.
// Output called before will be ignored.
func (c *CWebP) OutputFile(file string) *CWebP {
	c.output = nil
	c.outputFile = file
	return c
}

// Output specify writer to write webp file content.
// OutputFile called before will be ignored.
func (c *CWebP) Output(writer io.Writer) *CWebP {
	c.outputFile = ""
	c.output = writer
	return c
}

// Quality specify the compression factor for RGB channels between 0 and 100. The default is 75.
//
// A small factor produces a smaller file with lower quality. Best quality is achieved by using a value of 100.
func (c *CWebP) Quality(quality uint) *CWebP {
	if quality > 100 {
		quality = 100
	}

	c.quality = int(quality)
	return c
}

// Crop the source to a rectangle with top-left corner at coordinates (x, y) and size width x height. This cropping area must be fully contained within the source rectangle.
func (c *CWebP) Crop(x, y, width, height int) *CWebP {
	c.crop = &cropInfo{x, y, width, height}
	return c
}

// Run starts cwebp with specified parameters.
func (c *CWebP) Run() error {
	defer c.BinWrapper.Reset()

	c.Arg("-mt")

	// lower the number more compression

	if c.quality > -1 {
		if c.quality == 100 {
			c.Arg("-lossless")
			c.Arg("-exact")
			//c.Arg("-q", fmt.Sprintf("%d", c.quality))
		} else {
			c.Arg("-q", fmt.Sprintf("%d", c.quality))
		}
	}

	if c.crop != nil {
		c.Arg("-crop", fmt.Sprintf("%d", c.crop.x), fmt.Sprintf("%d", c.crop.y), fmt.Sprintf("%d", c.crop.width), fmt.Sprintf("%d", c.crop.height))
	}

	output, err := c.getOutput()

	if err != nil {
		return err
	}

	c.Arg("-o", output)

	err = c.setInput()

	if err != nil {
		return err
	}

	if c.output != nil {
		c.SetStdOut(c.output)
	}

	err = c.BinWrapper.Run()

	if err != nil {
		return errors.New(err.Error() + ". " + string(c.StdErr()))
	}

	return nil
}

// Reset all parameters to default values
func (c *CWebP) Reset() *CWebP {
	c.crop = nil
	c.quality = -1
	return c
}

func (c *CWebP) setInput() error {
	if c.input != nil {
		c.Arg("--").Arg("-")
		c.StdIn(c.input)
	} else if c.inputImage != nil {
		r, err := createReaderFromImage(c.inputImage)

		if err != nil {
			return err
		}

		c.Arg("--").Arg("-")
		c.StdIn(r)
	} else if c.inputFile != "" {
		c.Arg(c.inputFile)
	} else {
		return errors.New("Undefined input")
	}

	return nil
}

func (c *CWebP) getOutput() (string, error) {
	if c.output != nil {
		return "-", nil
	} else if c.outputFile != "" {
		return c.outputFile, nil
	} else {
		return "", errors.New("Undefined output")
	}
}"
}
{
file:./api/helpers/webp/dwebp_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package webp

import (
	"github.com/stretchr/testify/assert"
	"golang.org/x/image/webp"
	"image/png"
	"os"
	"testing"
)

func TestVersionDWebP(t *testing.T) {
	c := NewDWebP()
	r, err := c.Version()
	assert.Nil(t, err)
	if _, ok := os.LookupEnv("DOCKER_ARM_TEST"); !ok {
		assert.Equal(t, "0.6.0", r)
	}
}

func TestDecodeReader(t *testing.T) {
	c := NewDWebP()
	f, err := os.Open("source.webp")
	assert.Nil(t, err)
	defer f.Close()
	c.Input(f)
	c.OutputFile("target.png")
	img, err := c.Run()
	assert.Nil(t, err)
	assert.Nil(t, img)
	validatePng(t)
}

func TestDecodeFile(t *testing.T) {
	c := NewDWebP()
	c.InputFile("source.webp")
	c.OutputFile("target.png")
	img, err := c.Run()
	assert.Nil(t, err)
	assert.Nil(t, img)
	validatePng(t)
}

func TestDecodeImage(t *testing.T) {
	c := NewDWebP()
	f, err := os.Open("source.webp")
	assert.Nil(t, err)
	defer f.Close()
	imgSource, err := webp.Decode(f)
	assert.Nil(t, err)
	f.Seek(0, 0)
	c.Input(f)
	imgTarget, err := c.Run()
	assert.Nil(t, err)
	assert.NotNil(t, imgTarget)
	assert.Equal(t, imgSource.Bounds(), imgTarget.Bounds())
}

func TestDecodeWriter(t *testing.T) {
	f, err := os.Create("target.png")
	assert.Nil(t, err)
	defer f.Close()
	c := NewDWebP()
	c.InputFile("source.webp")
	c.Output(f)
	img, err := c.Run()
	assert.Nil(t, err)
	assert.Nil(t, img)
	f.Close()
	validatePng(t)
}

func validatePng(t *testing.T) {
	defer os.Remove("target.png")
	fSource, err := os.Open("source.webp")
	assert.Nil(t, err)
	imgSource, err := webp.Decode(fSource)
	assert.Nil(t, err)
	fTarget, err := os.Open("target.png")
	assert.Nil(t, err)
	defer fTarget.Close()
	imgTarget, err := png.Decode(fTarget)
	assert.Nil(t, err)
	assert.Equal(t, imgSource.Bounds(), imgTarget.Bounds())
}"
}
{
file:./api/helpers/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package helpers

import (
	"bytes"
	"strings"
	"unicode"
)

// Check if a string exists in a slice
func StringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

// Check if a string exists in a slice
func IntInSlice(a int, list []int) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

// Split everything before deliminator
func StringsSplitLeft(str string, delim string) string {
	return strings.Split(str, delim)[0]
}

// Split everything after deliminator
func StringsSplitRight(str string, delim string) string {
	return strings.Join(strings.Split(str, delim)[1:], delim)
}

// Between Gets substring between two strings.
func StringsBetween(value string, a string, b string) string {
	posFirst := strings.Index(value, a)
	if posFirst == -1 {
		return ""
	}
	posLast := strings.Index(value, b)
	if posLast == -1 {
		return ""
	}
	posFirstAdjusted := posFirst + len(a)
	if posFirstAdjusted >= posLast {
		return ""
	}
	return value[posFirstAdjusted:posLast]
}

// Add space between uppercase letters, for example
// HelloWorld will convert to Hello World.
func StringsAddSpace(s string) string {
	buf := &bytes.Buffer{}
	for i, rune := range s {
		if unicode.IsUpper(rune) && i > 0 {
			buf.WriteRune(' ')
		}
		buf.WriteRune(rune)
	}
	return buf.String()
}"
}
{
file:./api/helpers/params/params.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import (
	"encoding/json"
	"strconv"
)

const (
	// PaginationAllLimit defines how many items will be returned if
	// the limit is set to list all
	PaginationDefault = 15
	// PaginationDefaultOrder defines the default order by for the
	// API
	PaginationDefaultOrder = "id,DESC"
)

// Parameterize defines the function for getting http params
type Parameterize interface {
	Get() Params
}

// Params represents the http params for interacting with the DB
type Params struct {
	//gin            *gin.Context
	Page           int                 `json:"page"`
	Limit          int                 `json:"limit"`
	LimitAll       bool                `json:"all"`
	OrderBy        string              `json:"order_by"`
	OrderDirection string              `json:"order_direction"`
	Filters        map[string][]Filter `json:"-"`
	defaults       Defaults            `json:"-"`
	Stringer       `json:"-"`
}

type Stringer interface {
	Param(string) string
}

// Filter represents the searching fields for searching through records.
type Filter struct {
	Operator string `json:"operator"`
	Value    string `json:"value"`
}

type Defaults struct {
	Page           int
	Limit          interface{}
	OrderBy        string
	OrderDirection string
}

// NewParams - create a new parameter type
func NewParams(str Stringer, def Defaults) *Params {
	p := &Params{
		Stringer: str,
		defaults: def,
	}
	p.validateDefaults()
	return p
}

// Check there are values set in the defaults.
func (p *Params) validateDefaults() {
	if p.defaults.OrderBy == "" {
		panic("No default order by set")
	}
	if p.defaults.OrderDirection == "" {
		panic("No default order direction set")
	}
	if p.defaults.Limit == nil {
		panic("No default limit set")
	}
}

// Get query Parameters for http API routes
func (p *Params) Get() Params {
	limit, limitAll := p.limit()
	order := p.order()
	return Params{
		Page:           p.page(),
		Limit:          limit,
		LimitAll:       limitAll,
		OrderBy:        order[0],
		OrderDirection: order[1],
		Filters:        p.filter(),
	}
}

// Get page and set default
func (p *Params) page() int {
	var page int
	pageStr := p.Param("page")

	page, err := strconv.Atoi(pageStr)
	if err != nil || page == 0 {
		page = p.defaults.Page
	}

	return page
}

// Get limit & calculate if list all
func (p *Params) limit() (int, bool) {
	limitStr := p.Param("limit")
	if limitStr == "all" {
		return 0, true
	}

	limit, err := strconv.Atoi(limitStr)
	defLimit, ok := p.defaults.Limit.(int)
	if !ok {
		return PaginationDefault, false
	}

	if err != nil || limit == 0 || limitStr == "" {
		return defLimit, false
	}

	return limit, false
}

// Get order and set defaults
func (p *Params) order() []string {
	order := []string{p.defaults.OrderBy, p.defaults.OrderDirection}

	orderBy := p.Param("order_by")
	if orderBy != "" {
		order[0] = orderBy
	}

	orderDirection := p.Param("order_direction")
	if orderDirection != "" {
		order[1] = orderDirection
	}

	return order
}

// Get the filters
func (p *Params) filter() map[string][]Filter {
	filtersParam := p.Param("filter")

	var filters map[string][]Filter
	if filtersParam != "" {
		err := json.Unmarshal([]byte(filtersParam), &filters)
		if err != nil {
			filters = nil
		}
	}

	return filters
}"
}
{
file:./api/helpers/params/api.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import "github.com/gin-gonic/gin"

func ApiParams(g *gin.Context, def Defaults) *Params {
	p := &Params{
		Stringer: &apiParams{gin: g},
		defaults: def,
	}
	p.validateDefaults()
	return p
}

type apiParams struct {
	gin *gin.Context
}

func (a *apiParams) Param(q string) string {
	return a.gin.Query(q)
}"
}
{
file:./api/helpers/params/params_test.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import (
	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestNewParams(t *testing.T) {
	want := &Params{
		gin: &gin.Context{},
	}
	got := NewParams(&gin.Context{})
	assert.Equal(t, got, want)
}

func TestParams_Get(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tt := map[string]struct {
		url  string
		want *Params
	}{
		"Page": {
			url:  "page=2",
			want: &Params{Page: 2, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Nil Page": {
			url:  "page=wrong",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Limit All": {
			url:  "limit=all",
			want: &Params{Page: 1, Limit: 0, LimitAll: true, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Limit Failed": {
			url:  "limit=wrong",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Limit Zero": {
			url:  "limit=0",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Order": {
			url:  "order=name,desc",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "name", OrderDirection: "desc", Filters: nil},
		},
		"Order One Param": {
			url:  "order=id",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Order Comma": {
			url:  "order=id,",
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
		"Filter": {
			url: `&filter={"resource":[{"operator":"=", "value":"verbis"}]}`,
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: map[string][]Filter{
				"resource": {
					{
						Operator: "=",
						Value:    "verbis",
					},
				},
			}},
		},
		"Failed Filter": {
			url:  `&filter={"resource":[, "value":"verbis"}]}`,
			want: &Params{Page: 1, Limit: 15, LimitAll: false, OrderBy: "id", OrderDirection: "ASC", Filters: nil},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			rr := httptest.NewRecorder()
			g, engine := gin.CreateTestContext(rr)

			req, err := http.NewRequest("GET", "/test?"+test.url, nil)
			assert.NoError(t, err)
			g.Request = req

			params := &Params{}
			engine.GET("/test", func(g *gin.Context) {
				p := NewParams(g).Get()
				params = &p
			})
			engine.ServeHTTP(rr, req)

			assert.Equal(t, test.want, params)
		})
	}
}"
}
{
file:./api/helpers/files/util.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package files

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"io"
	"io/ioutil"
	"mime/multipart"
	"os"
	"path/filepath"
)

// Delete file based on file path
// Returns errors.INTERNAL if the file failed to delete.
func Delete(path string) error {
	const op = "files.Delete"
	err := os.Remove(path)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Could not delete the file with the path: %v", path), Operation: op, Err: err}
	}
	return nil
}

// Exists checks if a file exists using os.Stat
func Exists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

// DirectoryExists checks if directory exists using os.Stat
func DirectoryExists(filename string) bool {
	_, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return true
}

// Check the file exists and delete
// Returns errors.NOTFOUND if the file was not found.
func CheckAndDelete(path string) error {
	const op = "files.Delete"
	if Exists(path) {
		if err := Delete(path); err != nil {
			return err
		}
		return nil
	}
	return &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Failed to delete file with the path: %s", path), Operation: op, Err: fmt.Errorf("filepath %v not found", path)}
}

// Save File
// Returns errors.INTERNAL if the file could not be opened or be created.
func Save(file *multipart.FileHeader, dst string) error {
	const op = "files.Save"

	src, err := file.Open()
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to open file with the name: %s", file.Filename), Operation: op, Err: err}
	}
	defer src.Close()

	out, err := os.Create(dst)
	if err != nil {
		return &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to create a file with the name: %s", file.Filename), Operation: op, Err: err}
	}
	defer out.Close()

	_, err = io.Copy(out, src)
	return err
}

// Remove the file extension from a file
func RemoveFileExtension(file string) string {
	return file[0 : len(file)-len(GetFileExtension(file))]
}

// Get the file extension from a file
func GetFileExtension(file string) string {
	return filepath.Ext(file)
}

// Get the filesize of a file by path
func GetFileSize(path string) int {
	fi, err := os.Stat(path)
	if err != nil {
		return 0
	}
	return int(fi.Size() / 1024)
}

// GetFileContents of given path
// Returns errors.INTERNAL if the path was invalid
func GetFileContents(path string) (string, error) {
	const op = "files.GetFileContents"
	contents, err := ioutil.ReadFile(path)
	if err != nil {
		return "", &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Could not get the file contents with the path: %s", path), Operation: op, Err: err}
	}
	return string(contents), nil
}

// LoadFile load's the a file based on the path and returns a []byte ready for conversion
// Returns errors.INTERNAL if the configuration file failed to load.
func LoadFile(path string) ([]byte, error) {
	const op = "files.LoadFileB"
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, &errors.Error{Code: errors.INVALID, Message: fmt.Sprintf("Could not load the file with the path: %s", path), Operation: op, Err: err}
	}
	return data, nil
}"
}
{
file:./api/helpers/mime/types.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mime

import "strings"

// TypeByExtension returns the content type based on the extension of the file
func TypeByExtension(extension string) string {
	return mimeTypes[strings.ToLower(extension)]
}

var mimeTypes = map[string]string{
	"123":                      "application/vnd.lotus-1-2-3",
	"3dml":                     "text/vnd.in3d.3dml",
	"3ds":                      "image/x-3ds",
	"3g2":                      "video/3gpp2",
	"3gp":                      "video/3gpp",
	"3gpp":                     "video/3gpp",
	"7z":                       "application/x-7z-compressed",
	"aab":                      "application/x-authorware-bin",
	"aac":                      "audio/x-aac",
	"aam":                      "application/x-authorware-map",
	"aas":                      "application/x-authorware-seg",
	"abw":                      "application/x-abiword",
	"ac":                       "application/pkix-attr-cert",
	"acc":                      "application/vnd.americandynamics.acc",
	"ace":                      "application/x-ace-compressed",
	"acu":                      "application/vnd.acucobol",
	"acutc":                    "application/vnd.acucorp",
	"adp":                      "audio/adpcm",
	"aep":                      "application/vnd.audiograph",
	"afm":                      "application/x-font-type1",
	"afp":                      "application/vnd.ibm.modcap",
	"ahead":                    "application/vnd.ahead.space",
	"ai":                       "application/postscript",
	"aif":                      "audio/x-aiff",
	"aifc":                     "audio/x-aiff",
	"aiff":                     "audio/x-aiff",
	"air":                      "application/vnd.adobe.air-application-installer-package+zip",
	"ait":                      "application/vnd.dvb.ait",
	"ami":                      "application/vnd.amiga.ami",
	"apk":                      "application/vnd.android.package-archive",
	"apng":                     "image/apng",
	"appcache":                 "text/cache-manifest",
	"application":              "application/x-ms-application",
	"apr":                      "application/vnd.lotus-approach",
	"arc":                      "application/x-freearc",
	"arj":                      "application/x-arj",
	"arw":                      "image/x-sony-arw",
	"asc":                      "application/pgp-signature",
	"asf":                      "video/x-ms-asf",
	"asm":                      "text/x-asm",
	"aso":                      "application/vnd.accpac.simply.aso",
	"asx":                      "video/x-ms-asf",
	"atc":                      "application/vnd.acucorp",
	"atom":                     "application/atom+xml",
	"atomcat":                  "application/atomcat+xml",
	"atomsvc":                  "application/atomsvc+xml",
	"atx":                      "application/vnd.antix.game-component",
	"au":                       "audio/basic",
	"avi":                      "video/x-msvideo",
	"aw":                       "application/applixware",
	"azf":                      "application/vnd.airzip.filesecure.azf",
	"azs":                      "application/vnd.airzip.filesecure.azs",
	"azv":                      "image/vnd.airzip.accelerator.azv",
	"azw":                      "application/vnd.amazon.ebook",
	"bat":                      "application/x-msdownload",
	"bcpio":                    "application/x-bcpio",
	"bdf":                      "application/x-font-bdf",
	"bdm":                      "application/vnd.syncml.dm+wbxml",
	"bdoc":                     "application/x-bdoc",
	"bed":                      "application/vnd.realvnc.bed",
	"bh2":                      "application/vnd.fujitsu.oasysprs",
	"bin":                      "application/octet-stream",
	"blb":                      "application/x-blorb",
	"blorb":                    "application/x-blorb",
	"bmi":                      "application/vnd.bmi",
	"bmp":                      "image/x-ms-bmp",
	"book":                     "application/vnd.framemaker",
	"box":                      "application/vnd.previewsystems.box",
	"boz":                      "application/x-bzip2",
	"bpk":                      "application/octet-stream",
	"btif":                     "image/prs.btif",
	"buffer":                   "application/octet-stream",
	"bz":                       "application/x-bzip",
	"bz2":                      "application/x-bzip2",
	"c":                        "text/x-c",
	"c11amc":                   "application/vnd.cluetrust.cartomobile-config",
	"c11amz":                   "application/vnd.cluetrust.cartomobile-config-pkg",
	"c4d":                      "application/vnd.clonk.c4group",
	"c4f":                      "application/vnd.clonk.c4group",
	"c4g":                      "application/vnd.clonk.c4group",
	"c4p":                      "application/vnd.clonk.c4group",
	"c4u":                      "application/vnd.clonk.c4group",
	"cab":                      "application/vnd.ms-cab-compressed",
	"caf":                      "audio/x-caf",
	"cap":                      "application/vnd.tcpdump.pcap",
	"car":                      "application/vnd.curl.car",
	"cat":                      "application/vnd.ms-pki.seccat",
	"cb7":                      "application/x-cbr",
	"cba":                      "application/x-cbr",
	"cbr":                      "application/x-cbr",
	"cbt":                      "application/x-cbr",
	"cbz":                      "application/x-cbr",
	"cc":                       "text/x-c",
	"cco":                      "application/x-cocoa",
	"cct":                      "application/x-director",
	"ccxml":                    "application/ccxml+xml",
	"cdbcmsg":                  "application/vnd.contact.cmsg",
	"cdf":                      "application/x-netcdf",
	"cdkey":                    "application/vnd.mediastation.cdkey",
	"cdmia":                    "application/cdmi-capability",
	"cdmic":                    "application/cdmi-container",
	"cdmid":                    "application/cdmi-domain",
	"cdmio":                    "application/cdmi-object",
	"cdmiq":                    "application/cdmi-queue",
	"cdx":                      "chemical/x-cdx",
	"cdxml":                    "application/vnd.chemdraw+xml",
	"cdy":                      "application/vnd.cinderella",
	"cer":                      "application/pkix-cert",
	"cfs":                      "application/x-cfs-compressed",
	"cgm":                      "image/cgm",
	"chat":                     "application/x-chat",
	"chm":                      "application/vnd.ms-htmlhelp",
	"chrt":                     "application/vnd.kde.kchart",
	"cif":                      "chemical/x-cif",
	"cii":                      "application/vnd.anser-web-certificate-issue-initiation",
	"cil":                      "application/vnd.ms-artgalry",
	"cla":                      "application/vnd.claymore",
	"class":                    "application/java-vm",
	"clkk":                     "application/vnd.crick.clicker.keyboard",
	"clkp":                     "application/vnd.crick.clicker.palette",
	"clkt":                     "application/vnd.crick.clicker.template",
	"clkw":                     "application/vnd.crick.clicker.wordbank",
	"clkx":                     "application/vnd.crick.clicker",
	"clp":                      "application/x-msclip",
	"cmc":                      "application/vnd.cosmocaller",
	"cmdf":                     "chemical/x-cmdf",
	"cml":                      "chemical/x-cml",
	"cmp":                      "application/vnd.yellowriver-custom-menu",
	"cmx":                      "image/x-cmx",
	"cod":                      "application/vnd.rim.cod",
	"coffee":                   "text/coffeescript",
	"com":                      "application/x-msdownload",
	"conf":                     "text/plain",
	"cpio":                     "application/x-cpio",
	"cpp":                      "text/x-c",
	"cpt":                      "application/mac-compactpro",
	"cr2":                      "image/x-canon-cr2",
	"crd":                      "application/x-mscardfile",
	"crl":                      "application/pkix-crl",
	"crt":                      "application/x-x509-ca-cert",
	"crw":                      "image/x-canon-crw",
	"crx":                      "application/x-chrome-extension",
	"cryptonote":               "application/vnd.rig.cryptonote",
	"csh":                      "application/x-csh",
	"csl":                      "application/vnd.citationstyles.style+xml",
	"csml":                     "chemical/x-csml",
	"csp":                      "application/vnd.commonspace",
	"css":                      "text/css",
	"cst":                      "application/x-director",
	"csv":                      "text/csv",
	"cu":                       "application/cu-seeme",
	"curl":                     "text/vnd.curl",
	"cww":                      "application/prs.cww",
	"cxt":                      "application/x-director",
	"cxx":                      "text/x-c",
	"dae":                      "model/vnd.collada+xml",
	"daf":                      "application/vnd.mobius.daf",
	"dart":                     "application/vnd.dart",
	"dataless":                 "application/vnd.fdsn.seed",
	"davmount":                 "application/davmount+xml",
	"dbk":                      "application/docbook+xml",
	"dcr":                      "application/x-director",
	"dcurl":                    "text/vnd.curl.dcurl",
	"dd2":                      "application/vnd.oma.dd2+xml",
	"ddd":                      "application/vnd.fujixerox.ddd",
	"deb":                      "application/x-debian-package",
	"def":                      "text/plain",
	"deploy":                   "application/octet-stream",
	"der":                      "application/x-x509-ca-cert",
	"dfac":                     "application/vnd.dreamfactory",
	"dgc":                      "application/x-dgc-compressed",
	"dic":                      "text/x-c",
	"dir":                      "application/x-director",
	"dis":                      "application/vnd.mobius.dis",
	"disposition-notification": "message/disposition-notification",
	"dist":                     "application/octet-stream",
	"distz":                    "application/octet-stream",
	"djv":                      "image/vnd.djvu",
	"djvu":                     "image/vnd.djvu",
	"dll":                      "application/x-msdownload",
	"dmg":                      "application/x-apple-diskimage",
	"dmp":                      "application/vnd.tcpdump.pcap",
	"dms":                      "application/octet-stream",
	"dna":                      "application/vnd.dna",
	"dng":                      "image/x-adobe-dng",
	"doc":                      "application/msword",
	"docm":                     "application/vnd.ms-word.document.macroenabled.12",
	"docx":                     "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
	"dot":                      "application/msword",
	"dotm":                     "application/vnd.ms-word.template.macroenabled.12",
	"dotx":                     "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
	"dp":                       "application/vnd.osgi.dp",
	"dpg":                      "application/vnd.dpgraph",
	"dra":                      "audio/vnd.dra",
	"drle":                     "image/dicom-rle",
	"dsc":                      "text/prs.lines.tag",
	"dssc":                     "application/dssc+der",
	"dtb":                      "application/x-dtbook+xml",
	"dtd":                      "application/xml-dtd",
	"dts":                      "audio/vnd.dts",
	"dtshd":                    "audio/vnd.dts.hd",
	"dump":                     "application/octet-stream",
	"dvb":                      "video/vnd.dvb.file",
	"dvi":                      "application/x-dvi",
	"dwf":                      "model/vnd.dwf",
	"dwg":                      "image/vnd.dwg",
	"dxf":                      "image/vnd.dxf",
	"dxp":                      "application/vnd.spotfire.dxp",
	"dxr":                      "application/x-director",
	"ear":                      "application/java-archive",
	"ecelp4800":                "audio/vnd.nuera.ecelp4800",
	"ecelp7470":                "audio/vnd.nuera.ecelp7470",
	"ecelp9600":                "audio/vnd.nuera.ecelp9600",
	"ecma":                     "application/ecmascript",
	"edm":                      "application/vnd.novadigm.edm",
	"edx":                      "application/vnd.novadigm.edx",
	"efif":                     "application/vnd.picsel",
	"ei6":                      "application/vnd.pg.osasli",
	"elc":                      "application/octet-stream",
	"emf":                      "image/emf",
	"eml":                      "message/rfc822",
	"emma":                     "application/emma+xml",
	"emz":                      "application/x-msmetafile",
	"eol":                      "audio/vnd.digital-winds",
	"eot":                      "application/vnd.ms-fontobject",
	"eps":                      "application/postscript",
	"epub":                     "application/epub+zip",
	"erf":                      "image/x-epson-erf",
	"es":                       "application/ecmascript",
	"es3":                      "application/vnd.eszigno3+xml",
	"esa":                      "application/vnd.osgi.subsystem",
	"esf":                      "application/vnd.epson.esf",
	"et3":                      "application/vnd.eszigno3+xml",
	"etx":                      "text/x-setext",
	"eva":                      "application/x-eva",
	"evy":                      "application/x-envoy",
	"exe":                      "application/x-msdownload",
	"exi":                      "application/exi",
	"exr":                      "image/aces",
	"ext":                      "application/vnd.novadigm.ext",
	"ez":                       "application/andrew-inset",
	"ez2":                      "application/vnd.ezpix-album",
	"ez3":                      "application/vnd.ezpix-package",
	"f":                        "text/x-fortran",
	"f4v":                      "video/x-f4v",
	"f77":                      "text/x-fortran",
	"f90":                      "text/x-fortran",
	"fbs":                      "image/vnd.fastbidsheet",
	"fcdt":                     "application/vnd.adobe.formscentral.fcdt",
	"fcs":                      "application/vnd.isac.fcs",
	"fdf":                      "application/vnd.fdf",
	"fe_launch":                "application/vnd.denovo.fcselayout-link",
	"fg5":                      "application/vnd.fujitsu.oasysgp",
	"fgd":                      "application/x-director",
	"fh":                       "image/x-freehand",
	"fh4":                      "image/x-freehand",
	"fh5":                      "image/x-freehand",
	"fh7":                      "image/x-freehand",
	"fhc":                      "image/x-freehand",
	"fig":                      "application/x-xfig",
	"fits":                     "image/fits",
	"flac":                     "audio/x-flac",
	"fli":                      "video/x-fli",
	"flo":                      "application/vnd.micrografx.flo",
	"flv":                      "video/x-flv",
	"flw":                      "application/vnd.kde.kivio",
	"flx":                      "text/vnd.fmi.flexstor",
	"fly":                      "text/vnd.fly",
	"fm":                       "application/vnd.framemaker",
	"fnc":                      "application/vnd.frogans.fnc",
	"for":                      "text/x-fortran",
	"fpx":                      "image/vnd.fpx",
	"frame":                    "application/vnd.framemaker",
	"fsc":                      "application/vnd.fsc.weblaunch",
	"fst":                      "image/vnd.fst",
	"ftc":                      "application/vnd.fluxtime.clip",
	"fti":                      "application/vnd.anser-web-funds-transfer-initiation",
	"fvt":                      "video/vnd.fvt",
	"fxp":                      "application/vnd.adobe.fxp",
	"fxpl":                     "application/vnd.adobe.fxp",
	"fzs":                      "application/vnd.fuzzysheet",
	"g2w":                      "application/vnd.geoplan",
	"g3":                       "image/g3fax",
	"g3w":                      "application/vnd.geospace",
	"gac":                      "application/vnd.groove-account",
	"gam":                      "application/x-tads",
	"gbr":                      "application/rpki-ghostbusters",
	"gca":                      "application/x-gca-compressed",
	"gdl":                      "model/vnd.gdl",
	"gdoc":                     "application/vnd.google-apps.document",
	"geo":                      "application/vnd.dynageo",
	"geojson":                  "application/geo+json",
	"gex":                      "application/vnd.geometry-explorer",
	"ggb":                      "application/vnd.geogebra.file",
	"ggt":                      "application/vnd.geogebra.tool",
	"ghf":                      "application/vnd.groove-help",
	"gif":                      "image/gif",
	"gim":                      "application/vnd.groove-identity-message",
	"glb":                      "model/gltf-binary",
	"gltf":                     "model/gltf+json",
	"gml":                      "application/gml+xml",
	"gmx":                      "application/vnd.gmx",
	"gnumeric":                 "application/x-gnumeric",
	"gph":                      "application/vnd.flographit",
	"gpx":                      "application/gpx+xml",
	"gqf":                      "application/vnd.grafeq",
	"gqs":                      "application/vnd.grafeq",
	"gram":                     "application/srgs",
	"gramps":                   "application/x-gramps-xml",
	"gre":                      "application/vnd.geometry-explorer",
	"grv":                      "application/vnd.groove-injector",
	"grxml":                    "application/srgs+xml",
	"gsf":                      "application/x-font-ghostscript",
	"gsheet":                   "application/vnd.google-apps.spreadsheet",
	"gslides":                  "application/vnd.google-apps.presentation",
	"gtar":                     "application/x-gtar",
	"gtm":                      "application/vnd.groove-tool-message",
	"gtw":                      "model/vnd.gtw",
	"gv":                       "text/vnd.graphviz",
	"gxf":                      "application/gxf",
	"gxt":                      "application/vnd.geonext",
	"gz":                       "application/gzip",
	"h":                        "text/x-c",
	"h261":                     "video/h261",
	"h263":                     "video/h263",
	"h264":                     "video/h264",
	"hal":                      "application/vnd.hal+xml",
	"hbci":                     "application/vnd.hbci",
	"hbs":                      "text/x-handlebars-template",
	"hdd":                      "application/x-virtualbox-hdd",
	"hdf":                      "application/x-hdf",
	"heic":                     "image/heic",
	"heics":                    "image/heic-sequence",
	"heif":                     "image/heif",
	"heifs":                    "image/heif-sequence",
	"hh":                       "text/x-c",
	"hjson":                    "application/hjson",
	"hlp":                      "application/winhlp",
	"hpgl":                     "application/vnd.hp-hpgl",
	"hpid":                     "application/vnd.hp-hpid",
	"hps":                      "application/vnd.hp-hps",
	"hqx":                      "application/mac-binhex40",
	"htc":                      "text/x-component",
	"htke":                     "application/vnd.kenameaapp",
	"htm":                      "text/html",
	"html":                     "text/html",
	"hvd":                      "application/vnd.yamaha.hv-dic",
	"hvp":                      "application/vnd.yamaha.hv-voice",
	"hvs":                      "application/vnd.yamaha.hv-script",
	"i2g":                      "application/vnd.intergeo",
	"icc":                      "application/vnd.iccprofile",
	"ice":                      "x-conference/x-cooltalk",
	"icm":                      "application/vnd.iccprofile",
	"ico":                      "image/x-icon",
	"ics":                      "text/calendar",
	"ief":                      "image/ief",
	"ifb":                      "text/calendar",
	"ifm":                      "application/vnd.shana.informed.formdata",
	"iges":                     "model/iges",
	"igl":                      "application/vnd.igloader",
	"igm":                      "application/vnd.insors.igm",
	"igs":                      "model/iges",
	"igx":                      "application/vnd.micrografx.igx",
	"iif":                      "application/vnd.shana.informed.interchange",
	"img":                      "application/octet-stream",
	"imp":                      "application/vnd.accpac.simply.imp",
	"ims":                      "application/vnd.ms-ims",
	"in":                       "text/plain",
	"ini":                      "text/plain",
	"ink":                      "application/inkml+xml",
	"inkml":                    "application/inkml+xml",
	"install":                  "application/x-install-instructions",
	"iota":                     "application/vnd.astraea-software.iota",
	"ipfix":                    "application/ipfix",
	"ipk":                      "application/vnd.shana.informed.package",
	"irm":                      "application/vnd.ibm.rights-management",
	"irp":                      "application/vnd.irepository.package+xml",
	"iso":                      "application/x-iso9660-image",
	"itp":                      "application/vnd.shana.informed.formtemplate",
	"ivp":                      "application/vnd.immervision-ivp",
	"ivu":                      "application/vnd.immervision-ivu",
	"jad":                      "text/vnd.sun.j2me.app-descriptor",
	"jade":                     "text/jade",
	"jam":                      "application/vnd.jam",
	"jar":                      "application/java-archive",
	"jardiff":                  "application/x-java-archive-diff",
	"java":                     "text/x-java-source",
	"jisp":                     "application/vnd.jisp",
	"jls":                      "image/jls",
	"jlt":                      "application/vnd.hp-jlyt",
	"jng":                      "image/x-jng",
	"jnlp":                     "application/x-java-jnlp-file",
	"joda":                     "application/vnd.joost.joda-archive",
	"jp2":                      "image/jp2",
	"jpe":                      "image/jpeg",
	"jpeg":                     "image/jpeg",
	"jpf":                      "image/jpx",
	"jpg":                      "image/jpeg",
	"jpg2":                     "image/jp2",
	"jpgm":                     "video/jpm",
	"jpgv":                     "video/jpeg",
	"jpm":                      "video/jpm",
	"jpx":                      "image/jpx",
	"js":                       "application/javascript",
	"json":                     "application/json",
	"json5":                    "application/json5",
	"jsonld":                   "application/ld+json",
	"jsonml":                   "application/jsonml+json",
	"jsx":                      "text/jsx",
	"k25":                      "image/x-kodak-k25",
	"kar":                      "audio/midi",
	"karbon":                   "application/vnd.kde.karbon",
	"kdc":                      "image/x-kodak-kdc",
	"keynote":                  "application/vnd.apple.keynote",
	"kfo":                      "application/vnd.kde.kformula",
	"kia":                      "application/vnd.kidspiration",
	"kml":                      "application/vnd.google-earth.kml+xml",
	"kmz":                      "application/vnd.google-earth.kmz",
	"kne":                      "application/vnd.kinar",
	"knp":                      "application/vnd.kinar",
	"kon":                      "application/vnd.kde.kontour",
	"kpr":                      "application/vnd.kde.kpresenter",
	"kpt":                      "application/vnd.kde.kpresenter",
	"kpxx":                     "application/vnd.ds-keypoint",
	"ksp":                      "application/vnd.kde.kspread",
	"ktr":                      "application/vnd.kahootz",
	"ktx":                      "image/ktx",
	"ktz":                      "application/vnd.kahootz",
	"kwd":                      "application/vnd.kde.kword",
	"kwt":                      "application/vnd.kde.kword",
	"lasxml":                   "application/vnd.las.las+xml",
	"latex":                    "application/x-latex",
	"lbd":                      "application/vnd.llamagraphics.life-balance.desktop",
	"lbe":                      "application/vnd.llamagraphics.life-balance.exchange+xml",
	"les":                      "application/vnd.hhe.lesson-player",
	"less":                     "text/less",
	"lha":                      "application/x-lzh-compressed",
	"link66":                   "application/vnd.route66.link66+xml",
	"list":                     "text/plain",
	"list3820":                 "application/vnd.ibm.modcap",
	"listafp":                  "application/vnd.ibm.modcap",
	"litcoffee":                "text/coffeescript",
	"lnk":                      "application/x-ms-shortcut",
	"log":                      "text/plain",
	"lostxml":                  "application/lost+xml",
	"lrf":                      "application/octet-stream",
	"lrm":                      "application/vnd.ms-lrm",
	"ltf":                      "application/vnd.frogans.ltf",
	"lua":                      "text/x-lua",
	"luac":                     "application/x-lua-bytecode",
	"lvp":                      "audio/vnd.lucent.voice",
	"lwp":                      "application/vnd.lotus-wordpro",
	"lzh":                      "application/x-lzh-compressed",
	"m13":                      "application/x-msmediaview",
	"m14":                      "application/x-msmediaview",
	"m1v":                      "video/mpeg",
	"m21":                      "application/mp21",
	"m2a":                      "audio/mpeg",
	"m2v":                      "video/mpeg",
	"m3a":                      "audio/mpeg",
	"m3u":                      "audio/x-mpegurl",
	"m3u8":                     "application/vnd.apple.mpegurl",
	"m4a":                      "audio/x-m4a",
	"m4p":                      "application/mp4",
	"m4u":                      "video/vnd.mpegurl",
	"m4v":                      "video/x-m4v",
	"ma":                       "application/mathematica",
	"mads":                     "application/mads+xml",
	"mag":                      "application/vnd.ecowin.chart",
	"maker":                    "application/vnd.framemaker",
	"man":                      "text/troff",
	"manifest":                 "text/cache-manifest",
	"map":                      "application/json",
	"mar":                      "application/octet-stream",
	"markdown":                 "text/markdown",
	"mathml":                   "application/mathml+xml",
	"mb":                       "application/mathematica",
	"mbk":                      "application/vnd.mobius.mbk",
	"mbox":                     "application/mbox",
	"mc1":                      "application/vnd.medcalcdata",
	"mcd":                      "application/vnd.mcd",
	"mcurl":                    "text/vnd.curl.mcurl",
	"md":                       "text/markdown",
	"mdb":                      "application/x-msaccess",
	"mdi":                      "image/vnd.ms-modi",
	"me":                       "text/troff",
	"mesh":                     "model/mesh",
	"meta4":                    "application/metalink4+xml",
	"metalink":                 "application/metalink+xml",
	"mets":                     "application/mets+xml",
	"mfm":                      "application/vnd.mfmp",
	"mft":                      "application/rpki-manifest",
	"mgp":                      "application/vnd.osgeo.mapguide.package",
	"mgz":                      "application/vnd.proteus.magazine",
	"mid":                      "audio/midi",
	"midi":                     "audio/midi",
	"mie":                      "application/x-mie",
	"mif":                      "application/vnd.mif",
	"mime":                     "message/rfc822",
	"mj2":                      "video/mj2",
	"mjp2":                     "video/mj2",
	"mjs":                      "application/javascript",
	"mk3d":                     "video/x-matroska",
	"mka":                      "audio/x-matroska",
	"mkd":                      "text/x-markdown",
	"mks":                      "video/x-matroska",
	"mkv":                      "video/x-matroska",
	"mlp":                      "application/vnd.dolby.mlp",
	"mmd":                      "application/vnd.chipnuts.karaoke-mmd",
	"mmf":                      "application/vnd.smaf",
	"mml":                      "text/mathml",
	"mmr":                      "image/vnd.fujixerox.edmics-mmr",
	"mng":                      "video/x-mng",
	"mny":                      "application/x-msmoney",
	"mobi":                     "application/x-mobipocket-ebook",
	"mods":                     "application/mods+xml",
	"mov":                      "video/quicktime",
	"movie":                    "video/x-sgi-movie",
	"mp2":                      "audio/mpeg",
	"mp21":                     "application/mp21",
	"mp2a":                     "audio/mpeg",
	"mp3":                      "audio/mpeg",
	"mp4":                      "video/mp4",
	"mp4a":                     "audio/mp4",
	"mp4s":                     "application/mp4",
	"mp4v":                     "video/mp4",
	"mpc":                      "application/vnd.mophun.certificate",
	"mpd":                      "application/dash+xml",
	"mpe":                      "video/mpeg",
	"mpeg":                     "video/mpeg",
	"mpg":                      "video/mpeg",
	"mpg4":                     "video/mp4",
	"mpga":                     "audio/mpeg",
	"mpkg":                     "application/vnd.apple.installer+xml",
	"mpm":                      "application/vnd.blueice.multipass",
	"mpn":                      "application/vnd.mophun.application",
	"mpp":                      "application/vnd.ms-project",
	"mpt":                      "application/vnd.ms-project",
	"mpy":                      "application/vnd.ibm.minipay",
	"mqy":                      "application/vnd.mobius.mqy",
	"mrc":                      "application/marc",
	"mrcx":                     "application/marcxml+xml",
	"mrw":                      "image/x-minolta-mrw",
	"ms":                       "text/troff",
	"mscml":                    "application/mediaservercontrol+xml",
	"mseed":                    "application/vnd.fdsn.mseed",
	"mseq":                     "application/vnd.mseq",
	"msf":                      "application/vnd.epson.msf",
	"msg":                      "application/vnd.ms-outlook",
	"msh":                      "model/mesh",
	"msi":                      "application/x-msdownload",
	"msl":                      "application/vnd.mobius.msl",
	"msm":                      "application/octet-stream",
	"msp":                      "application/octet-stream",
	"msty":                     "application/vnd.muvee.style",
	"mts":                      "model/vnd.mts",
	"mus":                      "application/vnd.musician",
	"musicxml":                 "application/vnd.recordare.musicxml+xml",
	"mvb":                      "application/x-msmediaview",
	"mwf":                      "application/vnd.mfer",
	"mxf":                      "application/mxf",
	"mxl":                      "application/vnd.recordare.musicxml",
	"mxml":                     "application/xv+xml",
	"mxs":                      "application/vnd.triscape.mxs",
	"mxu":                      "video/vnd.mpegurl",
	"n-gage":                   "application/vnd.nokia.n-gage.symbian.install",
	"n3":                       "text/n3",
	"nb":                       "application/mathematica",
	"nbp":                      "application/vnd.wolfram.player",
	"nc":                       "application/x-netcdf",
	"ncx":                      "application/x-dtbncx+xml",
	"nef":                      "image/x-nikon-nef",
	"nfo":                      "text/x-nfo",
	"ngdat":                    "application/vnd.nokia.n-gage.data",
	"nitf":                     "application/vnd.nitf",
	"nlu":                      "application/vnd.neurolanguage.nlu",
	"nml":                      "application/vnd.enliven",
	"nnd":                      "application/vnd.noblenet-directory",
	"nns":                      "application/vnd.noblenet-sealer",
	"nnw":                      "application/vnd.noblenet-web",
	"npx":                      "image/vnd.net-fpx",
	"nsc":                      "application/x-conference",
	"nsf":                      "application/vnd.lotus-notes",
	"ntf":                      "application/vnd.nitf",
	"numbers":                  "application/vnd.apple.numbers",
	"nzb":                      "application/x-nzb",
	"oa2":                      "application/vnd.fujitsu.oasys2",
	"oa3":                      "application/vnd.fujitsu.oasys3",
	"oas":                      "application/vnd.fujitsu.oasys",
	"obd":                      "application/x-msbinder",
	"obj":                      "application/x-tgif",
	"oda":                      "application/oda",
	"odb":                      "application/vnd.oasis.opendocument.database",
	"odc":                      "application/vnd.oasis.opendocument.chart",
	"odf":                      "application/vnd.oasis.opendocument.formula",
	"odft":                     "application/vnd.oasis.opendocument.formula-template",
	"odg":                      "application/vnd.oasis.opendocument.graphics",
	"odi":                      "application/vnd.oasis.opendocument.image",
	"odm":                      "application/vnd.oasis.opendocument.text-master",
	"odp":                      "application/vnd.oasis.opendocument.presentation",
	"ods":                      "application/vnd.oasis.opendocument.spreadsheet",
	"odt":                      "application/vnd.oasis.opendocument.text",
	"oga":                      "audio/ogg",
	"ogg":                      "audio/ogg",
	"ogv":                      "video/ogg",
	"ogx":                      "application/ogg",
	"omdoc":                    "application/omdoc+xml",
	"onepkg":                   "application/onenote",
	"onetmp":                   "application/onenote",
	"onetoc":                   "application/onenote",
	"onetoc2":                  "application/onenote",
	"opf":                      "application/oebps-package+xml",
	"opml":                     "text/x-opml",
	"oprc":                     "application/vnd.palm",
	"orf":                      "image/x-olympus-orf",
	"org":                      "text/x-org",
	"osf":                      "application/vnd.yamaha.openscoreformat",
	"osfpvg":                   "application/vnd.yamaha.openscoreformat.osfpvg+xml",
	"otc":                      "application/vnd.oasis.opendocument.chart-template",
	"otf":                      "font/otf",
	"otg":                      "application/vnd.oasis.opendocument.graphics-template",
	"oth":                      "application/vnd.oasis.opendocument.text-web",
	"oti":                      "application/vnd.oasis.opendocument.image-template",
	"otp":                      "application/vnd.oasis.opendocument.presentation-template",
	"ots":                      "application/vnd.oasis.opendocument.spreadsheet-template",
	"ott":                      "application/vnd.oasis.opendocument.text-template",
	"ova":                      "application/x-virtualbox-ova",
	"ovf":                      "application/x-virtualbox-ovf",
	"owl":                      "application/rdf+xml",
	"oxps":                     "application/oxps",
	"oxt":                      "application/vnd.openofficeorg.extension",
	"p":                        "text/x-pascal",
	"p10":                      "application/pkcs10",
	"p12":                      "application/x-pkcs12",
	"p7b":                      "application/x-pkcs7-certificates",
	"p7c":                      "application/pkcs7-mime",
	"p7m":                      "application/pkcs7-mime",
	"p7r":                      "application/x-pkcs7-certreqresp",
	"p7s":                      "application/pkcs7-signature",
	"p8":                       "application/pkcs8",
	"pac":                      "application/x-ns-proxy-autoconfig",
	"pages":                    "application/vnd.apple.pages",
	"pas":                      "text/x-pascal",
	"paw":                      "application/vnd.pawaafile",
	"pbd":                      "application/vnd.powerbuilder6",
	"pbm":                      "image/x-portable-bitmap",
	"pcap":                     "application/vnd.tcpdump.pcap",
	"pcf":                      "application/x-font-pcf",
	"pcl":                      "application/vnd.hp-pcl",
	"pclxl":                    "application/vnd.hp-pclxl",
	"pct":                      "image/x-pict",
	"pcurl":                    "application/vnd.curl.pcurl",
	"pcx":                      "image/x-pcx",
	"pdb":                      "application/x-pilot",
	"pde":                      "text/x-processing",
	"pdf":                      "application/pdf",
	"pef":                      "image/x-pentax-pef",
	"pem":                      "application/x-x509-ca-cert",
	"pfa":                      "application/x-font-type1",
	"pfb":                      "application/x-font-type1",
	"pfm":                      "application/x-font-type1",
	"pfr":                      "application/font-tdpfr",
	"pfx":                      "application/x-pkcs12",
	"pgm":                      "image/x-portable-graymap",
	"pgn":                      "application/x-chess-pgn",
	"pgp":                      "application/pgp-encrypted",
	"php":                      "application/x-httpd-php",
	"pic":                      "image/x-pict",
	"pkg":                      "application/octet-stream",
	"pki":                      "application/pkixcmp",
	"pkipath":                  "application/pkix-pkipath",
	"pkpass":                   "application/vnd.apple.pkpass",
	"pl":                       "application/x-perl",
	"plb":                      "application/vnd.3gpp.pic-bw-large",
	"plc":                      "application/vnd.mobius.plc",
	"plf":                      "application/vnd.pocketlearn",
	"pls":                      "application/pls+xml",
	"pm":                       "application/x-perl",
	"pml":                      "application/vnd.ctc-posml",
	"png":                      "image/png",
	"pnm":                      "image/x-portable-anymap",
	"portpkg":                  "application/vnd.macports.portpkg",
	"pot":                      "application/vnd.ms-powerpoint",
	"potm":                     "application/vnd.ms-powerpoint.template.macroenabled.12",
	"potx":                     "application/vnd.openxmlformats-officedocument.presentationml.template",
	"ppam":                     "application/vnd.ms-powerpoint.addin.macroenabled.12",
	"ppd":                      "application/vnd.cups-ppd",
	"ppm":                      "image/x-portable-pixmap",
	"pps":                      "application/vnd.ms-powerpoint",
	"ppsm":                     "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
	"ppsx":                     "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
	"ppt":                      "application/vnd.ms-powerpoint",
	"pptm":                     "application/vnd.ms-powerpoint.presentation.macroenabled.12",
	"pptx":                     "application/vnd.openxmlformats-officedocument.presentationml.presentation",
	"pqa":                      "application/vnd.palm",
	"prc":                      "application/x-pilot",
	"pre":                      "application/vnd.lotus-freelance",
	"prf":                      "application/pics-rules",
	"ps":                       "application/postscript",
	"psb":                      "application/vnd.3gpp.pic-bw-small",
	"psd":                      "image/vnd.adobe.photoshop",
	"psf":                      "application/x-font-linux-psf",
	"pskcxml":                  "application/pskc+xml",
	"pti":                      "image/prs.pti",
	"ptid":                     "application/vnd.pvi.ptid1",
	"pub":                      "application/x-mspublisher",
	"pvb":                      "application/vnd.3gpp.pic-bw-var",
	"pwn":                      "application/vnd.3m.post-it-notes",
	"pya":                      "audio/vnd.ms-playready.media.pya",
	"pyv":                      "video/vnd.ms-playready.media.pyv",
	"qam":                      "application/vnd.epson.quickanime",
	"qbo":                      "application/vnd.intu.qbo",
	"qfx":                      "application/vnd.intu.qfx",
	"qps":                      "application/vnd.publishare-delta-tree",
	"qt":                       "video/quicktime",
	"qwd":                      "application/vnd.quark.quarkxpress",
	"qwt":                      "application/vnd.quark.quarkxpress",
	"qxb":                      "application/vnd.quark.quarkxpress",
	"qxd":                      "application/vnd.quark.quarkxpress",
	"qxl":                      "application/vnd.quark.quarkxpress",
	"qxt":                      "application/vnd.quark.quarkxpress",
	"ra":                       "audio/x-realaudio",
	"raf":                      "image/x-fuji-raf",
	"ram":                      "audio/x-pn-realaudio",
	"raml":                     "application/raml+yaml",
	"rar":                      "application/x-rar-compressed",
	"ras":                      "image/x-cmu-raster",
	"raw":                      "image/x-panasonic-raw",
	"rcprofile":                "application/vnd.ipunplugged.rcprofile",
	"rdf":                      "application/rdf+xml",
	"rdz":                      "application/vnd.data-vision.rdz",
	"rep":                      "application/vnd.businessobjects",
	"res":                      "application/x-dtbresource+xml",
	"rgb":                      "image/x-rgb",
	"rif":                      "application/reginfo+xml",
	"rip":                      "audio/vnd.rip",
	"ris":                      "application/x-research-info-systems",
	"rl":                       "application/resource-lists+xml",
	"rlc":                      "image/vnd.fujixerox.edmics-rlc",
	"rld":                      "application/resource-lists-diff+xml",
	"rm":                       "application/vnd.rn-realmedia",
	"rmi":                      "audio/midi",
	"rmp":                      "audio/x-pn-realaudio-plugin",
	"rms":                      "application/vnd.jcp.javame.midlet-rms",
	"rmvb":                     "application/vnd.rn-realmedia-vbr",
	"rnc":                      "application/relax-ng-compact-syntax",
	"rng":                      "application/xml",
	"roa":                      "application/rpki-roa",
	"roff":                     "text/troff",
	"rp9":                      "application/vnd.cloanto.rp9",
	"rpm":                      "application/x-redhat-package-manager",
	"rpss":                     "application/vnd.nokia.radio-presets",
	"rpst":                     "application/vnd.nokia.radio-preset",
	"rq":                       "application/sparql-query",
	"rs":                       "application/rls-services+xml",
	"rsd":                      "application/rsd+xml",
	"rss":                      "application/rss+xml",
	"rtf":                      "text/rtf",
	"rtx":                      "text/richtext",
	"run":                      "application/x-makeself",
	"s":                        "text/x-asm",
	"s3m":                      "audio/s3m",
	"saf":                      "application/vnd.yamaha.smaf-audio",
	"sass":                     "text/x-sass",
	"sbml":                     "application/sbml+xml",
	"sc":                       "application/vnd.ibm.secure-container",
	"scd":                      "application/x-msschedule",
	"scm":                      "application/vnd.lotus-screencam",
	"scq":                      "application/scvp-cv-request",
	"scs":                      "application/scvp-cv-response",
	"scss":                     "text/x-scss",
	"scurl":                    "text/vnd.curl.scurl",
	"sda":                      "application/vnd.stardivision.draw",
	"sdc":                      "application/vnd.stardivision.calc",
	"sdd":                      "application/vnd.stardivision.impress",
	"sdkd":                     "application/vnd.solent.sdkm+xml",
	"sdkm":                     "application/vnd.solent.sdkm+xml",
	"sdp":                      "application/sdp",
	"sdw":                      "application/vnd.stardivision.writer",
	"sea":                      "application/x-sea",
	"see":                      "application/vnd.seemail",
	"seed":                     "application/vnd.fdsn.seed",
	"sema":                     "application/vnd.sema",
	"semd":                     "application/vnd.semd",
	"semf":                     "application/vnd.semf",
	"ser":                      "application/java-serialized-object",
	"setpay":                   "application/set-payment-initiation",
	"setreg":                   "application/set-registration-initiation",
	"sfd-hdstx":                "application/vnd.hydrostatix.sof-data",
	"sfs":                      "application/vnd.spotfire.sfs",
	"sfv":                      "text/x-sfv",
	"sgi":                      "image/sgi",
	"sgl":                      "application/vnd.stardivision.writer-global",
	"sgm":                      "text/sgml",
	"sgml":                     "text/sgml",
	"sh":                       "application/x-sh",
	"shar":                     "application/x-shar",
	"shex":                     "text/shex",
	"shf":                      "application/shf+xml",
	"shtml":                    "text/html",
	"sid":                      "image/x-mrsid-image",
	"sig":                      "application/pgp-signature",
	"sil":                      "audio/silk",
	"silo":                     "model/mesh",
	"sis":                      "application/vnd.symbian.install",
	"sisx":                     "application/vnd.symbian.install",
	"sit":                      "application/x-stuffit",
	"sitx":                     "application/x-stuffitx",
	"skd":                      "application/vnd.koan",
	"skm":                      "application/vnd.koan",
	"skp":                      "application/vnd.koan",
	"skt":                      "application/vnd.koan",
	"sldm":                     "application/vnd.ms-powerpoint.slide.macroenabled.12",
	"sldx":                     "application/vnd.openxmlformats-officedocument.presentationml.slide",
	"slim":                     "text/slim",
	"slm":                      "text/slim",
	"slt":                      "application/vnd.epson.salt",
	"sm":                       "application/vnd.stepmania.stepchart",
	"smf":                      "application/vnd.stardivision.math",
	"smi":                      "application/smil+xml",
	"smil":                     "application/smil+xml",
	"smv":                      "video/x-smv",
	"smzip":                    "application/vnd.stepmania.package",
	"snd":                      "audio/basic",
	"snf":                      "application/x-font-snf",
	"so":                       "application/octet-stream",
	"spc":                      "application/x-pkcs7-certificates",
	"spf":                      "application/vnd.yamaha.smaf-phrase",
	"spl":                      "application/x-futuresplash",
	"spot":                     "text/vnd.in3d.spot",
	"spp":                      "application/scvp-vp-response",
	"spq":                      "application/scvp-vp-request",
	"spx":                      "audio/ogg",
	"sql":                      "application/x-sql",
	"sr2":                      "image/x-sony-sr2",
	"src":                      "application/x-wais-source",
	"srf":                      "image/x-sony-srf",
	"srt":                      "application/x-subrip",
	"sru":                      "application/sru+xml",
	"srx":                      "application/sparql-results+xml",
	"ssdl":                     "application/ssdl+xml",
	"sse":                      "application/vnd.kodak-descriptor",
	"ssf":                      "application/vnd.epson.ssf",
	"ssml":                     "application/ssml+xml",
	"st":                       "application/vnd.sailingtracker.track",
	"stc":                      "application/vnd.sun.xml.calc.template",
	"std":                      "application/vnd.sun.xml.draw.template",
	"stf":                      "application/vnd.wt.stf",
	"sti":                      "application/vnd.sun.xml.impress.template",
	"stk":                      "application/hyperstudio",
	"stl":                      "application/vnd.ms-pki.stl",
	"str":                      "application/vnd.pg.format",
	"stw":                      "application/vnd.sun.xml.writer.template",
	"styl":                     "text/stylus",
	"stylus":                   "text/stylus",
	"sub":                      "text/vnd.dvb.subtitle",
	"sus":                      "application/vnd.sus-calendar",
	"susp":                     "application/vnd.sus-calendar",
	"sv4cpio":                  "application/x-sv4cpio",
	"sv4crc":                   "application/x-sv4crc",
	"svc":                      "application/vnd.dvb.service",
	"svd":                      "application/vnd.svd",
	"svg":                      "image/svg+xml",
	"svgz":                     "image/svg+xml",
	"swa":                      "application/x-director",
	"swf":                      "application/x-shockwave-flash",
	"swi":                      "application/vnd.aristanetworks.swi",
	"sxc":                      "application/vnd.sun.xml.calc",
	"sxd":                      "application/vnd.sun.xml.draw",
	"sxg":                      "application/vnd.sun.xml.writer.global",
	"sxi":                      "application/vnd.sun.xml.impress",
	"sxm":                      "application/vnd.sun.xml.math",
	"sxw":                      "application/vnd.sun.xml.writer",
	"t":                        "text/troff",
	"t3":                       "application/x-t3vm-image",
	"t38":                      "image/t38",
	"taglet":                   "application/vnd.mynfc",
	"tao":                      "application/vnd.tao.intent-module-archive",
	"tap":                      "image/vnd.tencent.tap",
	"tar":                      "application/x-tar",
	"tcap":                     "application/vnd.3gpp2.tcap",
	"tcl":                      "application/x-tcl",
	"teacher":                  "application/vnd.smart.teacher",
	"tei":                      "application/tei+xml",
	"teicorpus":                "application/tei+xml",
	"tex":                      "application/x-tex",
	"texi":                     "application/x-texinfo",
	"texinfo":                  "application/x-texinfo",
	"text":                     "text/plain",
	"tfi":                      "application/thraud+xml",
	"tfm":                      "application/x-tex-tfm",
	"tfx":                      "image/tiff-fx",
	"tga":                      "image/x-tga",
	"thmx":                     "application/vnd.ms-officetheme",
	"tif":                      "image/tiff",
	"tiff":                     "image/tiff",
	"tk":                       "application/x-tcl",
	"tmo":                      "application/vnd.tmobile-livetv",
	"torrent":                  "application/x-bittorrent",
	"tpl":                      "application/vnd.groove-tool-template",
	"tpt":                      "application/vnd.trid.tpt",
	"tr":                       "text/troff",
	"tra":                      "application/vnd.trueapp",
	"trm":                      "application/x-msterminal",
	"ts":                       "video/mp2t",
	"tsd":                      "application/timestamped-data",
	"tsv":                      "text/tab-separated-values",
	"ttc":                      "font/collection",
	"ttf":                      "font/ttf",
	"ttl":                      "text/turtle",
	"twd":                      "application/vnd.simtech-mindmapper",
	"twds":                     "application/vnd.simtech-mindmapper",
	"txd":                      "application/vnd.genomatix.tuxedo",
	"txf":                      "application/vnd.mobius.txf",
	"txt":                      "text/plain",
	"u32":                      "application/x-authorware-bin",
	"u8dsn":                    "message/global-delivery-status",
	"u8hdr":                    "message/global-headers",
	"u8mdn":                    "message/global-disposition-notification",
	"u8msg":                    "message/global",
	"udeb":                     "application/x-debian-package",
	"ufd":                      "application/vnd.ufdl",
	"ufdl":                     "application/vnd.ufdl",
	"ulx":                      "application/x-glulx",
	"umj":                      "application/vnd.umajin",
	"unityweb":                 "application/vnd.unity",
	"uoml":                     "application/vnd.uoml+xml",
	"uri":                      "text/uri-list",
	"uris":                     "text/uri-list",
	"urls":                     "text/uri-list",
	"ustar":                    "application/x-ustar",
	"utz":                      "application/vnd.uiq.theme",
	"uu":                       "text/x-uuencode",
	"uva":                      "audio/vnd.dece.audio",
	"uvd":                      "application/vnd.dece.data",
	"uvf":                      "application/vnd.dece.data",
	"uvg":                      "image/vnd.dece.graphic",
	"uvh":                      "video/vnd.dece.hd",
	"uvi":                      "image/vnd.dece.graphic",
	"uvm":                      "video/vnd.dece.mobile",
	"uvp":                      "video/vnd.dece.pd",
	"uvs":                      "video/vnd.dece.sd",
	"uvt":                      "application/vnd.dece.ttml+xml",
	"uvu":                      "video/vnd.uvvu.mp4",
	"uvv":                      "video/vnd.dece.video",
	"uvva":                     "audio/vnd.dece.audio",
	"uvvd":                     "application/vnd.dece.data",
	"uvvf":                     "application/vnd.dece.data",
	"uvvg":                     "image/vnd.dece.graphic",
	"uvvh":                     "video/vnd.dece.hd",
	"uvvi":                     "image/vnd.dece.graphic",
	"uvvm":                     "video/vnd.dece.mobile",
	"uvvp":                     "video/vnd.dece.pd",
	"uvvs":                     "video/vnd.dece.sd",
	"uvvt":                     "application/vnd.dece.ttml+xml",
	"uvvu":                     "video/vnd.uvvu.mp4",
	"uvvv":                     "video/vnd.dece.video",
	"uvvx":                     "application/vnd.dece.unspecified",
	"uvvz":                     "application/vnd.dece.zip",
	"uvx":                      "application/vnd.dece.unspecified",
	"uvz":                      "application/vnd.dece.zip",
	"vbox":                     "application/x-virtualbox-vbox",
	"vbox-extpack":             "application/x-virtualbox-vbox-extpack",
	"vcard":                    "text/vcard",
	"vcd":                      "application/x-cdlink",
	"vcf":                      "text/x-vcard",
	"vcg":                      "application/vnd.groove-vcard",
	"vcs":                      "text/x-vcalendar",
	"vcx":                      "application/vnd.vcx",
	"vdi":                      "application/x-virtualbox-vdi",
	"vhd":                      "application/x-virtualbox-vhd",
	"vis":                      "application/vnd.visionary",
	"viv":                      "video/vnd.vivo",
	"vmdk":                     "application/x-virtualbox-vmdk",
	"vob":                      "video/x-ms-vob",
	"vor":                      "application/vnd.stardivision.writer",
	"vox":                      "application/x-authorware-bin",
	"vrml":                     "model/vrml",
	"vsd":                      "application/vnd.visio",
	"vsf":                      "application/vnd.vsf",
	"vss":                      "application/vnd.visio",
	"vst":                      "application/vnd.visio",
	"vsw":                      "application/vnd.visio",
	"vtf":                      "image/vnd.valve.source.texture",
	"vtt":                      "text/vtt",
	"vtu":                      "model/vnd.vtu",
	"vxml":                     "application/voicexml+xml",
	"w3d":                      "application/x-director",
	"wad":                      "application/x-doom",
	"wadl":                     "application/vnd.sun.wadl+xml",
	"war":                      "application/java-archive",
	"wasm":                     "application/wasm",
	"wav":                      "audio/x-wav",
	"wax":                      "audio/x-ms-wax",
	"wbmp":                     "image/vnd.wap.wbmp",
	"wbs":                      "application/vnd.criticaltools.wbs+xml",
	"wbxml":                    "application/vnd.wap.wbxml",
	"wcm":                      "application/vnd.ms-works",
	"wdb":                      "application/vnd.ms-works",
	"wdp":                      "image/vnd.ms-photo",
	"weba":                     "audio/webm",
	"webapp":                   "application/x-web-app-manifest+json",
	"webm":                     "video/webm",
	"webmanifest":              "application/manifest+json",
	"webp":                     "image/webp",
	"wg":                       "application/vnd.pmi.widget",
	"wgt":                      "application/widget",
	"wks":                      "application/vnd.ms-works",
	"wm":                       "video/x-ms-wm",
	"wma":                      "audio/x-ms-wma",
	"wmd":                      "application/x-ms-wmd",
	"wmf":                      "image/wmf",
	"wml":                      "text/vnd.wap.wml",
	"wmlc":                     "application/vnd.wap.wmlc",
	"wmls":                     "text/vnd.wap.wmlscript",
	"wmlsc":                    "application/vnd.wap.wmlscriptc",
	"wmv":                      "video/x-ms-wmv",
	"wmx":                      "video/x-ms-wmx",
	"wmz":                      "application/x-msmetafile",
	"woff":                     "font/woff",
	"woff2":                    "font/woff2",
	"wpd":                      "application/vnd.wordperfect",
	"wpl":                      "application/vnd.ms-wpl",
	"wps":                      "application/vnd.ms-works",
	"wqd":                      "application/vnd.wqd",
	"wri":                      "application/x-mswrite",
	"wrl":                      "model/vrml",
	"wsc":                      "message/vnd.wfa.wsc",
	"wsdl":                     "application/wsdl+xml",
	"wspolicy":                 "application/wspolicy+xml",
	"wtb":                      "application/vnd.webturbo",
	"wvx":                      "video/x-ms-wvx",
	"x32":                      "application/x-authorware-bin",
	"x3d":                      "model/x3d+xml",
	"x3db":                     "model/x3d+binary",
	"x3dbz":                    "model/x3d+binary",
	"x3dv":                     "model/x3d+vrml",
	"x3dvz":                    "model/x3d+vrml",
	"x3dz":                     "model/x3d+xml",
	"x3f":                      "image/x-sigma-x3f",
	"xaml":                     "application/xaml+xml",
	"xap":                      "application/x-silverlight-app",
	"xar":                      "application/vnd.xara",
	"xbap":                     "application/x-ms-xbap",
	"xbd":                      "application/vnd.fujixerox.docuworks.binder",
	"xbm":                      "image/x-xbitmap",
	"xdf":                      "application/xcap-diff+xml",
	"xdm":                      "application/vnd.syncml.dm+xml",
	"xdp":                      "application/vnd.adobe.xdp+xml",
	"xdssc":                    "application/dssc+xml",
	"xdw":                      "application/vnd.fujixerox.docuworks",
	"xenc":                     "application/xenc+xml",
	"xer":                      "application/patch-ops-error+xml",
	"xfdf":                     "application/vnd.adobe.xfdf",
	"xfdl":                     "application/vnd.xfdl",
	"xht":                      "application/xhtml+xml",
	"xhtml":                    "application/xhtml+xml",
	"xhvml":                    "application/xv+xml",
	"xif":                      "image/vnd.xiff",
	"xla":                      "application/vnd.ms-excel",
	"xlam":                     "application/vnd.ms-excel.addin.macroenabled.12",
	"xlc":                      "application/vnd.ms-excel",
	"xlf":                      "application/x-xliff+xml",
	"xlm":                      "application/vnd.ms-excel",
	"xls":                      "application/vnd.ms-excel",
	"xlsb":                     "application/vnd.ms-excel.sheet.binary.macroenabled.12",
	"xlsm":                     "application/vnd.ms-excel.sheet.macroenabled.12",
	"xlsx":                     "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	"xlt":                      "application/vnd.ms-excel",
	"xltm":                     "application/vnd.ms-excel.template.macroenabled.12",
	"xltx":                     "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
	"xlw":                      "application/vnd.ms-excel",
	"xm":                       "audio/xm",
	"xml":                      "text/xml",
	"xo":                       "application/vnd.olpc-sugar",
	"xop":                      "application/xop+xml",
	"xpi":                      "application/x-xpinstall",
	"xpl":                      "application/xproc+xml",
	"xpm":                      "image/x-xpixmap",
	"xpr":                      "application/vnd.is-xpr",
	"xps":                      "application/vnd.ms-xpsdocument",
	"xpw":                      "application/vnd.intercon.formnet",
	"xpx":                      "application/vnd.intercon.formnet",
	"xsd":                      "application/xml",
	"xsl":                      "application/xml",
	"xslt":                     "application/xslt+xml",
	"xsm":                      "application/vnd.syncml+xml",
	"xspf":                     "application/xspf+xml",
	"xul":                      "application/vnd.mozilla.xul+xml",
	"xvm":                      "application/xv+xml",
	"xvml":                     "application/xv+xml",
	"xwd":                      "image/x-xwindowdump",
	"xyz":                      "chemical/x-xyz",
	"xz":                       "application/x-xz",
	"yaml":                     "text/yaml",
	"yang":                     "application/yang",
	"yin":                      "application/yin+xml",
	"yml":                      "text/yaml",
	"ymp":                      "text/x-suse-ymp",
	"z1":                       "application/x-zmachine",
	"z2":                       "application/x-zmachine",
	"z3":                       "application/x-zmachine",
	"z4":                       "application/x-zmachine",
	"z5":                       "application/x-zmachine",
	"z6":                       "application/x-zmachine",
	"z7":                       "application/x-zmachine",
	"z8":                       "application/x-zmachine",
	"zaz":                      "application/vnd.zzazz.deck+xml",
	"zip":                      "application/zip",
	"zir":                      "application/vnd.zul",
	"zirz":                     "application/vnd.zul",
	"zmm":                      "application/vnd.handheld-entertainment+xml",
}"
}
{
file:./api/helpers/mime/file.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mime

import (
	"fmt"
	"github.com/ainsleyclark/verbis/api/errors"
	"github.com/gabriel-vasile/mimetype"
	"mime/multipart"
)

// Get the mime type by opening the file
// Returns errors.INTERNAL if the file could not be opened.
// Returns errors.NOTFOUND if the mime type was not found.
func TypeByFile(file *multipart.FileHeader) (string, error) {
	const op = "mime.TypeByFile"

	reader, err := file.Open()
	if err != nil {
		return "", &errors.Error{Code: errors.INTERNAL, Message: fmt.Sprintf("Unable to open file with the name: %s", file.Filename), Operation: op, Err: err}
	}
	defer reader.Close()

	mime, err := mimetype.DetectReader(reader)
	if err != nil {
		return "", &errors.Error{Code: errors.NOTFOUND, Message: fmt.Sprintf("Mime type not found: %s", mime), Operation: op, Err: err}
	}

	return mime.String(), nil
}

// IsValidMime checks a whitelist of MIME types
// Returns true if the file is in the whitelist.
func IsValidMime(allowed []string, mime string) bool {
	if mimetype.EqualsAny(mime, allowed...) {
		return true
	}
	return false
}"
}
{
file:./api/cron/schedule.go
contents:
"// Copyright 2020 The Verbis Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cron

import (
	"github.com/ainsleyclark/verbis/api/models"
	"github.com/ainsleyclark/verbis/api/render"
	"github.com/jasonlvhit/gocron"
	log "github.com/sirupsen/logrus"
)

// Scheduler defines all necessary cron jobs for the application
// when running.
type Scheduler struct {
	store *models.Store
}

// New - Construct for a new Scheduler
func New(m *models.Store) *Scheduler {
	return &Scheduler{
		store: m,
	}
}

// Run all cron jobs
func (s *Scheduler) Run() {

	// Clean password resets table every 15 minutes
	if err := gocron.Every(15).Minutes().Do(s.store.Auth.CleanPasswordResets); err != nil {
		log.WithFields(log.Fields{
			"error": err,
		}).Error()
	}

	// Clean sitemap cache
	if err := gocron.Every(6).Hours().Do(render.NewSitemap(s.store).ClearCache); err != nil {
		log.WithFields(log.Fields{
			"error": err,
		}).Error()
	}

	// Start all the pending jobs
	<-gocron.Start()
}"
}
{
file:./main.go
contents:
"/*
Copyright  2020 NAME HERE ainsley@reddico.co.uk

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main

import (
	"github.com/ainsleyclark/verbis/api/cmd"
	"runtime"
)

func main() {
	// Execute Verbis
	runtime.GOMAXPROCS(runtime.NumCPU())
	cmd.Execute()
}"
}
